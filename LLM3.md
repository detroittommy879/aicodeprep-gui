Yes. You can design a compact, human‑friendly DSL (domain‑specific language) that encodes only the flow logic (which nodes exist and how they connect) and the essential per‑node settings. Then you can write a small converter that turns that DSL into your existing flow.json format. A YAML-based approach is a good fit here because it’s easy for people to read and write.

What the compact language would cover
- Node definitions (type, name, and the important settings for that node)
- How nodes are connected (which port goes to which port)
- Optional high‑level flow options (e.g., whether the graph is acyclic)
- No need to encode colors, positions, or UI layout; those can be generated by the GUI if needed

Proposed DSL design (YAML)
- Flow file contains one or more flows
- Each flow has:
  - nodes: a mapping or a list of nodes with a stable id
  - connections: a list describing edges with from and to ports
  - optional per‑node config (the “custom” fields you already use)

Example: compact flow.yaml (human-friendly, no UI details)
flow:
  version: 1.0
  name: Best-of-3
  nodes:
    ctx:
      type_: aicp.flow.ContextOutputNode
      name: "Context Output: fullcode.txt"
      config:
        path: "fullcode.txt"
        use_latest_generated: true
    llm1:
      type_: aicp.flow.OpenRouterNode
      name: "gpt-5-codex"
      config:
        provider: "openrouter"
        model_mode: "choose"
        model: "openai/gpt-5-codex"
        base_url: "https://openrouter.ai/api/v1"
        output_file: "LLM1.md"
        temperature: 0.7
        top_p: 1.0
    llm2:
      type_: aicp.flow.OpenRouterNode
      name: "qwen3-next-80b-a3..."
      config:
        provider: "openrouter"
        model_mode: "choose"
        model: "qwen/qwen3-next-80b-a3b-thinking"
        base_url: "https://openrouter.ai/api/v1"
        output_file: "LLM2.md"
        temperature: 0.7
        top_p: 1.0
    synth:
      type_: aicp.flow.BestOfNNode
      name: "Best-of-N Synthesizer"
      config:
        model: "google/gemini-2.5-pro"
        model_mode: "choose"
        extra_prompt: "You are an expert coder... (long prompt omitted)"
        # other synthesizer params can go here
    clip:
      type_: aicp.flow.ClipboardNode
      name: "Clipboard"
  connections:
    - from: { node: "ctx", port: "text" }
      to: { node: "llm1", port: "text" }
    - from: { node: "ctx", port: "text" }
      to: { node: "llm2", port: "text" }
    - from: { node: "llm1", port: "text" }
      to: { node: "synth", port: "text" }
    - from: { node: "llm2", port: "text" }
      to: { node: "synth", port: "text" }
    - from: { node: "synth", port: "text" }
      to: { node: "clip", port: "text" }

Notes
- Ports: I used a common port name "text" for inputs/outputs that the current flow.json uses. You can standardize on this across your nodes to simplify the DSL.
- UI details are omitted on purpose (colors, positions, sizes, layout_direction). The GUI can render automatically or you can keep those fields optional in the DSL.
- If you want multiple flows in one file, you can add a top-level flows: [ ... ] array and give each a separate id/name.

A minimal alternative (JSON-like but still readable)
If you prefer not to use YAML, you can use a JSON‑like structure with the same semantics, but YAML tends to be more readable for people writing flows by hand.

Mapping to your current flow.json
- flow.json’s top-level graph and global options can be kept, or defaulted by the converter.
- nodes: each entry in the YAML “nodes” list becomes an entry in the flow.json "nodes" map with the same id and a converted "type_" and "custom"/"config" content.
  - type_ gets the node’s type_ from the DSL (e.g., aicp.flow.OpenRouterNode)
  - custom/config content maps to the per-node configuration (model, base_url, output_file, etc.)
- connections: each edge is converted to the flow.json "connections" entries with out/in specifying [node, port].

Implementation plan (quick, reusable)
1) Pick a format you like (YAML is recommended for readability).
2) Define a tiny schema (as shown above) and keep it stable.
3) Write a small converter (Python or JS) that:
   - Reads flow.yaml
   - Builds a Python/JS object that matches flow.json’s structure
   - Ignores optional UI fields (only keeps essential fields)
   - Writes flow.json
4) Validate with your GUI:
   - Load the generated flow.json in the GUI and verify the graph appears as intended
   - If needed, add a second step to generate default positions and sizes if the GUI requires them
5) Optional: add comments to YAML to explain non-obvious choices, and keep versions in a top-level “version” field to help future migrations.

A ready-to-build converter (high level)
- Language: Python (or JavaScript)
- Input: flow.yaml
- Output: flow.json
- Key steps:
  - Parse YAML (PyYAML)
  - Build a dict: { graph: { ... }, nodes: { id: { ... } }, connections: [ ... ] }
  - Copy essential fields; ignore colors/positions
  - Save as flow.json

If you’d like, I can:
- tailor a compact YAML DSL specifically for your two flows (or for any number of flows you want),
- and provide a ready-to-run Python snippet that converts flow.yaml into flow.json,
- plus generate concrete flow.yaml examples for Best-of-3 and Best-of-5 that map exactly to your existing JSONs.

Would you like me to draft a ready-to-use YAML DSL version plus a small converter script (Python or JavaScript) to generate flow.json from it? If yes, tell me which flow(s) you want first (e.g., Best-of-3, Best-of-5), and your preferred output language for the converter.