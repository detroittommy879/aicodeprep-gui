CHANGELOG.md:
<code>
# Changelog

## [0.9.7] - 2025-28-4

### Added

New .aicodeprep file that saves the size of the window, and also which files you last processed so the next time you use AI Code Prep GUI in that folder, it will know what you did last time

New buttons for Smart Auto (to redo the smart file checking), Load from .aicodeprep (check the files you last had checked when last processed), Quit button

Expandable and collapsable folders, will auto expand if any files recursively inside are checked

Checkbox to disable creation of the .aicodeprep file if you for some reason don't want that feature

## [0.9.5] - 2025-24-1 (Mac GUI version seems to work)

### Added

- Mac OS app and workflow file that installs a right click menu to Finder. Switched to PyQt5 also.

## [0.5.0] - 2024-14-11 (GUI Release)

### Added

- Windows GUI Version
- Right-click context menu integration for Windows
- Enhanced file selection GUI with granular file inclusion/exclusion
- DPI awareness for better display on high-resolution screens

### New Features

- Interactive file selection before code preparation
- Checkbox-based file inclusion/exclusion
- Scalable UI with multiple theme options
- Windows Explorer context menu integration

### Changed

- Moved from free to premium model
- Lifetime license available for $7
- Enhanced configuration options
- Improved logging and error handling

## [0.2.2] - 2024-02-11

Minor tweaks and improvements

## [0.2.2] - 2024-07-11 (Nov 2nd 2024)

Minor tweaks

## [0.2.0] - 2024-02-11 (Nov 2nd 2024)

### Moved all hard coded options to the default_config.yaml file

### Added

- New `exclude_extensions` configuration option to exclude file types globally
- New `exclude_extensions` configuration option to exclude patterns like .min.js
- New `include_dirs` configuration option to explicitly include specific directories
- Enhanced priority system for file inclusion/exclusion rules
- Better support for user configuration overrides
- Updated and added some more exclusions that came up later when it would add unnecessary files

### Changed

- Improved file processing logic with clearer priority rules:
  1. Explicitly included files (highest priority)
  2. Explicitly excluded files
  3. Excluded extensions
  4. Code extensions (lowest priority)
- Enhanced directory processing logic:
  1. Explicitly included directories (highest priority)
  2. Explicitly excluded directories
  3. Normal directory processing

</code>

aicodeprep_gui_c\file_processor.py:
<code>
import os
import sys
import logging
import pyperclip
from typing import List

def process_files(selected_files: List[str], output_file: str) -> int:
    """Process selected files and write their contents to output_file"""
    try:
        # Get the directory passed from context menu (%V)
        target_dir = sys.argv[1] if len(sys.argv) > 1 else os.getcwd()
        logging.info(f"Target directory from context menu: {target_dir}")
        logging.info(f"Current working directory: {os.getcwd()}")

        # Use the target directory for output
        output_path = os.path.join(target_dir, output_file)
        logging.info(f"Writing output to: {output_path}")

        with open(output_path, 'w', encoding='utf-8') as outfile:
            for file_path in selected_files:
                relative_path = os.path.relpath(file_path, target_dir)
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as infile:
                        outfile.write(f"{relative_path}:\n<code>\n")
                        outfile.write(infile.read())
                        outfile.write("\n</code>\n\n")
                        logging.info(f"Processed: {relative_path}")
                except Exception as e:
                    logging.error(f"Error processing {file_path}: {str(e)}")
            
            # Add the note about skipped files
            outfile.write("\n<additional_information>Some files may have been skipped, to save tokens or because they didn't seem relevant. Ask about them if needed.</additional_information>\n")
        return len(selected_files)
    except Exception as e:
        logging.error(f"Error writing to output file: {str(e)}")
        return 0

def copy_to_clipboard(output_path: str) -> bool:
    """Copy the contents of output_path to clipboard"""
    try:
        with open(output_path, 'r', encoding='utf-8') as f:
            full_code = f.read()
        pyperclip.copy(full_code)
#        logging.info("Code copied to clipboard!")
        return True
    except Exception as e:
        logging.error(f"Error copying to clipboard: {str(e)}")
        return False

</code>

aicodeprep_gui_c\gui.py:
<code>
import os
import sys
import platform
import logging
from PyQt5 import QtWidgets, QtCore, QtGui, QtNetwork
from typing import List, Tuple
try:
    import tiktoken
except ImportError:
    tiktoken = None
from aicodeprep_gui_c.smart_logic import (
    EXCLUDE_DIRS, EXCLUDE_FILES, EXCLUDE_EXTENSIONS, EXCLUDE_PATTERNS, CODE_EXTENSIONS,
    matches_pattern, is_excluded_directory
)

def get_resource_path(relative_path):
    """Get absolute path to resource, works for dev and for PyInstaller"""
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, relative_path)

class FileSelectionGUI(QtWidgets.QWidget):
    def __init__(self, files):
        super().__init__()
        self.files = files  # Store files for preferences loading
        self.setWindowTitle("AI Code Prep - File Selection")
        self.app = QtWidgets.QApplication.instance()
        if self.app is None:
            self.app = QtWidgets.QApplication([])
        self.action = 'quit'  # Track user action: 'process' or 'quit'

        # .aicodeprep prefs
        self.prefs_filename = ".aicodeprep"
        self.remember_checkbox = None
        self.checked_files_from_prefs = set()
        self.prefs_loaded = False
        self.window_size_from_prefs = None
        self.load_prefs_if_exists()

        # DPI Awareness and Scaling
        if platform.system() == 'Windows':
            screen = self.app.primaryScreen()
            scale_factor = screen.logicalDotsPerInch() / 96.0
        else:
            scale_factor = self.app.primaryScreen().devicePixelRatio()

        # Font Configuration
        default_font_size = 9
        try:
            if platform.system() == 'Windows':
                system_font = 'Segoe UI'
            else:
                system_font = 'Arial'

            default_font_size = int(default_font_size * scale_factor)
            self.default_font = QtGui.QFont(system_font, default_font_size)
            self.tree_font = QtGui.QFont(system_font, default_font_size + 1)
            self.checkbox_font = QtGui.QFont(system_font, int(default_font_size * 1.2))
            self.setFont(self.default_font)
            logging.info(f"Using system font: {system_font}, Size: {default_font_size}")
        except Exception as e:
            logging.warning(f"Font/scaling error: {e}")
            self.default_font = QtGui.QFont('Arial', default_font_size)
            self.tree_font = QtGui.QFont('Arial', default_font_size + 1)
            self.checkbox_font = QtGui.QFont('Arial', int(default_font_size * 1.2))

        # Geometry
        if self.window_size_from_prefs:
            w, h = self.window_size_from_prefs
            self.setGeometry(100, 100, w, h)
        else:
            self.setGeometry(100, 100, int(600 * scale_factor), int(400 * scale_factor))
        
        # Layout
        main_layout = QtWidgets.QVBoxLayout(self)
        # Token count label
        self.token_label = QtWidgets.QLabel("Estimated tokens: 0")
        main_layout.addWidget(self.token_label)
        # Status label for messages
        self.text_label = QtWidgets.QLabel("")
        self.text_label.setWordWrap(True)
        main_layout.addWidget(self.text_label)
        self.tree_widget = QtWidgets.QTreeWidget()
        self.tree_widget.setHeaderLabels(["File/Folder"])
        self.tree_widget.setColumnCount(1)
        self.tree_widget.setColumnWidth(0, int(400 * scale_factor))  # Wider for file paths
        self.tree_widget.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        main_layout.addWidget(self.tree_widget)

        # --- Build folder/file tree ---
        self.path_to_item = {}  # Maps folder path to QTreeWidgetItem
        self.checked_paths = set()
        for file_path, relative_path, is_included in files:
            # If prefs loaded, override: only check files in prefs, uncheck all others
            if self.prefs_loaded:
                is_included = relative_path in self.checked_files_from_prefs
            if is_included:
                self.checked_paths.add(relative_path)
            parts = relative_path.split(os.sep)
            parent = self.tree_widget
            parent_path = ""
            for i, part in enumerate(parts):
                curr_path = os.sep.join(parts[:i+1])
                is_file = (i == len(parts) - 1)
                if curr_path not in self.path_to_item:
                    if is_file:
                        item = QtWidgets.QTreeWidgetItem()
                        item.setText(0, part)  # Show filename in column 0
                        item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
                        item.setCheckState(0, QtCore.Qt.Checked if is_included else QtCore.Qt.Unchecked)
                        item.setData(0, QtCore.Qt.UserRole, file_path)
                        parent.addTopLevelItem(item) if parent is self.tree_widget else parent.addChild(item)
                        self.path_to_item[curr_path] = item
                    else:
                        folder_item = QtWidgets.QTreeWidgetItem()
                        folder_item.setText(0, part)
                        # Make folders checkable
                        folder_item.setFlags(folder_item.flags() | QtCore.Qt.ItemIsUserCheckable)
                        folder_item.setCheckState(0, QtCore.Qt.Checked if is_included else QtCore.Qt.Unchecked)
                        parent.addTopLevelItem(folder_item) if parent is self.tree_widget else parent.addChild(folder_item)
                        self.path_to_item[curr_path] = folder_item
                    parent = self.path_to_item[curr_path]
                else:
                    parent = self.path_to_item[curr_path]

        self.tree_widget.itemChanged.connect(self.handle_item_changed)

        # --- Auto-expand folders to checked files ---
        def expand_to_checked(item):
            expanded = False
            for i in range(item.childCount()):
                child = item.child(i)
                if child.childCount() > 0:
                    if expand_to_checked(child):
                        self.tree_widget.expandItem(child)
                        expanded = True
                else:
                    if child.checkState(0) == QtCore.Qt.Checked:
                        expanded = True
            return expanded

        for i in range(self.tree_widget.topLevelItemCount()):
            top_item = self.tree_widget.topLevelItem(i)
            if expand_to_checked(top_item):
                self.tree_widget.expandItem(top_item)

        # --- Preferences Checkbox ---
        prefs_checkbox_layout = QtWidgets.QHBoxLayout()
        self.remember_checkbox = QtWidgets.QCheckBox("Remember checked files for this folder (.aicodeprep) and window size")
        self.remember_checkbox.setChecked(True)
        prefs_checkbox_layout.addWidget(self.remember_checkbox)
        prefs_checkbox_layout.addStretch()
        main_layout.addLayout(prefs_checkbox_layout)

        # --- Button Layout: two rows, right-aligned ---
        button_layout1 = QtWidgets.QHBoxLayout()
        button_layout2 = QtWidgets.QHBoxLayout()
        main_layout.addLayout(button_layout1)
        main_layout.addLayout(button_layout2)

        # Website link (left side, above buttons)
        website_label = QtWidgets.QLabel("<a href=\"https://wuu73.org/aicp\">wuu73.org/aicp</a>")
        website_label.setOpenExternalLinks(True)
        website_label.setTextFormat(QtCore.Qt.RichText)
        main_layout.insertWidget(main_layout.count() - 2, website_label)  # Place above buttons

        # First row of buttons (right-aligned)
        button_layout1.addStretch()
        process_button = QtWidgets.QPushButton("Process Selected")
        process_button.clicked.connect(self.process_selected)
        button_layout1.addWidget(process_button)

        select_all_button = QtWidgets.QPushButton("Select All")
        select_all_button.clicked.connect(self.select_all)
        button_layout1.addWidget(select_all_button)

        deselect_all_button = QtWidgets.QPushButton("Deselect All")
        deselect_all_button.clicked.connect(self.deselect_all)
        button_layout1.addWidget(deselect_all_button)

        # Second row of buttons (right-aligned)
        button_layout2.addStretch()
        load_prefs_button = QtWidgets.QPushButton("Load from .aicodeprep")
        load_prefs_button.clicked.connect(self.load_from_prefs_button_clicked)
        button_layout2.addWidget(load_prefs_button)

        quit_button = QtWidgets.QPushButton("Quit")
        quit_button.clicked.connect(self.quit_without_processing)
        button_layout2.addWidget(quit_button)

        self.selected_files = []
        self.file_token_counts = {}
        self.update_token_counter()

    def handle_item_changed(self, item, column):
        if column == 0:
            file_path = item.data(0, QtCore.Qt.UserRole)
            # If it's a folder (no file_path), do smart recursive check/uncheck
            if file_path is None:
                def should_skip_folder(folder_item):
                    # Compose full path from tree
                    path_parts = []
                    curr = folder_item
                    while curr is not None and curr.parent() is not None:
                        path_parts.insert(0, curr.text(0))
                        curr = curr.parent()
                    if curr is not None and curr.parent() is None:
                        path_parts.insert(0, curr.text(0))
                    folder_path = os.path.join(*path_parts)
                    return (folder_item.text(0) in EXCLUDE_DIRS or
                            is_excluded_directory(folder_path))
                def smart_check(item, check_state):
                    # Skip blocked folders
                    if should_skip_folder(item):
                        item.setCheckState(0, QtCore.Qt.Unchecked)
                        return
                    for i in range(item.childCount()):
                        child = item.child(i)
                        child_file_path = child.data(0, QtCore.Qt.UserRole)
                        if child_file_path:
                            # It's a file
                            filename = os.path.basename(child_file_path)
                            ext = os.path.splitext(filename)[1].lower()
                            if (filename in EXCLUDE_FILES or
                                ext in EXCLUDE_EXTENSIONS or
                                any(matches_pattern(filename, pat) for pat in EXCLUDE_PATTERNS)):
                                child.setCheckState(0, QtCore.Qt.Unchecked)
                                continue
                            child.setCheckState(0, check_state)
                        else:
                            # It's a folder
                            smart_check(child, check_state)
                    item.setCheckState(0, check_state)
                smart_check(item, item.checkState(0))
            else:
                # File item: update selected_files as before
                if item.checkState(0) == QtCore.Qt.Checked:
                    if file_path and file_path not in self.selected_files:
                        self.selected_files.append(file_path)
                else:
                    if file_path and file_path in self.selected_files:
                        self.selected_files.remove(file_path)
            self.update_token_counter()

    def select_all(self):
        # Recursively select all file items
        def check_all_items(item):
            if item.flags() & QtCore.Qt.ItemIsUserCheckable:
                item.setCheckState(0, QtCore.Qt.Checked)
            for i in range(item.childCount()):
                check_all_items(item.child(i))

        for i in range(self.tree_widget.topLevelItemCount()):
            check_all_items(self.tree_widget.topLevelItem(i))
        self.update_token_counter()

    def deselect_all(self):
        # Recursively deselect all file items
        def uncheck_all_items(item):
            if item.flags() & QtCore.Qt.ItemIsUserCheckable:
                item.setCheckState(0, QtCore.Qt.Unchecked)
            for i in range(item.childCount()):
                uncheck_all_items(item.child(i))

        for i in range(self.tree_widget.topLevelItemCount()):
            uncheck_all_items(self.tree_widget.topLevelItem(i))
        self.update_token_counter()

    def get_selected_files(self):
        self.selected_files = []

        # Recursively collect all checked files
        def collect_checked_files(item):
            if item.flags() & QtCore.Qt.ItemIsUserCheckable and item.checkState(0) == QtCore.Qt.Checked:
                file_path = item.data(0, QtCore.Qt.UserRole)
                if file_path:
                    self.selected_files.append(file_path)

            for i in range(item.childCount()):
                collect_checked_files(item.child(i))

        for i in range(self.tree_widget.topLevelItemCount()):
            collect_checked_files(self.tree_widget.topLevelItem(i))

        return self.selected_files

    def process_selected(self):
        self.action = 'process'  # Set action first
        logging.info(f"Process Selected clicked - action set to: {self.action}")
        self.get_selected_files()
        # Save prefs if checkbox is checked
        if self.remember_checkbox and self.remember_checkbox.isChecked():
            self.save_prefs()
        logging.info(f"Process Selected closing - action is: {self.action}")
        self.close()

    def fetch_text_content(self):
        url = "https://wuu73.org/aicp/display.txt"  # URL to fetch text from
        request = QtNetwork.QNetworkRequest(QtCore.QUrl(url))
        self.network_manager.get(request)

    def handle_network_reply(self, reply):
        if reply.error() == QtNetwork.QNetworkReply.NoError:
            text = reply.readAll().data().decode()
            # Check if the text is not just whitespace
            if text.strip():
                # Convert plain text links to HTML links (basic link handling)
                text_with_links = self.convert_text_links_to_html(text)
                self.text_label.setText(text_with_links)
        # If there's an error or the content is empty, do nothing (silent handling)

    def convert_text_links_to_html(self, text):
        """Converts URLs in plain text to clickable HTML links (very basic)."""
        import re
        url_pattern = re.compile(r'(https?://\S+)')
        return url_pattern.sub(r'<a href="\1">\1</a>', text)

    def load_from_prefs_button_clicked(self):
        import os
        prefs_path = _prefs_path()
        if os.path.exists(prefs_path):
            self.load_prefs_if_exists()
            # Uncheck all first, then check those in prefs
            self.deselect_all()
            for file_path, relative_path, is_included in self.files:
                if relative_path in self.checked_files_from_prefs:
                    parts = relative_path.split(os.sep)
                    curr_path = os.sep.join(parts)
                    item = self.path_to_item.get(curr_path)
                    if item:
                        item.setCheckState(0, QtCore.Qt.Checked)
            # Optionally show a message
            self.text_label.setText("Loaded selection from .aicodeprep")
            self.update_token_counter()
        else:
            self.text_label.setText(".aicodeprep not found")

    def quit_without_processing(self):
        # Immediately close the window and exit the app without processing
        logging.info("Quit button clicked - setting action to quit")
        self.action = 'quit'
        self.close()

    def update_token_counter(self):
        selected_files = self.get_selected_files()
        total_tokens = 0
        for file_path in selected_files:
            if file_path not in self.file_token_counts:
                try:
                    with open(file_path, "r", encoding="utf-8") as f:
                        text = f.read()
                    if tiktoken:
                        enc = tiktoken.get_encoding("cl100k_base")
                        token_count = len(enc.encode(text))
                    else:
                        token_count = len(text) // 4
                    self.file_token_counts[file_path] = token_count
                except Exception as e:
                    self.file_token_counts[file_path] = 0
            total_tokens += self.file_token_counts[file_path]
        self.token_label.setText(f"Estimated tokens: {total_tokens:,}")

def show_file_selection_gui(files):
    app = QtWidgets.QApplication.instance()
    if app is None:
        app = QtWidgets.QApplication([])

    gui = FileSelectionGUI(files)
    gui.show()
    app.exec_()
    logging.info(f"GUI event loop finished - final action value: {gui.action}")
    return gui.action, gui.selected_files

# --- Preferences Save/Load Methods ---

def _prefs_path():
    # Always save/load in current working directory
    return os.path.join(os.getcwd(), ".aicodeprep")

def _write_prefs_file(checked_relpaths, window_size=None):
    try:
        with open(_prefs_path(), "w", encoding="utf-8") as f:
            if window_size:
                f.write("[window]\n")
                f.write(f"width={window_size[0]}\n")
                f.write(f"height={window_size[1]}\n\n")
            for relpath in checked_relpaths:
                f.write(relpath + "\n")
    except Exception as e:
        logging.warning(f"Could not write .aicodeprep: {e}")


def _read_prefs_file():
    checked = set()
    window_size = None
    try:
        with open(_prefs_path(), "r", encoding="utf-8") as f:
            lines = f.readlines()
        i = 0
        if lines and lines[0].strip() == '[window]':
            width = height = None
            for j in range(1, len(lines)):
                line = lines[j].strip()
                if line.startswith('width='):
                    width = int(line.split('=', 1)[1])
                elif line.startswith('height='):
                    height = int(line.split('=', 1)[1])
                elif line == '':
                    i = j + 1
                    break
            if width and height:
                window_size = (width, height)
        for line in lines[i:]:
            line = line.strip()
            if line and not line.startswith('#'):
                checked.add(line)
    except Exception:
        pass
    return checked, window_size

# Add closeEvent to set action to 'quit' ONLY if window is closed via 'X'
def closeEvent(self, event):
    logging.info(f"closeEvent triggered - action before: {self.action}")
    # Only set to 'quit' if it wasn't already set to 'process'
    if self.action != 'process':
        self.action = 'quit'
    logging.info(f"closeEvent triggered - action after: {self.action}")
    super(FileSelectionGUI, self).closeEvent(event)

# Patch methods into FileSelectionGUI

def load_prefs_if_exists(self):
    prefs_path = _prefs_path()
    if os.path.exists(prefs_path):
        checked, window_size = _read_prefs_file()
        self.checked_files_from_prefs = checked
        self.window_size_from_prefs = window_size
        self.prefs_loaded = True
    else:
        self.checked_files_from_prefs = set()
        self.window_size_from_prefs = None
        self.prefs_loaded = False

def save_prefs(self):
    checked_relpaths = []
    # Recursively collect all checked relative paths
    def collect_checked(item, relpath_prefix=""):
        text = item.text(0)
        curr_path = os.path.join(relpath_prefix, text) if relpath_prefix else text
        if item.flags() & QtCore.Qt.ItemIsUserCheckable and item.checkState(0) == QtCore.Qt.Checked:
            checked_relpaths.append(curr_path)
        for i in range(item.childCount()):
            collect_checked(item.child(i), curr_path)
    for i in range(self.tree_widget.topLevelItemCount()):
        collect_checked(self.tree_widget.topLevelItem(i))
    # Save window size
    size = self.size()
    window_size = (size.width(), size.height())
    _write_prefs_file(checked_relpaths, window_size=window_size)

FileSelectionGUI.load_prefs_if_exists = load_prefs_if_exists
FileSelectionGUI.save_prefs = save_prefs
FileSelectionGUI.closeEvent = closeEvent

</code>

aicodeprep_gui_c\data\default_config.md:
<code>
# Default Configuration

```json
{
  "code_extensions": [
    ".py",
    ".js",
    ".jsx",
    ".ts",
    ".tsx",
    ".java",
    ".cpp",
    ".c",
    ".h",
    ".cs",
    ".php",
    ".rb",
    ".go",
    ".rs",
    ".swift",
    ".kt",
    ".scala",
    ".html",
    ".css",
    ".scss",
    ".sass",
    ".less",
    ".sql",
    ".sh",
    ".yaml",
    ".yml",
    ".json",
    ".xml",
    ".vue",
    ".r",
    ".m",
    ".f90",
    ".f95",
    ".f03",
    ".f08",
    ".gradle",
    ".groovy",
    ".ps1",
    ".psm1",
    ".ipynb",
    ".md",
    ".txt",
    ".lock",
    ".toml",
    ".ini",
    ".conf",
    ".cfg",
    ".properties"
  ],
  "exclude_extensions": [
    ".txt",
    ".log",
    ".temp",
    ".exe",
    ".dll",
    ".so",
    ".dylib",
    ".jar",
    ".war",
    ".ear",
    ".o",
    ".class"
  ],
  "include_files": ["README.md", "CONTRIBUTING.md", "important.txt"],
  "include_dirs": ["important_docs"],
  "exclude_dirs": [
    ".git",
    "node_modules",
    "venv",
    "__pycache__",
    "build",
    "dist",
    ".idea",
    "Lib",
    "site-packages",
    ".venv",
    "venv",
    ".vscode",
    ".github",
    "docs",
    "tests",
    "spec",
    "fixtures",
    "migrations",
    "logs",
    "tmp",
    "cache",
    "assets",
    "public",
    "static",
    "uploads",
    "vendor",
    "bin",
    "obj",
    "out",
    "target",
    "coverage",
    "reports",
    ".pytest_cache",
    ".mypy_cache",
    ".ipynb_checkpoints",
    ".nyc_output",
    "test-results",
    "__tests__",
    "__snapshots__",
    "__mocks__",
    "debug",
    ".jest",
    ".next",
    ".nuxt",
    ".svelte-kit",
    ".expo",
    "dist-ssr",
    ".parcel-cache",
    ".serverless",
    ".vercel",
    ".angular",
    ".quasar",
    ".redwood",
    ".fusebox",
    ".docusaurus",
    ".terraform",
    "snapshots"
  ],
  "exclude_files": [
    "package-lock.json",
    "yarn.lock",
    "requirements.txt",
    "Gemfile.lock",
    "composer.lock",
    ".DS_Store",
    "Thumbs.db",
    "pnpm-lock.yaml",
    "bun.lock",
    "bun.lockb",
    "cargo.lock",
    "poetry.lock",
    "Pipfile.lock",
    ".npmrc",
    ".env",
    ".env.*",
    ".env.local",
    ".env.prod",
    ".env.staging",
    ".env.dev",
    ".flaskenv",
    ".dockerenv",
    "env.json",
    "credentials.yaml",
    "secret*.json",
    "*.key",
    "*.pem",
    "*.crt",
    "*.pub",
    "id_rsa",
    "id_dsa",
    "Dockerfile.*.cache",
    "coverage.xml",
    "*.lcov"
  ],
  "exclude_patterns": [
    "min.js",
    "min.css",
    "bundle.js",
    "chunk.js",
    "test.js",
    "spec.js",
    "generated.ts",
    "*.swp",
    "*.swo",
    "*.un~",
    "~$*",
    "*.min.*",
    "*-lock.*",
    "*.snap",
    ".test.",
    ".spec.",
    ".bench.",
    ".cache",
    ".temp",
    "*.lock",
    "*.class",
    "*.exe",
    "*.dll",
    "*.so",
    "*.dylib",
    "*.jar",
    "*.war",
    "*.ear",
    "*.o"
  ],
  "max_file_size": 1000000
}
```

</code>

aicodeprep_gui_c\data\default_config_old.yaml:
<code>
code_extensions:
  - .py
  - .js
  - .jsx
  - .ts
  - .tsx
  - .java
  - .cpp
  - .c
  - .h
  - .cs
  - .php
  - .rb
  - .go
  - .rs
  - .swift
  - .kt
  - .scala
  - .html
  - .css
  - .scss
  - .sass
  - .less
  - .sql
  - .sh
  - .yaml
  - .yml
  - .json
  - .xml
  - .vue
  - .r
  - .m
  - .f90
  - .f95
  - .f03
  - .f08
  - .gradle
  - .groovy
  - .ps1
  - .psm1
  - .ipynb
  - .md
  - .txt
  - .lock
  - .toml
  - .ini
  - .conf
  - .cfg
  - .properties

exclude_extensions:
  - .txt
  - .log
  - .temp
  - .exe
  - .dll
  - .so
  - .dylib
  - .jar
  - .war
  - .ear
  - .o
  - .class

include_files:
  - README.md
  - CONTRIBUTING.md
  - important.txt   # Even if .txt is excluded, this specific file will be included

include_dirs:
  - important_docs  # Specifically include this directory even if parent is excluded

exclude_dirs:
  - .git
  - node_modules
  - venv
  - __pycache__
  - build
  - dist
  - .idea
  - Lib
  - site-packages  
  - .venv
  - venv
  - .vscode
  - .github
  - docs
  - tests
  - spec
  - fixtures
  - migrations
  - logs
  - tmp
  - cache
  - assets
  - public
  - static
  - uploads
  - vendor
  - bin
  - obj
  - out
  - target
  - coverage
  - reports
  - .pytest_cache
  - .mypy_cache
  - .ipynb_checkpoints
  - .nyc_output
  - test-results
  - __tests__
  - __snapshots__
  - __mocks__
  - debug
  - .jest
  - .next
  - .nuxt
  - .svelte-kit
  - .expo
  - dist-ssr
  - .parcel-cache
  - .serverless
  - .vercel
  - .angular
  - .quasar
  - .redwood
  - .fusebox
  - .docusaurus
  - .terraform
  - snapshots

exclude_files:
  - package-lock.json
  - yarn.lock
  - requirements.txt
  - Gemfile.lock
  - composer.lock
  - .DS_Store
  - Thumbs.db
  - pnpm-lock.yaml
  - bun.lock
  - bun.lockb
  - cargo.lock
  - poetry.lock
  - Pipfile.lock
  - .npmrc
  - .env
  - .env.*
  - .env.local
  - .env.prod
  - .env.staging
  - .env.dev
  - .flaskenv
  - .dockerenv
  - env.json
  - credentials.yaml
  - secret*.json
  - *.key
  - *.pem
  - *.crt
  - *.pub
  - id_rsa
  - id_dsa
  - Dockerfile.*.cache
  - coverage.xml
  - *.lcov

exclude_patterns:
  - min.js
  - min.css
  - bundle.js
  - chunk.js
  - test.js
  - spec.js
  - generated.ts
  - '*.swp'
  - '*.swo'
  - '*.un~'
  - '~$*'
  - '*.min.*'
  - '*-lock.*'
  - '*.snap'
  - .test.
  - .spec.
  - .bench.
  - .cache
  - .temp
  - '*.lock'
  - '*.class'
  - '*.exe'
  - '*.dll'
  - '*.so'
  - '*.dylib'
  - '*.jar'
  - '*.war'
  - '*.ear'
  - '*.o'

max_file_size: 1000000  # 1MB default

</code>


<additional_information>Some files may have been skipped, to save tokens or because they didn't seem relevant. Ask about them if needed.</additional_information>
