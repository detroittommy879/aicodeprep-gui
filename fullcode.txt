### pyproject.toml
[build-system]
requires = ["setuptools>=61.0.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "aicodeprep_gui_c"
version = "0.9.7"
description = "Prepare code for AI chatbot assistance"
readme = "README.md"
authors = [{ name = "Tom Brothers", email = "wuu73@yahoo.com" }]
license = { file = "LICENSE" }
classifiers = [
    "License :: Proprietary",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3",
]
keywords = ["ai", "code", "preparation", "chatbot"]
dependencies = [
    "PySide6>=6.7",
    "tiktoken"
]
requires-python = ">=3.6"

[project.scripts]
aicodeprep_gui_c = "aicodeprep_gui_c.main:main" # Use an underscore here

[project.urls]
Homepage = "https://github.com/detroittommy879/aicodeprep"

[tool.setuptools.packages.find]
where = ["."]

[tool.setuptools.package-data]
aicodeprep_gui_c = ["data/default_config.md"]

### END pyproject.toml

### README.md
# AI Code Prep GUI

_Streamline code sharing with AI chatbots (macOS & Windows & Linux)_

[![GitHub stars](https://img.shields.io/github/stars/detroittommy879/aicodeprep.svg?style=social&label=Stars)](https://github.com/detroittommy879/aicodeprep/stargazers)

**Latest Version: 0.9.8 (May 27, 2025)**

---

## What is AI Code Prep GUI?

AI Code Prep GUI is a cross-platform desktop application that helps developers quickly gather and share their project code with AI chatbots. Instead of manually copying and pasting multiple files, this tool automatically collects relevant code files into a single text file, copies it to your clipboard, and formats it with AI-friendly `<code>` tags.

It supports **Windows**, **macOS (M1+)**, and **Linux** with context menu/right-click integration.

---

## New Features in v0.9.8

- **Dark Mode Support:**
  - Automatic theme detection based on system preferences
  - Manual dark/light mode toggle in the top-right corner
  - Carefully designed dark theme palette for optimal readability
- **PySide6 Migration:**
  - Upgraded to Qt6 via PySide6 for improved performance
  - Simplified dependencies - only requires PySide6 and tiktoken
  - Better modern Qt features and future-proofing

## Features from v0.9.7

- **Persistent Preferences:** Automatically saves window size and the last selected files in a `.aicodeprep` file per project folder. When you re-open the tool in the same folder, your previous selections and window layout are restored.
  - New checkbox lets you disable creation of the `.aicodeprep` file if you don't want this feature.
- **Folder Tree UI Improvements:**
  - Expandable and collapsable folders for easier navigation
  - Auto-expands folders containing checked files
- **Token Counter:** As you check or uncheck files, the token count is now displayed.
- **Enhanced Smart Auto-Selection:** Smarter file checking logic that respects exclusions and better filters irrelevant files
- **Additional UI Buttons:**
  - **Load from .aicodeprep** button to restore your last saved selection
  - **Quit** button for quick exit without processing
- **Better Visual Styling:** Improved fonts and DPI scaling for crisp display on high-resolution screens

---

## Screenshots & Usage

See screenshots and a quick usage guide here:  
[https://wuu73.org/aicp](https://wuu73.org/aicp)

### New version 0.9.8 available for Windows, macOS, and Linux

---

## Future idea's

MCP Server to automatically attach to a browser, and automatically paste the output context into various AI/LLM chats like Gemini on AI Studio, ChatGPT, Openrouter, Poe, Deepseek, X, etc so even less copying and pasting.

## Installation

### macOS

1. Download and unzip the macOS package.
2. Drag `AICodePrepGUI.app` to your Applications folder.
3. Double-click `AICodePrepGUI.workflow` and follow instructions to add the right-click Quick Actions menu to Finder.
4. Restart Finder if needed to activate the menu.
5. To use: Right-click on a project folder → Quick Actions → AICodePrepGUI.
6. Select/deselect files and folders as needed, then click **Process Selected**.
7. The tool will create a `fullcode.txt` and copy all selected code to your clipboard, ready to paste into your AI chatbot.

_Tested on macOS Ventura 13.4 and newer (M1+)._

### Windows

1. Run `windows-easy-installer-dist.exe` or the newer v0.9.8 installer file.
2. Follow the installation wizard (default directory: `Program Files\AICodePrep-GUI`).
3. To use: Right-click in any folder's blank space in Windows File Explorer → `AI Code Prep GUI`.
4. Restart Windows if the context menu does not appear immediately.
5. Select/deselect files and folders, then click **Process Selected**.
6. Your selected code will be saved to `fullcode.txt` and copied to the clipboard.

### Linux

1. Download the Linux package from the releases page.
2. Follow the installation instructions in the included README.
3. Use via command line or file manager context menu integration.

---

## Features Summary

- **Cross-platform GUI** for easy visual file selection
- **Smart Preselection** of relevant code files based on configured extensions and exclusions
- **Dark/Light Theme Support** with system preference detection and manual toggle
- **Folder Tree View** with collapsible/expandable folders and auto-expansion for selected files
- **Preferences Saving** via `.aicodeprep` per folder to remember your last selected files and window size (with option to disable)
- **Token Counter** displays token count as you check/uncheck files
- **Context Menu Integration** for quick access
- **Clipboard & File Output** for seamless pasting into AI chatbots
- **LLM-Optimized Formatting** with `<code>` tags around file contents
- **Configurable via YAML** to suit various project needs
- **Improved DPI & Font Scaling** for crisp UI on all displays

---

## Usage

1. Open the tool from your project folder's context menu (right-click).
2. Review the preselected files and folders. Expand or collapse folders as needed.
3. Use the **Smart Auto** button to auto-select files based on smart logic.
4. Use **Load from .aicodeprep** to restore your previous session's selection.
5. Check or uncheck files/folders manually.
6. Toggle dark/light mode using the checkbox in the top-right corner if desired.
7. If you want to save your preferences for the folder, ensure the **Remember checked files for this folder (.aicodeprep)** checkbox is ticked.
8. Click **Process Selected** to generate the output file and copy it to your clipboard.

---

## Configuration

You can customize file extensions, directories, and exclusion patterns via a `aicodeprep_config.yaml` file in your project folder. Refer to the [default_config.yaml](aicodeprep_gui_c/data/default_config.yaml) for examples.

---

## Contributing

Contributions and pull requests are welcome! Please submit bug reports and feature requests via GitHub Issues.

---

## Support & Donations

If you find this tool useful, consider supporting future development:

| Method   | Address / Link                                                                                    |
| -------- | ------------------------------------------------------------------------------------------------- |
| Bitcoin  | `bc1qkuwhujaxhzk7e3g4f3vekpzjad2rwlh9usagy6`                                                      |
| Litecoin | `ltc1q3z327a3ea22mlhtawmdjxmwn69n65a32fek2s4`                                                     |
| Monero   | `46FzbFckBy9bbExzwAifMPBheYFb37k8ghGWSHqc6wE1BiEz6rQc2f665JmqUdtv1baRmuUEcDoJ2dpqY6Msa3uCKArszQZ` |
| CashApp  | `$lightweb73`                                                                                     |
| Website  | [https://wuu73.org/hello.html](https://wuu73.org/hello.html)                                      |

---

### END README.md

### requirements.txt
altgraph==0.17.4
certifi==2025.4.26
charset-normalizer==3.4.1
idna==3.10
packaging==25.0
pefile==2023.2.7
pyinstaller==6.13.0
pyinstaller-hooks-contrib==2025.3
pyperclip==1.8.2
PySide6==6.8.1
PySide6_Addons==6.8.1
PySide6_Essentials==6.8.1
pywin32-ctypes==0.2.3
regex==2024.11.6
requests==2.32.3
shiboken6==6.8.1
tiktoken==0.9.0
urllib3==2.4.0

### END requirements.txt

### aicodeprep_gui_c\apptheme.py
from PySide6 import QtCore, QtGui, QtWidgets
import platform
import os
import sys
import ctypes
import json

def system_pref_is_dark() -> bool:
    """Detect if system is using dark mode."""
    system = platform.system()
    
    if system == "Darwin":  # macOS
        try:
            import subprocess
            cmd = "defaults read -g AppleInterfaceStyle"
            result = subprocess.run(cmd, shell=True, text=True, capture_output=True)
            return result.stdout.strip() == "Dark"
        except:
            pass
    
    elif system == "Windows":  # Windows 10+
        try:
            import winreg
            registry = winreg.ConnectRegistry(None, winreg.HKEY_CURRENT_USER)
            reg_keypath = r"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize"
            key = winreg.OpenKey(registry, reg_keypath)
            value, _ = winreg.QueryValueEx(key, "AppsUseLightTheme")
            return value == 0
        except:
            pass
    
    # Fallback: use palette heuristic
    return QtWidgets.QApplication.palette().color(QtGui.QPalette.Window).lightness() < 128

def apply_dark_palette(app: QtWidgets.QApplication):
    """Apply dark color palette to application."""
    dark = QtGui.QPalette()
    dark.setColor(QtGui.QPalette.Window, QtGui.QColor(53, 53, 53))
    dark.setColor(QtGui.QPalette.WindowText, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Base, QtGui.QColor(42, 42, 42))
    dark.setColor(QtGui.QPalette.AlternateBase, QtGui.QColor(66, 66, 66))
    dark.setColor(QtGui.QPalette.ToolTipBase, QtGui.QColor(53, 53, 53))
    dark.setColor(QtGui.QPalette.ToolTipText, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Text, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Button, QtGui.QColor(53, 53, 53))
    dark.setColor(QtGui.QPalette.ButtonText, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Link, QtGui.QColor(42, 130, 218))
    dark.setColor(QtGui.QPalette.Highlight, QtGui.QColor(42, 130, 218))
    dark.setColor(QtGui.QPalette.HighlightedText, QtGui.QColor(255, 255, 255))
    
    # Disabled colors
    dark.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.Text, QtGui.QColor(128, 128, 128))
    dark.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, QtGui.QColor(128, 128, 128))
    dark.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, QtGui.QColor(128, 128, 128))
    
    app.setPalette(dark)

def apply_light_palette(app: QtWidgets.QApplication):
    """Apply light color palette to application."""
    light = QtGui.QPalette()
    light.setColor(QtGui.QPalette.Window, QtGui.QColor(240, 240, 240))
    light.setColor(QtGui.QPalette.WindowText, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Base, QtGui.QColor(255, 255, 255))
    light.setColor(QtGui.QPalette.AlternateBase, QtGui.QColor(233, 233, 233))
    light.setColor(QtGui.QPalette.ToolTipBase, QtGui.QColor(255, 255, 255))
    light.setColor(QtGui.QPalette.ToolTipText, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Text, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Button, QtGui.QColor(240, 240, 240))
    light.setColor(QtGui.QPalette.ButtonText, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Link, QtGui.QColor(0, 0, 255))
    light.setColor(QtGui.QPalette.Highlight, QtGui.QColor(42, 130, 218))
    light.setColor(QtGui.QPalette.HighlightedText, QtGui.QColor(255, 255, 255))
    
    # Disabled colors
    light.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.Text, QtGui.QColor(120, 120, 120))
    light.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, QtGui.QColor(120, 120, 120))
    light.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, QtGui.QColor(120, 120, 120))
    
    app.setPalette(light)

def create_checkmark_pixmap(size=16, color="#0078D4"):
    """Create a checkmark pixmap programmatically."""
    pixmap = QtGui.QPixmap(size, size)
    pixmap.fill(QtCore.Qt.transparent)
    
    painter = QtGui.QPainter(pixmap)
    painter.setRenderHint(QtGui.QPainter.Antialiasing)
    
    pen = QtGui.QPen(QtGui.QColor(color))
    pen.setWidth(2)
    pen.setCapStyle(QtCore.Qt.RoundCap)
    pen.setJoinStyle(QtCore.Qt.RoundJoin)
    painter.setPen(pen)
    
    # Draw checkmark
    painter.drawLine(4, 8, 7, 11)
    painter.drawLine(7, 11, 12, 4)
    
    painter.end()
    return pixmap

def _checkbox_style_with_images(dark: bool) -> str:
    """Alternative approach using programmatically created images."""
    
    if dark:
        bg_unchecked = '#2B2B2B'
        bg_checked = '#2B2B2B'
        border_unchecked = '#555555'
        border_checked = '#0078D4'
        checkmark_color = '#0078D4'
    else:
        bg_unchecked = '#FFFFFF'
        bg_checked = '#FFFFFF'
        border_unchecked = '#AAAAAA'
        border_checked = '#0078D4'
        checkmark_color = '#0078D4'

    # Create checkmark image and save it temporarily
    import tempfile
    checkmark_pixmap = create_checkmark_pixmap(16, checkmark_color)
    temp_dir = tempfile.gettempdir()
    checkmark_path = os.path.join(temp_dir, f"checkmark_{'dark' if dark else 'light'}.png")
    checkmark_pixmap.save(checkmark_path)

    return f"""
    QTreeView::indicator, QTreeWidget::indicator {{
        width: 16px;
        height: 16px;
        border-radius: 3px;
    }}

    QTreeView::indicator:unchecked,
    QTreeWidget::indicator:unchecked {{
        background-color: {bg_unchecked};
        border: 2px solid {border_unchecked};
    }}

    QTreeView::indicator:checked,
    QTreeWidget::indicator:checked {{
        background-color: {bg_checked};
        border: 2px solid {border_checked};
        image: url({checkmark_path.replace(os.sep, '/')});
    }}

    QTreeView::indicator:unchecked:hover,
    QTreeWidget::indicator:unchecked:hover {{
        border-color: {border_checked};
    }}
    """



def _checkbox_style(dark: bool) -> str:
    """Return a style-sheet that shows a visible tick using Unicode checkmarks."""
    
    if dark:
        bg_unchecked = '#2B2B2B'
        bg_checked = '#2B2B2B'
        border_unchecked = '#555555'
        border_checked = '#0078D4'
        checkmark_color = '#0078D4'
        disabled_bg = '#1F1F1F'
        disabled_border = '#3A3A3A'
    else:
        bg_unchecked = '#FFFFFF'
        bg_checked = '#FFFFFF'
        border_unchecked = '#AAAAAA'
        border_checked = '#0078D4'
        checkmark_color = '#0078D4'
        disabled_bg = '#F5F5F5'
        disabled_border = '#CCCCCC'

    return f"""
    QTreeView::indicator, QTreeWidget::indicator {{
        width: 16px;
        height: 16px;
        border-radius: 3px;
    }}

    /* Unchecked state */
    QTreeView::indicator:unchecked,
    QTreeWidget::indicator:unchecked {{
        background-color: {bg_unchecked};
        border: 2px solid {border_unchecked};
    }}

    /* Checked state with Unicode checkmark */
    QTreeView::indicator:checked,
    QTreeWidget::indicator:checked {{
        background-color: {bg_checked};
        border: 2px solid {border_checked};
        color: {checkmark_color};
        font-weight: bold;
        font-size: 12px;
        text-align: center;
    }}

    QTreeView::indicator:checked::after,
    QTreeWidget::indicator:checked::after {{
        content: "✓";
        color: {checkmark_color};
        font-weight: bold;
        font-size: 12px;
        position: absolute;
        top: -1px;
        left: 1px;
    }}

    /* Disabled states */
    QTreeView::indicator:disabled,
    QTreeWidget::indicator:disabled {{
        background-color: {disabled_bg};
        border: 2px solid {disabled_border};
    }}

    /* Hover effects */
    QTreeView::indicator:unchecked:hover,
    QTreeWidget::indicator:unchecked:hover {{
        border-color: {border_checked};
        background-color: {bg_unchecked};
    }}

    QTreeView::indicator:checked:hover,
    QTreeWidget::indicator:checked:hover {{
        background-color: {bg_checked};
        border-color: {border_checked};
    }}
    """

def get_checkbox_style_dark()  -> str: 
    return _checkbox_style_with_images(True)

def get_checkbox_style_light() -> str: 
    return _checkbox_style_with_images(False)
### END aicodeprep_gui_c\apptheme.py

### aicodeprep_gui_c\file_processor.py
import os
import sys
import logging
from typing import List, Literal

OutputFmt = Literal['xml', 'markdown']

def _write_one_file_xml(outfile, rel_path, abs_path):
    outfile.write(f"{rel_path}:\n<code>\n")
    with open(abs_path, 'r', encoding='utf-8', errors='ignore') as infile:
        outfile.write(infile.read())
    outfile.write("\n</code>\n\n")

def _write_one_file_md(outfile, rel_path, abs_path):
    outfile.write(f"### {rel_path}\n")
    with open(abs_path, 'r', encoding='utf-8', errors='ignore') as infile:
        outfile.write(infile.read())
    outfile.write(f"\n### END {rel_path}\n\n")

def process_files(selected_files: List[str], output_file: str, fmt: OutputFmt = 'xml') -> int:
    """
    Write the concatenation of `selected_files` into `output_file`.
    `fmt` is either 'xml' (default, uses <code> … </code>) or
    'markdown' (### path … ### END path).
    """
    try:
        output_path = os.path.join(os.getcwd(), output_file)
        logging.info(f"Writing output to: {output_path}")

        writer = _write_one_file_xml if fmt == 'xml' else _write_one_file_md

        with open(output_path, 'w', encoding='utf-8') as outfile:
            for file_path in selected_files:
                try:
                    try:
                        rel_path = os.path.relpath(file_path, os.getcwd())
                    except ValueError:
                        rel_path = file_path
                    writer(outfile, rel_path, file_path)
                    logging.info(f"Processed: {rel_path}")
                except Exception as exc:
                    logging.error(f"Error processing {file_path}: {exc}")

            # generic tail line – no XML tags any more
            outfile.write(".. some other files were skipped ..\n")

        return len(selected_files)
    except Exception as exc:
        logging.error(f"Error writing output file: {exc}")
        return 0

### END aicodeprep_gui_c\file_processor.py

### aicodeprep_gui_c\gui.py
import os
import sys
import platform
import logging
from PySide6 import QtWidgets, QtCore, QtGui, QtNetwork
from aicodeprep_gui_c.apptheme import system_pref_is_dark, apply_dark_palette, apply_light_palette
from typing import List, Tuple
# --- Removed tiktoken dependency for token counting ---
tiktoken = None
from aicodeprep_gui_c import smart_logic
from aicodeprep_gui_c.smart_logic import (
    EXCLUDE_DIRS, EXCLUDE_FILES, EXCLUDE_EXTENSIONS, EXCLUDE_PATTERNS, CODE_EXTENSIONS,
    matches_pattern, is_excluded_directory
)
from aicodeprep_gui_c.file_processor import process_files

def get_resource_path(relative_path):
    """Get absolute path to resource, works for dev and for PyInstaller"""
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, relative_path)

def get_checkbox_style():
    return """
    QCheckBox {
        spacing: 8px;
        color: #E0E0E0;
        font-size: 11px;
    }
    
    QCheckBox::indicator {
        width: 16px;
        height: 16px;
        border: 2px solid #555555;
        border-radius: 3px;
        background-color: #2B2B2B;
    }
    
    QCheckBox::indicator:hover {
        border-color: #777777;
        background-color: #353535;
    }
    
    QCheckBox::indicator:checked {
        border-color: #0078D4;
        background-color: #2B2B2B;
    
    }
    
    QCheckBox::indicator:checked {
        border-color: #0078D4;
        background-color: #2B2B2B;
        font-family: "Segoe UI Symbol";
        font-size: 14px;
        color: #0078D4;
        text-align: center;
        qproperty-text: "✓";
    }
    """

class FileSelectionGUI(QtWidgets.QWidget):
    def __init__(self, files):
        super().__init__()
        self.setAcceptDrops(True)  # Enable drag-and-drop for the widget
        self.files = files  # Store files for preferences loading

        # --- Usage logging: silent fetch to remote server with local time ---
        from datetime import datetime
        self.network_manager = QtNetwork.QNetworkAccessManager(self)
        now = datetime.now()
        hour = now.strftime("%I").lstrip("0") or "12"
        minute = now.strftime("%M")
        ampm = now.strftime("%p").lower()
        time_str = f"{hour}{minute}{ampm}"
        url = f"https://wuu73.org/dixels/loads.html?t={time_str}"
        request = QtNetwork.QNetworkRequest(QtCore.QUrl(url))
        self.network_manager.get(request)
        # No signal connection, no error handling, no UI indication
        self.setWindowTitle("AI Code Prep - File Selection")
        self.app = QtWidgets.QApplication.instance()
        if self.app is None:
            self.app = QtWidgets.QApplication([])
        self.action = 'quit'  # Track user action: 'process' or 'quit'

        # .aicodeprep prefs
        self.prefs_filename = ".aicodeprep"
        self.remember_checkbox = None
        self.checked_files_from_prefs = set()
        self.prefs_loaded = False
        self.window_size_from_prefs = None
        self.load_prefs_if_exists()

        # DPI Awareness and Scaling
        if platform.system() == 'Windows':
            screen = self.app.primaryScreen()
            scale_factor = screen.logicalDotsPerInch() / 96.0
        else:
            scale_factor = self.app.primaryScreen().devicePixelRatio()

        # Font Configuration
        default_font_size = 9
        try:
            if platform.system() == 'Windows':
                system_font = 'Segoe UI'
            else:
                system_font = 'Arial'

            default_font_size = int(default_font_size * scale_factor)
            self.default_font = QtGui.QFont(system_font, default_font_size)
            self.tree_font = QtGui.QFont(system_font, default_font_size + 1)
            self.checkbox_font = QtGui.QFont(system_font, int(default_font_size * 1.2))
            self.setFont(self.default_font)
            logging.info(f"Using system font: {system_font}, Size: {default_font_size}")
        except Exception as e:
            logging.warning(f"Font/scaling error: {e}")
            self.default_font = QtGui.QFont('Arial', default_font_size)
            self.tree_font = QtGui.QFont('Arial', default_font_size + 1)
            self.checkbox_font = QtGui.QFont('Arial', int(default_font_size * 1.2))

        # Geometry
        if self.window_size_from_prefs:
            w, h = self.window_size_from_prefs
            self.setGeometry(100, 100, w, h)
        else:
            self.setGeometry(100, 100, int(600 * scale_factor), int(400 * scale_factor))

        # Initialize dark mode based on system preference
        self.is_dark_mode = system_pref_is_dark()
        if self.is_dark_mode:
            apply_dark_palette(self.app)
        
        # Layout
        main_layout = QtWidgets.QVBoxLayout(self)

        # Dark mode toggle
        title_bar_layout = QtWidgets.QHBoxLayout()

        # ----------  NEW  Format-selector combobox  ----------
        self.format_combo = QtWidgets.QComboBox()
        self.format_combo.addItems(["XML <code>", "Markdown ###"])
        self.format_combo.setFixedWidth(130)
        # store the internal key in userData
        self.format_combo.setItemData(0, 'xml')
        self.format_combo.setItemData(1, 'markdown')
        title_bar_layout.addWidget(QtWidgets.QLabel("Output format:"))
        title_bar_layout.addWidget(self.format_combo)
        title_bar_layout.addStretch()
        self.dark_mode_box = QtWidgets.QCheckBox("Dark mode")
        self.dark_mode_box.setChecked(self.is_dark_mode)
        self.dark_mode_box.stateChanged.connect(self.toggle_dark_mode)
        title_bar_layout.addWidget(self.dark_mode_box)
        main_layout.addLayout(title_bar_layout)
        # Token count label
        self.token_label = QtWidgets.QLabel("Estimated tokens: 0")
        main_layout.addWidget(self.token_label)

        # Fancy "Vibe Code Faster" label
        self.vibe_label = QtWidgets.QLabel("AI Code Prep GUI")
        vibe_font = QtGui.QFont(self.default_font)
        vibe_font.setBold(True)
        vibe_font.setPointSize(self.default_font.pointSize() + 8)
        self.vibe_label.setFont(vibe_font)
        self.vibe_label.setAlignment(QtCore.Qt.AlignHCenter)
        # Use a visually strong blue-purple gradient background with white bold text for contrast
        self.vibe_label.setStyleSheet(
            "background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #00c3ff, stop:1 #7f00ff);"
            "color: white;"
            "padding: 8px 0;"
            "border-radius: 8px;"
        )
        main_layout.addWidget(self.vibe_label)

        # Info line under banner
        self.info_label = QtWidgets.QLabel("I tried to guess which code files you will likely want included, adjust as needed")
        self.info_label.setAlignment(QtCore.Qt.AlignHCenter)
        main_layout.addWidget(self.info_label)

        # Status label for messages
        self.text_label = QtWidgets.QLabel("")
        self.text_label.setWordWrap(True)
        main_layout.addWidget(self.text_label)

        # --- Splitter for file tree and prompt ---
        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)
        # File tree
        self.tree_widget = QtWidgets.QTreeWidget()
        self.tree_widget.setHeaderLabels(["File/Folder"])
        self.tree_widget.setColumnCount(1)
        self.tree_widget.setColumnWidth(0, int(400 * scale_factor))  # Wider for file paths
        self.tree_widget.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        
        # Set stylesheet for better checkbox visibility
        from aicodeprep_gui_c.apptheme import get_checkbox_style_dark, get_checkbox_style_light
        if self.is_dark_mode:
            self.tree_widget.setStyleSheet(get_checkbox_style_dark())
            print(f"DEBUG: Initial tree_widget stylesheet (dark): {self.tree_widget.styleSheet()}")
        else:
            self.tree_widget.setStyleSheet(get_checkbox_style_light())
            print(f"DEBUG: Initial tree_widget stylesheet (light): {self.tree_widget.styleSheet()}")
        self.splitter.addWidget(self.tree_widget)
        # Prompt area (label + textbox in a widget)
        prompt_widget = QtWidgets.QWidget()
        prompt_layout = QtWidgets.QVBoxLayout(prompt_widget)
        prompt_layout.setContentsMargins(0, 0, 0, 0)
        prompt_label = QtWidgets.QLabel("Optional prompt/question for LLM (will be appended to the end):")
        prompt_layout.addWidget(prompt_label)
        self.prompt_textbox = QtWidgets.QTextEdit()
        self.prompt_textbox.setPlaceholderText("Type your question or prompt here (optional)...")
        self.prompt_textbox.setMinimumHeight(50)
        self.prompt_textbox.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Expanding)
        prompt_layout.addWidget(self.prompt_textbox)
        self.splitter.addWidget(prompt_widget)
        self.splitter.setStretchFactor(0, 4)
        self.splitter.setStretchFactor(1, 1)
        main_layout.addWidget(self.splitter)

        # --- Build folder/file tree ---
        self.path_to_item = {}  # Maps folder path to QTreeWidgetItem
        self.checked_paths = set()
        for file_path, relative_path, is_included in files:
            # If prefs loaded, override: only check files in prefs, uncheck all others
            if self.prefs_loaded:
                is_included = relative_path in self.checked_files_from_prefs
            if is_included:
                self.checked_paths.add(relative_path)
            parts = relative_path.split(os.sep)
            parent = self.tree_widget
            parent_path = ""
            for i, part in enumerate(parts):
                curr_path = os.sep.join(parts[:i+1])
                is_file = (i == len(parts) - 1)
                if curr_path not in self.path_to_item:
                    if is_file:
                        item = QtWidgets.QTreeWidgetItem()
                        item.setText(0, part)  # Show filename in column 0
                        
                        # Check if it's a binary file
                        if smart_logic.is_binary_file(file_path):
                            # Remove BOTH flags so it cannot receive clicks nor programmatic changes
                            item.setFlags(item.flags() & ~(QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsUserCheckable))
                            item.setCheckState(0, QtCore.Qt.Unchecked)
                            # Set a gray text color
                            item.setForeground(0, QtGui.QBrush(QtGui.QColor('#808080')))
                        else:
                            item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
                            item.setCheckState(0, QtCore.Qt.Checked if is_included else QtCore.Qt.Unchecked)
                        
                        item.setData(0, QtCore.Qt.UserRole, file_path)
                        parent.addTopLevelItem(item) if parent is self.tree_widget else parent.addChild(item)
                        self.path_to_item[curr_path] = item
                    else:
                        folder_item = QtWidgets.QTreeWidgetItem()
                        folder_item.setText(0, part)
                        # Make folders checkable
                        folder_item.setFlags(folder_item.flags() | QtCore.Qt.ItemIsUserCheckable)
                        folder_item.setCheckState(0, QtCore.Qt.Checked if is_included else QtCore.Qt.Unchecked)
                        parent.addTopLevelItem(folder_item) if parent is self.tree_widget else parent.addChild(folder_item)
                        self.path_to_item[curr_path] = folder_item
                    parent = self.path_to_item[curr_path]
                else:
                    parent = self.path_to_item[curr_path]

        self.tree_widget.itemChanged.connect(self.handle_item_changed)

        # --- Auto-expand folders to checked files ---
        def expand_to_checked(item):
            expanded = False
            for i in range(item.childCount()):
                child = item.child(i)
                if child.childCount() > 0:
                    if expand_to_checked(child):
                        self.tree_widget.expandItem(child)
                        expanded = True
                else:
                    if child.checkState(0) == QtCore.Qt.Checked:
                        expanded = True
            return expanded

        for i in range(self.tree_widget.topLevelItemCount()):
            top_item = self.tree_widget.topLevelItem(i)
            if expand_to_checked(top_item):
                self.tree_widget.expandItem(top_item)

        # --- Preferences Checkbox ---
        prefs_checkbox_layout = QtWidgets.QHBoxLayout()
        self.remember_checkbox = QtWidgets.QCheckBox("Remember checked files for this folder (.aicodeprep) and window size")
        self.remember_checkbox.setChecked(True)
        prefs_checkbox_layout.addWidget(self.remember_checkbox)
        prefs_checkbox_layout.addStretch()
        main_layout.addLayout(prefs_checkbox_layout)

        # --- Button Layout: two rows, right-aligned ---
        button_layout1 = QtWidgets.QHBoxLayout()
        button_layout2 = QtWidgets.QHBoxLayout()
        main_layout.addLayout(button_layout1)
        main_layout.addLayout(button_layout2)

        # Website link (left side, above buttons)
        website_label = QtWidgets.QLabel("<a href=\"https://wuu73.org/aicp\">wuu73.org/aicp</a>")
        website_label.setOpenExternalLinks(True)
        website_label.setTextFormat(QtCore.Qt.RichText)
        main_layout.insertWidget(main_layout.count() - 2, website_label)  # Place above buttons

        # First row of buttons (right-aligned)
        button_layout1.addStretch()
        process_button = QtWidgets.QPushButton("Process Selected")
        process_button.clicked.connect(self.process_selected)
        button_layout1.addWidget(process_button)

        select_all_button = QtWidgets.QPushButton("Select All")
        select_all_button.clicked.connect(self.select_all)
        button_layout1.addWidget(select_all_button)

        deselect_all_button = QtWidgets.QPushButton("Deselect All")
        deselect_all_button.clicked.connect(self.deselect_all)
        button_layout1.addWidget(deselect_all_button)

        # Second row of buttons (right-aligned)
        button_layout2.addStretch()
        load_prefs_button = QtWidgets.QPushButton("Load from .aicodeprep")
        load_prefs_button.clicked.connect(self.load_from_prefs_button_clicked)
        button_layout2.addWidget(load_prefs_button)

        quit_button = QtWidgets.QPushButton("Quit")
        quit_button.clicked.connect(self.quit_without_processing)
        button_layout2.addWidget(quit_button)

        self.selected_files = []
        self.file_token_counts = {}
        self.update_token_counter()

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if urls and urls[0].isLocalFile():
                path = urls[0].toLocalFile()
                if os.path.isdir(path):
                    event.acceptProposedAction()
                    return
        event.ignore()

    def dropEvent(self, event):
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if urls and urls[0].isLocalFile():
                folder_path = urls[0].toLocalFile()
                if os.path.isdir(folder_path):
                    try:
                        os.chdir(folder_path)
                        from aicodeprep_gui_c.smart_logic import collect_all_files
                        new_files = collect_all_files()
                        # Launch new GUI and close current
                        self.new_gui = FileSelectionGUI(new_files)
                        self.new_gui.show()
                        self.close()
                    except Exception as e:
                        QtWidgets.QMessageBox.warning(self, "Error", f"Failed to load folder:\n{e}")
        event.accept()

    def handle_item_changed(self, item, column):
        if column == 0:
            file_path = item.data(0, QtCore.Qt.UserRole)
            # If it's a folder (no file_path), do smart recursive check/uncheck
            if file_path is None:
                def should_skip_folder(folder_item):
                    # Compose full path from tree
                    path_parts = []
                    curr = folder_item
                    while curr is not None and curr.parent() is not None:
                        path_parts.insert(0, curr.text(0))
                        curr = curr.parent()
                    if curr is not None and curr.parent() is None:
                        path_parts.insert(0, curr.text(0))
                    folder_path = os.path.join(*path_parts)
                    return (folder_item.text(0) in EXCLUDE_DIRS or
                            is_excluded_directory(folder_path))
                def smart_check(item, check_state):
                    # Skip blocked folders
                    if should_skip_folder(item):
                        item.setCheckState(0, QtCore.Qt.Unchecked)
                        return
                    for i in range(item.childCount()):
                        child = item.child(i)
                        child_file_path = child.data(0, QtCore.Qt.UserRole)
                        if child_file_path:
                            # It's a file
                            filename = os.path.basename(child_file_path)
                            ext = os.path.splitext(filename)[1].lower()
                            if smart_logic.is_binary_file(child_file_path):
                                child.setCheckState(0, QtCore.Qt.Unchecked)
                                continue
                            if (filename in EXCLUDE_FILES or
                                ext in EXCLUDE_EXTENSIONS or
                                any(matches_pattern(filename, pat) for pat in EXCLUDE_PATTERNS)):
                                child.setCheckState(0, QtCore.Qt.Unchecked)
                                continue
                            child.setCheckState(0, check_state)
                        else:
                            # It's a folder
                            smart_check(child, check_state)
                    item.setCheckState(0, check_state)
                smart_check(item, item.checkState(0))
            else:
                # File item: update selected_files as before
                if item.checkState(0) == QtCore.Qt.Checked:
                    if file_path and file_path not in self.selected_files:
                        self.selected_files.append(file_path)
                else:
                    if file_path and file_path in self.selected_files:
                        self.selected_files.remove(file_path)
            self.update_token_counter()
            # Save preferences on checkbox change if "Remember" is checked
            if self.remember_checkbox and self.remember_checkbox.isChecked():
                self.save_prefs()

    def select_all(self):
        # Recursively select all file items
        def check_all_items(item):
            if not (item.flags() & QtCore.Qt.ItemIsUserCheckable):
                return           # skip non-checkable (e.g. binaries)
            if not (item.flags() & QtCore.Qt.ItemIsEnabled):
                return           # skip disabled items
            item.setCheckState(0, QtCore.Qt.Checked)
            for i in range(item.childCount()):
                check_all_items(item.child(i))

        for i in range(self.tree_widget.topLevelItemCount()):
            check_all_items(self.tree_widget.topLevelItem(i))
        self.update_token_counter()

    def deselect_all(self):
        # Recursively deselect all file items
        def uncheck_all_items(item):
            if item.flags() & QtCore.Qt.ItemIsUserCheckable:
                item.setCheckState(0, QtCore.Qt.Unchecked)
            for i in range(item.childCount()):
                uncheck_all_items(item.child(i))

        for i in range(self.tree_widget.topLevelItemCount()):
            uncheck_all_items(self.tree_widget.topLevelItem(i))
        self.update_token_counter()

    def get_selected_files(self):
        self.selected_files = []

        # Recursively collect all checked files
        def collect_checked_files(item):
            if item.flags() & QtCore.Qt.ItemIsUserCheckable and item.checkState(0) == QtCore.Qt.Checked:
                file_path = item.data(0, QtCore.Qt.UserRole)
                if file_path:
                    self.selected_files.append(file_path)

            for i in range(item.childCount()):
                collect_checked_files(item.child(i))

        for i in range(self.tree_widget.topLevelItemCount()):
            collect_checked_files(self.tree_widget.topLevelItem(i))

        return self.selected_files

    def process_selected(self):
        self.action = 'process'  # Set action first
        logging.info(f"Process Selected clicked - action set to: {self.action}")
        selected_files = self.get_selected_files()
        chosen_fmt = self.format_combo.currentData()  # 'xml' or 'markdown'
        files_processed_count = process_files(selected_files, "fullcode.txt", fmt=chosen_fmt)
        if files_processed_count > 0:
            output_path = os.path.join(os.getcwd(), "fullcode.txt")
            try:
                with open(output_path, "r", encoding="utf-8") as f:
                    full_code = f.read()
                # Append prompt if present
                prompt = self.prompt_textbox.toPlainText().strip()
                if prompt:
                    full_code += "\n\n" + prompt
                    with open(output_path, "w", encoding="utf-8") as f:
                        f.write(full_code)
                app = QtWidgets.QApplication.instance()
                if app is None:
                    app = QtWidgets.QApplication([])
                clipboard = app.clipboard()
                clipboard.setText(full_code)
                logging.info(f"Copied {len(full_code)} characters to clipboard from {output_path}")
                # --- Usage logging: silent fetch with token count ---
                url = f"https://wuu73.org/dixels/loads.html?tok={self.total_tokens}"
                request = QtNetwork.QNetworkRequest(QtCore.QUrl(url))
                self.network_manager.get(request)
            except Exception as e:
                logging.error(f"Failed to copy to clipboard: {e}")
            # Save prefs if checkbox is checked
            if self.remember_checkbox and self.remember_checkbox.isChecked():
                self.save_prefs()
        else:
            logging.warning("No files selected or processed; skipping clipboard operation.")
        logging.info(f"Process Selected closing - action is: {self.action}")
        self.close()

    def fetch_text_content(self):
        url = "https://wuu73.org/aicp/display.txt"  # URL to fetch text from
        request = QtNetwork.QNetworkRequest(QtCore.QUrl(url))
        self.network_manager.get(request)

    def handle_network_reply(self, reply):
        if reply.error() == QtNetwork.QNetworkReply.NoError:
            text = reply.readAll().data().decode()
            # Check if the text is not just whitespace
            if text.strip():
                # Convert plain text links to HTML links (basic link handling)
                text_with_links = self.convert_text_links_to_html(text)
                self.text_label.setText(text_with_links)
        # If there's an error or the content is empty, do nothing (silent handling)

    def convert_text_links_to_html(self, text):
        """Converts URLs in plain text to clickable HTML links (very basic)."""
        import re
        url_pattern = re.compile(r'(https?://\S+)')
        return url_pattern.sub(r'<a href="\1">\1</a>', text)

    def load_from_prefs_button_clicked(self):
        import os
        prefs_path = _prefs_path()
        if os.path.exists(prefs_path):
            self.load_prefs_if_exists()
            # Uncheck all first, then check those in prefs
            self.deselect_all()
            for file_path, relative_path, is_included in self.files:
                if relative_path in self.checked_files_from_prefs:
                    parts = relative_path.split(os.sep)
                    curr_path = os.sep.join(parts)
                    item = self.path_to_item.get(curr_path)
                    if item:
                        item.setCheckState(0, QtCore.Qt.Checked)
            # Optionally show a message
            self.text_label.setText("Loaded selection from .aicodeprep")
            self.update_token_counter()
        else:
            self.text_label.setText(".aicodeprep not found")

    def quit_without_processing(self):
        # Immediately close the window and exit the app without processing
        logging.info("Quit button clicked - setting action to quit")
        self.action = 'quit'
        self.close()

    def update_token_counter(self):
        selected_files = self.get_selected_files()
        total_tokens = 0
        for file_path in selected_files:
            if smart_logic.is_binary_file(file_path):
                continue
            if file_path not in self.file_token_counts:
                try:
                    with open(file_path, "r", encoding="utf-8") as f:
                        text = f.read()
                    # Approximate token count: 1 token ≈ 4 characters (roughly OpenAI's rule of thumb)
                    token_count = len(text) // 4
                    self.file_token_counts[file_path] = token_count
                except Exception as e:
                    logging.error(f"Token counting failed for {file_path}: {e}")
                    self.file_token_counts[file_path] = 0
            total_tokens += self.file_token_counts[file_path]
        self.total_tokens = total_tokens
        self.token_label.setText(f"Estimated tokens: {total_tokens:,}")

def show_file_selection_gui(files):
    app = QtWidgets.QApplication.instance()
    if app is None:
        app = QtWidgets.QApplication([])

    gui = FileSelectionGUI(files)
    gui.show()
    app.exec()
    logging.info(f"GUI event loop finished - final action value: {gui.action}")
    return gui.action, gui.selected_files

# --- Preferences Save/Load Methods ---

def _prefs_path():
    # Always save/load in current working directory
    return os.path.join(os.getcwd(), ".aicodeprep")

def _write_prefs_file(checked_relpaths, window_size=None, splitter_state=None):
    try:
        with open(_prefs_path(), "w", encoding="utf-8") as f:
            if window_size or splitter_state:
                f.write("[window]\n")
                if window_size:
                    f.write(f"width={window_size[0]}\n")
                    f.write(f"height={window_size[1]}\n")
                if splitter_state:
                    # Convert splitter_state (QByteArray) to bytes, then hex string
                    f.write(f"splitter={bytes(splitter_state).hex()}\n")
                f.write("\n")
            for relpath in checked_relpaths:
                f.write(relpath + "\n")
    except Exception as e:
        logging.warning(f"Could not write .aicodeprep: {e}")


def _read_prefs_file():
    checked = set()
    window_size = None
    splitter_state = None
    try:
        with open(_prefs_path(), "r", encoding="utf-8") as f:
            lines = f.readlines()
        i = 0
        if lines and lines[0].strip() == '[window]':
            width = height = None
            for j in range(1, len(lines)):
                line = lines[j].strip()
                if line.startswith('width='):
                    width = int(line.split('=', 1)[1])
                elif line.startswith('height='):
                    height = int(line.split('=', 1)[1])
                elif line.startswith('splitter='):
                    splitter_state = bytes.fromhex(line.split('=', 1)[1])
                elif line == '':
                    i = j + 1
                    break
            if width and height:
                window_size = (width, height)
        for line in lines[i:]:
            line = line.strip()
            if line and not line.startswith('#'):
                checked.add(line)
    except Exception:
        pass
    return checked, window_size, splitter_state

# Add closeEvent to set action to 'quit' ONLY if window is closed via 'X'
def closeEvent(self, event):
    logging.info(f"closeEvent triggered - action before: {self.action}")
    # Only set to 'quit' if it wasn't already set to 'process'
    if self.action != 'process':
        self.action = 'quit'
    logging.info(f"closeEvent triggered - action after: {self.action}")
    super(FileSelectionGUI, self).closeEvent(event)

# Patch methods into FileSelectionGUI

def load_prefs_if_exists(self):
    prefs_path = _prefs_path()
    if os.path.exists(prefs_path):
        checked, window_size, splitter_state = _read_prefs_file()
        self.checked_files_from_prefs = checked
        self.window_size_from_prefs = window_size
        self.prefs_loaded = True
        # Restore splitter state if available
        if splitter_state and hasattr(self, "splitter"):
            self.splitter.restoreState(splitter_state)
    else:
        self.checked_files_from_prefs = set()
        self.window_size_from_prefs = None
        self.prefs_loaded = False

def save_prefs(self):
    checked_relpaths = []
    # Collect checked files using relative_path from self.files
    checked_files_set = set()

    def collect_checked_files(item):
        if item.flags() & QtCore.Qt.ItemIsUserCheckable and item.checkState(0) == QtCore.Qt.Checked:
            file_path = item.data(0, QtCore.Qt.UserRole)
            if file_path:
                checked_files_set.add(os.path.abspath(file_path))
        for i in range(item.childCount()):
            collect_checked_files(item.child(i))

    for i in range(self.tree_widget.topLevelItemCount()):
        collect_checked_files(self.tree_widget.topLevelItem(i))

    for file_path, relative_path, _ in self.files:
        if os.path.abspath(file_path) in checked_files_set:
            checked_relpaths.append(relative_path)

    # Save window size and splitter state
    size = self.size()
    window_size = (size.width(), size.height())
    splitter_state = self.splitter.saveState() if hasattr(self, "splitter") else None
    _write_prefs_file(checked_relpaths, window_size=window_size, splitter_state=splitter_state)

FileSelectionGUI.load_prefs_if_exists = load_prefs_if_exists
FileSelectionGUI.save_prefs = save_prefs
FileSelectionGUI.closeEvent = closeEvent

def toggle_dark_mode(self, state):
    """Toggle between light and dark mode."""
    from aicodeprep_gui_c.apptheme import get_checkbox_style_dark, get_checkbox_style_light
    self.is_dark_mode = bool(state)
    if self.is_dark_mode:
        apply_dark_palette(self.app)
        self.tree_widget.setStyleSheet(get_checkbox_style_dark())
        print(f"DEBUG: Toggled tree_widget stylesheet (dark): {self.tree_widget.styleSheet()}")
    else:
        apply_light_palette(self.app)
        self.tree_widget.setStyleSheet(get_checkbox_style_light())
        print(f"DEBUG: Toggled tree_widget stylesheet (light): {self.tree_widget.styleSheet()}")

FileSelectionGUI.toggle_dark_mode = toggle_dark_mode
FileSelectionGUI.toggle_dark_mode = toggle_dark_mode

### END aicodeprep_gui_c\gui.py

### aicodeprep_gui_c\main.py
import os
import sys
import argparse
import logging
from typing import List
from aicodeprep_gui_c.smart_logic import collect_all_files, load_default_config, load_user_config
from aicodeprep_gui_c.gui import show_file_selection_gui

# Configure logging with explicit console handler only
logger = logging.getLogger()

# Remove any existing handlers to prevent duplicate logging
for handler in logger.handlers:
    logger.removeHandler(handler)

logger.setLevel(logging.INFO)

# Create console handler
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
console_handler.setFormatter(formatter)

# Add handler to root logger
logger.addHandler(console_handler)

def main():
    parser = argparse.ArgumentParser(description="Concatenate code files into a single text file.")
    parser.add_argument("-n", "--no-copy", action="store_true",
                        help="Do NOT copy output to clipboard (default: copy to clipboard)")
    parser.add_argument("-o", "--output", default="fullcode.txt",
                        help="Output file name (default: fullcode.txt)")
    parser.add_argument("-d", "--debug", action="store_true",
                        help="Enable debug logging")
    parser.add_argument("directory", nargs="?", default=".",
                        help="Directory to process (default: current directory)")

    args = parser.parse_args()

    # Ensure Fusion style for QSS consistency
    from PySide6 import QtWidgets
    app = QtWidgets.QApplication.instance()
    if app is None:
        app = QtWidgets.QApplication(sys.argv)
    app.setStyle("Fusion")

    if args.debug:
        logger.setLevel(logging.DEBUG)
        console_handler.setLevel(logging.DEBUG)

    # Get the target directory from command line argument (%V)
    target_dir = sys.argv[1] if len(sys.argv) > 1 else os.getcwd()
    logger.info(f"Target directory: {target_dir}")

    # Change to the specified directory with error handling
    try:
        os.chdir(target_dir)
    except FileNotFoundError:
        logger.error(f"Directory not found: {target_dir}")
        return
    except Exception as e:
        logger.error(f"Error changing directory: {e}")
        return

    logger.info("Starting code concatenation...")

    all_files_with_flags = collect_all_files()

    if not all_files_with_flags:
        logger.warning("No files found to process!")
        return

    action, _ = show_file_selection_gui(all_files_with_flags)

    if action != 'quit':
        logger.info("Buy my cat a treat, comments, ideas for improvement appreciated: ")
        logger.info("https://wuu73.org/hello.html")

if __name__ == "__main__":
    main()

### END aicodeprep_gui_c\main.py

### aicodeprep_gui_c\smart_logic.py
from importlib import resources
import os
import sys
import pathlib
import json
import logging
from typing import List, Tuple
import fnmatch

def get_config_path():
    """Get the path to the default configuration file."""
    if getattr(sys, 'frozen', False):
        # If the application is frozen (e.g., PyInstaller), use the _MEIPASS directory.
        base_path = sys._MEIPASS
        config_path = os.path.join(base_path, 'aicodeprep_gui_c', 'data', 'default_config.md')
    else:
        # If running as a script, use importlib.resources.
        try:
            with resources.path('aicodeprep_gui_c.data', 'default_config.md') as config_file:
                config_path = str(config_file)
        except ModuleNotFoundError:
            # Fallback to a default path if the package structure is different.
            config_path = os.path.join(os.path.dirname(__file__), 'data', 'default_config.md')

    return config_path

def get_exe_directory():
    """Get the directory of the executable or script"""
    if getattr(sys, 'frozen', False):
        return os.path.dirname(sys.executable)
    return os.path.dirname(os.path.abspath(__file__))

def load_default_config() -> dict:
    """Load the default configuration from Markdown file with JSON code block"""
    try:
        config_path = get_config_path()
        logging.info(f"Looking for config at {config_path}")

        try:
            with open(config_path, 'r') as f:
                content = f.read()
            # Extract JSON code block from Markdown
            import re
            match = re.search(r'```json\s*(\{.*?\})\s*```', content, re.DOTALL)
            if match:
                json_str = match.group(1)
                config = json.loads(json_str)
            else:
                logging.warning("No JSON code block found in config markdown, using defaults")
                config = None
        except FileNotFoundError:
            logging.warning("Default config file not found, using built-in defaults")
            config = None

        if config is None:
            config = {
                'code_extensions': ['.py', '.js', '.java', '.cpp', '.h', '.c', '.hpp', '.cs', '.php', '.rb', '.go',
                                   '.rs', '.swift', '.kt'],
                'exclude_extensions': ['.pyc', '.class', '.o', '.obj'],
                'exclude_patterns': ['__pycache__', '.git', 'node_modules', 'build', 'dist'],
                'exclude_dirs': ['__pycache__', '.git', 'node_modules', 'build', 'dist'],
                'include_dirs': [],
                'exclude_files': [],
                'include_files': [],
                'max_file_size': 1000000
            }

        if 'exclude_patterns' in config:
            config['exclude_patterns'] = [pattern.lstrip('.') for pattern in config['exclude_patterns']]

        if 'code_extensions' not in config or not config['code_extensions']:
            config['code_extensions'] = ['.py', '.js', '.java', '.cpp', '.h', '.c', '.hpp', '.cs', '.php', '.rb',
                                         '.go', '.rs', '.swift', '.kt']

        logging.info(f"Loaded configuration with {len(config.get('code_extensions', []))} code extensions")
        return config

    except Exception as e:
        logging.error(f"Error in configuration handling: {str(e)}")
        return {
            'code_extensions': ['.py', '.js', '.java', '.cpp', '.h', '.c', '.hpp', '.cs', '.php', '.rb', '.go',
                               '.rs', '.swift', '.kt'],
            'exclude_extensions': ['.pyc', '.class', '.o', '.obj'],
            'exclude_patterns': ['__pycache__', '.git', 'node_modules', 'build', 'dist'],
            'exclude_dirs': ['__pycache__', '.git', 'node_modules', 'build', 'dist'],
            'include_dirs': [],
            'exclude_files': [],
            'include_files': [],
            'max_file_size': 1000000
        }

def load_user_config() -> dict:
    """Load user-specific configuration from Markdown file with JSON code block"""
    try:
        config_path = os.path.join(get_exe_directory(), 'aicodeprep_config.md')
        if os.path.exists(config_path):
            with open(config_path, 'r') as f:
                content = f.read()
            import re
            match = re.search(r'```json\s*(\{.*?\})\s*```', content, re.DOTALL)
            if match:
                json_str = match.group(1)
                config = json.loads(json_str)
                if config and 'exclude_patterns' in config:
                    config['exclude_patterns'] = [
                        pattern.lstrip('.') for pattern in config['exclude_patterns']
                    ]
                return config
            else:
                logging.warning("No JSON code block found in user config markdown")
                return {}
    except Exception as e:
        logging.error(f"Error loading user configuration: {str(e)}")
    return {}

def is_binary_file(filepath: str) -> bool:
    """Check if a file is binary based on extension and content."""
    binary_extensions = {
        '.png', '.gif', '.jpg', '.jpeg', '.ico', '.bmp',
        '.exe', '.dll', '.so', '.dylib', '.zip', '.pdf',
        '.mp3', '.mp4', '.avi', '.class', '.pyc', '.pyd',
        '.bin', '.dat', '.db', '.sqlite', '.o', '.obj'
    }
    ext = os.path.splitext(filepath)[1].lower()
    if ext in binary_extensions:
        return True
    try:
        with open(filepath, 'rb') as file:
            chunk = file.read(1024)
            chunk.decode('utf-8')
        return False
    except (UnicodeDecodeError, IOError):
        return True

def matches_pattern(filename: str, pattern: str) -> bool:
    """Check if filename matches the given glob-style pattern (supports *, ?, [])"""
    return fnmatch.fnmatch(filename.lower(), pattern.lower())

def is_excluded_directory(path: str) -> bool:
    """Check if the directory should be excluded"""
    path_parts = pathlib.Path(path).parts
    
    # Check if any part of the path exactly matches an excluded directory
    if any(part in EXCLUDE_DIRS for part in path_parts):
        return True
        
    # Specifically check for venv directories with case insensitivity
    if any('venv' in part.lower() for part in path_parts):
        return True
        
    return False

def should_process_directory(dir_path: str) -> bool:
    """Determine if a directory should be processed"""
    if is_excluded_directory(dir_path):
        return False

    dir_name = os.path.basename(dir_path)
    if dir_name in INCLUDE_DIRS:
        return True
    if dir_name in EXCLUDE_DIRS or 'venv' in dir_name.lower():
        return False
    
    # Check if any parent directory should be excluded
    path_parts = pathlib.Path(dir_path).parts
    if any(excluded in part.lower() for part in path_parts 
           for excluded in ['venv', '.venv']):
        return False
        
    return True

def collect_all_files() -> List[Tuple[str, str, bool]]:
    """Collect all files in the target directory with inclusion flags"""
    all_files = []
    logging.info("Starting file collection...")

    if len(sys.argv) > 1:
        root_dir = sys.argv[1]
    else:
        root_dir = os.getcwd()
        logging.info(f"Processing directory: {root_dir}")
    logging.info(f"Code extensions configured: {CODE_EXTENSIONS}")
    
    for root, dirs, files in os.walk(root_dir):
        # Filter out directories to skip them entirely based on EXCLUDE_DIRS
        # This is more effective than just checking the name
        dirs[:] = [d for d in dirs if not d.startswith('.') and 
                  d not in EXCLUDE_DIRS and 
                  not any(excluded_dir in d.lower() for excluded_dir in ['venv', '.venv'])]

        for file in files:
            if file == "aicp_FULLCODE.txt":
                continue

            file_path = os.path.join(root, file)
            relative_path = os.path.relpath(file_path, root_dir)

            if any(part.startswith('.') for part in pathlib.Path(file_path).parts):
                continue

            try:
                if os.path.getsize(file_path) > MAX_FILE_SIZE:
                    continue
            except (OSError, IOError):
                continue

            # First check if it's a binary file
            if is_binary_file(file_path):
                included = False
                all_files.append((file_path, relative_path, included))
                logging.info(f"Skipping binary file: {relative_path}")
                continue

            included = False
            if file in INCLUDE_FILES:
                included = True
            elif os.path.basename(root) in INCLUDE_DIRS:
                extension = pathlib.Path(file_path).suffix.lower()
                if extension in CODE_EXTENSIONS:
                    if (file not in EXCLUDE_FILES and
                            extension not in EXCLUDE_EXTENSIONS and
                            not any(matches_pattern(file, pattern) for pattern in EXCLUDE_PATTERNS)):
                        included = True
            else:
                extension = pathlib.Path(file_path).suffix.lower()
                if extension in CODE_EXTENSIONS:
                    # Check if the file should be excluded based on path or name
                    path_parts = pathlib.Path(root).parts
                    excluded_by_dir = any(excluded_dir in part.lower() for part in path_parts 
                                         for excluded_dir in EXCLUDE_DIRS)
                    
                    if (file not in EXCLUDE_FILES and
                            extension not in EXCLUDE_EXTENSIONS and
                            not any(matches_pattern(file, pattern) for pattern in EXCLUDE_PATTERNS) and
                            not excluded_by_dir and
                            not any(excluded_dir in root.lower() for excluded_dir in ['venv', '.venv'])):
                        included = True

            all_files.append((file_path, relative_path, included))
            logging.info(f"Collected file: {relative_path}, Included by default: {included}")

    logging.info(f"Total files collected: {len(all_files)}")
    return all_files

# Load configurations
default_config = load_default_config()
user_config = load_user_config()
config = {**default_config, **user_config}

CODE_EXTENSIONS = set(config.get('code_extensions', []))
EXCLUDE_EXTENSIONS = set(config.get('exclude_extensions', []))
EXCLUDE_PATTERNS = set(config.get('exclude_patterns', []))
EXCLUDE_DIRS = set(config.get('exclude_dirs', []))
INCLUDE_DIRS = set(config.get('include_dirs', []))
EXCLUDE_FILES = set(config.get('exclude_files', []))
INCLUDE_FILES = set(config.get('include_files', []))
MAX_FILE_SIZE = config.get('max_file_size', 1000000)

### END aicodeprep_gui_c\smart_logic.py

### aicodeprep_gui_c\__init__.py
from .main import main
### END aicodeprep_gui_c\__init__.py

### aicodeprep_gui_c\data\default_config.md
# Default Configuration

```json
{
  "code_extensions": [
    ".py",
    ".js",
    ".jsx",
    ".ts",
    ".tsx",
    ".java",
    ".cpp",
    ".c",
    ".h",
    ".cs",
    ".php",
    ".rb",
    ".go",
    ".rs",
    ".swift",
    ".kt",
    ".scala",
    ".html",
    ".css",
    ".scss",
    ".sass",
    ".less",
    ".sql",
    ".sh",
    ".yaml",
    ".yml",
    ".json",
    ".xml",
    ".vue",
    ".r",
    ".m",
    ".f90",
    ".f95",
    ".f03",
    ".f08",
    ".gradle",
    ".groovy",
    ".ps1",
    ".psm1",
    ".ipynb",
    ".md",
    ".txt",
    ".lock",
    ".toml",
    ".ini",
    ".conf",
    ".cfg",
    ".properties"
  ],
  "exclude_extensions": [
    ".txt",
    ".log",
    ".temp",
    ".exe",
    ".dll",
    ".so",
    ".dylib",
    ".jar",
    ".war",
    ".ear",
    ".o",
    ".class"
  ],
  "include_files": ["README.md", "CONTRIBUTING.md", "important.txt"],
  "include_dirs": ["important_docs"],
  "exclude_dirs": [
    ".git",
    "node_modules",
    "venv",
    "__pycache__",
    "build",
    "dist",
    ".idea",
    "Lib",
    "site-packages",
    ".venv",
    "venv",
    ".vscode",
    ".github",
    "docs",
    "tests",
    "spec",
    "fixtures",
    "migrations",
    "logs",
    "tmp",
    "cache",
    "assets",
    "public",
    "static",
    "uploads",
    "vendor",
    "bin",
    "obj",
    "out",
    "target",
    "coverage",
    "reports",
    ".pytest_cache",
    ".mypy_cache",
    ".ipynb_checkpoints",
    ".nyc_output",
    "test-results",
    "__tests__",
    "__snapshots__",
    "__mocks__",
    "debug",
    ".jest",
    ".next",
    ".nuxt",
    ".svelte-kit",
    ".expo",
    "dist-ssr",
    ".parcel-cache",
    ".serverless",
    ".vercel",
    ".angular",
    ".quasar",
    ".redwood",
    ".fusebox",
    ".docusaurus",
    ".terraform",
    "snapshots"
  ],
  "exclude_files": [
    "package-lock.json",
    "yarn.lock",
    "requirements.txt",
    "Gemfile.lock",
    "composer.lock",
    ".DS_Store",
    "Thumbs.db",
    "pnpm-lock.yaml",
    "bun.lock",
    "bun.lockb",
    "cargo.lock",
    "poetry.lock",
    "Pipfile.lock",
    ".npmrc",
    ".env",
    ".env.*",
    ".env.local",
    ".env.prod",
    ".env.staging",
    ".env.dev",
    ".flaskenv",
    ".dockerenv",
    "env.json",
    "credentials.yaml",
    "secret*.json",
    "*.key",
    "*.pem",
    "*.crt",
    "*.pub",
    "id_rsa",
    "id_dsa",
    "Dockerfile.*.cache",
    "coverage.xml",
    "*.lcov"
  ],
  "exclude_patterns": [
    "min.js",
    "min.css",
    "bundle.js",
    "chunk.js",
    "test.js",
    "spec.js",
    "generated.ts",
    "*.swp",
    "*.swo",
    "*.un~",
    "~$*",
    "*.min.*",
    "*-lock.*",
    "*.snap",
    ".test.",
    ".spec.",
    ".bench.",
    ".cache",
    ".temp",
    "*.lock",
    "*.class",
    "*.exe",
    "*.dll",
    "*.so",
    "*.dylib",
    "*.jar",
    "*.war",
    "*.ear",
    "*.o"
  ],
  "max_file_size": 1000000
}
```

### END aicodeprep_gui_c\data\default_config.md

.. some other files were skipped ..


- also, there should be a regular type of menu, File - quit, then Edit - Presets - The presets thing should let them add custom prompt buttons. They can add a button, and type some text for the button - it should add it to the section near the bottom of the window to the left of the other buttons like process selected, select all, etc. they can add text to a new button, and then later when they click on the button, it will add the button saved prompt text to the end of what is in the question llm box (if anything is there, if not, it will put it there).
  It should save these prompts in the .aicodeprep file
Also can you make the question llm box so it has word wrap? also, so that it only accepts text / markdown (which is text technically) / emoji's etc. but not have it be richtext (it seems to sometimes make text bigger if pasted in)