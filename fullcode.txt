can you create a privacy policy file, and make a new info menu next to file, edit... and then Info/Privacy policy will show it in a new window (with just an ok button to close it, or close button)? Analyze the code for any data it collects, which should be just anonymous information like when it tries to fetch the dixels url just to count how many people use the app etc. or what time they use it but nothing identifiyable. Write a prompt for Cline the ai coding agent to make the new file and make the edits for the menu changes, enclose the whole cline prompt in a single code tag.

aicodeprep_gui\data\default_config.toml:
<code>
# aicodeprep-gui - Default Configuration File
# This file provides the baseline settings for file filtering.
# You can override these settings by creating an `aicodeprep-gui.toml` file
# in your project's root directory.
#
# This file uses the TOML format.
# All exclusion/inclusion patterns use the same syntax as a .gitignore file.
# - A trailing slash '/' matches a directory (e.g., "build/").
# - A leading '!' negates a pattern, re-including a file if it was excluded by a previous pattern.
# - Wildcards like '*' are supported.

max_file_size = 4000000

# File extensions that are considered code and will be checked by default.
# Grouped by category for easier review.
code_extensions = [
    # -- Web & Frontend --
    ".html", ".css", ".scss", ".sass", ".less", ".js", ".jsx", ".ts", ".tsx",
    ".vue", ".svelte", ".astro",

    # -- Backend & General Purpose --
    ".py", ".java", ".c", ".cpp", ".h", ".cs", ".php", ".rb", ".go", ".rs",
    ".swift", ".kt", ".scala", ".r", ".m", ".pl", ".lua", ".dart", ".erl",
    ".ex", ".exs", ".clj",

    # -- Scripts & Shell --
    ".sh", ".bash", ".zsh", ".ps1", ".psm1", ".groovy",

    # -- Data & Markup --
    ".json", ".xml", ".yaml", ".yml", ".toml", ".ini", ".md", ".sql", ".csv",
    ".tsv",

    # -- Config & Build --
    ".conf", ".cfg", ".properties", ".gradle", ".f90", ".f95", ".f03", ".f08",
    ".editorconfig", "Dockerfile", ".env.example", ".env.sample", "Jenkinsfile",
    
    # -- Notebooks & Text --
    ".ipynb", ".txt",

    # -- Lock files (sometimes useful for context, but often excluded below) --
    ".lock",
]

# --- UNIFIED INCLUSION/EXCLUSION LISTS using .gitignore syntax ---

# Patterns for files/dirs to be checked *by default*.
# These are high-value files that provide critical context about a project.
default_include_patterns = [
    # Core project documentation
    "README.md",
    "CONTRIBUTING.md",
    "CHANGELOG.md",
    "LICENSE",
    "CODE_OF_CONDUCT.md",

    # Core project definition files
    "pyproject.toml",
    "package.json",
    "requirements.txt",
    "pom.xml",
    "build.gradle",
    "Gemfile",
    "go.mod",
    "Cargo.toml",
    "composer.json",

    # Environment and containerization
    "Dockerfile",
    "docker-compose.yml",
    ".env.example",
    ".env.sample",

    # Important configuration or documentation
    "important.txt",
    "important_docs/",
]

# Patterns for files/dirs to be excluded from the GUI list or unchecked by default.
# Grouped by category for clarity.
exclude_patterns = [
    # -- Version Control --
    ".git/",
    ".svn/",
    ".hg/",

    # -- Dependency & Package Manager Directories --
    "node_modules/",
    "bower_components/",
    "vendor/",
    "deps/", # Elixir

    # -- Python-specific --
    "venv/",
    ".venv/",
    "__pycache__/",
    "Lib/",
    "site-packages/",
    "*.egg-info/",
    ".tox/",

    # -- IDE & Editor Directories --
    ".idea/",
    ".vscode/",
    ".project",
    ".classpath",
    ".settings/",
    "nbproject/", # Netbeans
    "*.sublime-project",
    "*.sublime-workspace",

    # -- Build, Dist & Compilation Output --
    "build/",
    "dist/",
    "dist-ssr/",
    "bin/",
    "obj/",
    "out/",
    "target/",
    "_build/", # Elixir, Erlang
    "*.o",
    "*.pyc",
    "*.class",
    "*.exe",
    "*.dll",
    "*.so",
    "*.dylib",
    "*.jar",
    "*.war",
    "*.ear",

    # -- Framework & Tool Caches/Builds --
    ".parcel-cache/",
    ".next/",
    ".nuxt/",
    ".svelte-kit/",
    ".docusaurus/",
    ".angular/",
    ".quasar/",
    ".redwood/",
    ".fusebox/",
    ".expo/",
    ".serverless/",
    ".vercel/",
    ".dart_tool/",
    ".elixir_ls/",

    # -- Test, Coverage & Report Artifacts --
    "coverage/",
    "reports/",
    "test-results/",
    "test-reports/",
    "playwright-report/",
    "junit.xml",
    "coverage.xml",
    "*.lcov",
    ".pytest_cache/",
    ".mypy_cache/",
    ".nyc_output/",
    ".jest/",
    "*snapshots*/",

    # -- Logs & Temporary Files --
    "logs/",
    "tmp/",
    "temp/",
    "cache/",
    ".cache/",
    "*.log",
    "*.log.*",
    "npm-debug.log*",
    "yarn-error.log",
    "*.swp",
    "*.swo",
    "*.un~",
    "~$*",
    "*.temp",

    # -- OS & System Files --
    ".DS_Store",
    "Thumbs.db",
    "desktop.ini",

    # -- Lock files (usually not needed as they are machine-generated) --
    "package-lock.json",
    "yarn.lock",
    "Gemfile.lock",
    "composer.lock",
    "pnpm-lock.yaml",
    "bun.lockb",
    "cargo.lock",
    "poetry.lock",
    "Pipfile.lock",

    # -- Secrets, Keys & Sensitive Environment Files --
    ".npmrc",
    ".env",
    ".env.*",
    "!.env.example", # Re-include example files if they were excluded by .env.*
    "!.env.sample",
    ".flaskenv",
    ".dockerenv",
    "env.json",
    "credentials.yaml",
    "secret*.json",
    "*.key",
    "*.pem",
    "*.crt",
    "*.pub",
    "id_rsa",
    "id_dsa",

    # -- Terraform State --
    ".terraform/",
    ".terraform.lock.hcl",
    "terraform.tfstate",
    "terraform.tfstate.backup",

    # -- General Generated & Minified Patterns --
    "*generated*",
    "*.min.js",
    "*.min.css",
    "*.min.*",
    "*bundle.js",
    "*chunk.js",
    "*.snap", # Jest snapshots
    "*.test.",
    ".spec.",
    ".bench.",

]

</code>

aicodeprep_gui\images\__init__.py:
<code>

</code>

aicodeprep_gui\apptheme.py:
<code>
from PySide6 import QtCore, QtGui, QtWidgets
import platform
import os
import sys
import ctypes
import json
import logging
from importlib import resources

def system_pref_is_dark() -> bool:
    """Detect if system is using dark mode."""
    system = platform.system()
    
    if system == "Darwin":  # macOS
        try:
            import subprocess
            cmd = "defaults read -g AppleInterfaceStyle"
            result = subprocess.run(cmd, shell=True, text=True, capture_output=True)
            return result.stdout.strip() == "Dark"
        except:
            pass
    
    elif system == "Windows":  # Windows 10+
        try:
            import winreg
            registry = winreg.ConnectRegistry(None, winreg.HKEY_CURRENT_USER)
            reg_keypath = r"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize"
            key = winreg.OpenKey(registry, reg_keypath)
            value, _ = winreg.QueryValueEx(key, "AppsUseLightTheme")
            return value == 0
        except:
            pass
    
    # Fallback: use palette heuristic
    return QtWidgets.QApplication.palette().color(QtGui.QPalette.Window).lightness() < 128

def apply_dark_palette(app: QtWidgets.QApplication):
    """Apply dark color palette to application."""
    dark = QtGui.QPalette()
    dark.setColor(QtGui.QPalette.Window, QtGui.QColor(53, 53, 53))
    dark.setColor(QtGui.QPalette.WindowText, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Base, QtGui.QColor(42, 42, 42))
    dark.setColor(QtGui.QPalette.AlternateBase, QtGui.QColor(66, 66, 66))
    dark.setColor(QtGui.QPalette.ToolTipBase, QtGui.QColor(53, 53, 53))
    dark.setColor(QtGui.QPalette.ToolTipText, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Text, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Button, QtGui.QColor(53, 53, 53))
    dark.setColor(QtGui.QPalette.ButtonText, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Link, QtGui.QColor(42, 130, 218))
    dark.setColor(QtGui.QPalette.Highlight, QtGui.QColor(42, 130, 218))
    dark.setColor(QtGui.QPalette.HighlightedText, QtGui.QColor(255, 255, 255))
    
    # Disabled colors
    dark.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.Text, QtGui.QColor(128, 128, 128))
    dark.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, QtGui.QColor(128, 128, 128))
    dark.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, QtGui.QColor(128, 128, 128))
    
    app.setPalette(dark)

def apply_light_palette(app: QtWidgets.QApplication):
    """Apply light color palette to application."""
    light = QtGui.QPalette()
    light.setColor(QtGui.QPalette.Window, QtGui.QColor(240, 240, 240))
    light.setColor(QtGui.QPalette.WindowText, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Base, QtGui.QColor(255, 255, 255))
    light.setColor(QtGui.QPalette.AlternateBase, QtGui.QColor(233, 233, 233))
    light.setColor(QtGui.QPalette.ToolTipBase, QtGui.QColor(255, 255, 255))
    light.setColor(QtGui.QPalette.ToolTipText, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Text, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Button, QtGui.QColor(240, 240, 240))
    light.setColor(QtGui.QPalette.ButtonText, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Link, QtGui.QColor(0, 0, 255))
    light.setColor(QtGui.QPalette.Highlight, QtGui.QColor(42, 130, 218))
    light.setColor(QtGui.QPalette.HighlightedText, QtGui.QColor(255, 255, 255))
    
    # Disabled colors
    light.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.Text, QtGui.QColor(120, 120, 120))
    light.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, QtGui.QColor(120, 120, 120))
    light.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, QtGui.QColor(120, 120, 120))
    
    app.setPalette(light)

def create_checkmark_pixmap(size=16, color="#0078D4"):
    """Create a checkmark pixmap programmatically."""
    pixmap = QtGui.QPixmap(size, size)
    pixmap.fill(QtCore.Qt.transparent)
    
    painter = QtGui.QPainter(pixmap)
    painter.setRenderHint(QtGui.QPainter.Antialiasing)
    
    pen = QtGui.QPen(QtGui.QColor(color))
    pen.setWidth(2)
    pen.setCapStyle(QtCore.Qt.RoundCap)
    pen.setJoinStyle(QtCore.Qt.RoundJoin)
    painter.setPen(pen)
    
    # Draw checkmark
    painter.drawLine(4, 8, 7, 11)
    painter.drawLine(7, 11, 12, 4)
    
    painter.end()
    return pixmap

def create_x_mark_pixmap(size=16, color="#0078D4"):
    """Create an X mark pixmap programmatically (alternative to checkmark)."""
    pixmap = QtGui.QPixmap(size, size)
    pixmap.fill(QtCore.Qt.transparent)
    
    painter = QtGui.QPainter(pixmap)
    painter.setRenderHint(QtGui.QPainter.Antialiasing)
    
    pen = QtGui.QPen(QtGui.QColor(color))
    pen.setWidth(2)
    pen.setCapStyle(QtCore.Qt.RoundCap)
    painter.setPen(pen)
    
    # Draw X mark
    margin = 3
    painter.drawLine(margin, margin, size-margin, size-margin)
    painter.drawLine(margin, size-margin, size-margin, margin)
    
    painter.end()
    return pixmap

def _checkbox_style_with_images(dark: bool) -> str:
    """Use SVG-based checkboxes - same as _checkbox_style but with descriptive name."""
    return _checkbox_style(dark)



def _checkbox_style(dark: bool) -> str:
    """Return checkbox styling using packaged image files."""
    
    # Use appropriate images for theme
    if dark:
        unchecked_filename = "checkbox_unchecked_dark.png"
        checked_filename = "checkbox_checked_dark.png"
    else:
        unchecked_filename = "checkbox_unchecked.png"
        checked_filename = "checkbox_checked.png"
    
    # --- THIS IS THE NEW, PACKAGE-SAFE WAY TO FIND FILES ---
    try:
        # 'aicodeprep_gui.images' corresponds to the aicodeprep_gui/images folder
        with resources.as_file(resources.files('aicodeprep_gui.images').joinpath(unchecked_filename)) as p:
            unchecked_path = str(p)
        with resources.as_file(resources.files('aicodeprep_gui.images').joinpath(checked_filename)) as p:
            checked_path = str(p)
    except Exception as e:
        # Fallback or error logging if resources can't be found
        logging.error(f"Could not load checkbox images: {e}")
        return "" # Return empty style if images fail to load
    # --- END OF THE NEW SECTION ---

    # The rest of the function is the same as before
    # Convert Windows paths to proper URLs for Qt
    if os.name == 'nt':  # Windows
        unchecked_url = unchecked_path.replace('\\', '/')
        checked_url = checked_path.replace('\\', '/')
    else:
        unchecked_url = unchecked_path
        checked_url = checked_path
    
    hover_border_color = "#00c3ff"
    
    return f"""
    QTreeView::indicator, QTreeWidget::indicator {{
        width: 16px;
        height: 16px;
        border: none;
        background: transparent;
        image: url({unchecked_url});
    }}
    
    QTreeView::indicator:checked, QTreeWidget::indicator:checked {{
        image: url({checked_url});
    }}
    
    QTreeView::indicator:hover, QTreeWidget::indicator:hover {{
        border: 1px solid {hover_border_color};
        border-radius: 2px;
    }}
    
    QTreeView::indicator:checked:hover, QTreeWidget::indicator:checked:hover {{
        border: 1px solid {hover_border_color};
        border-radius: 2px;
        image: url({checked_url});
    }}
    """

def get_checkbox_style_dark()  -> str: 
    return _checkbox_style(True)

def get_checkbox_style_light() -> str: 
    return _checkbox_style(False)

</code>

aicodeprep_gui\file_processor.py:
<code>
import os
import sys
import logging
from typing import List, Literal

OutputFmt = Literal['xml', 'markdown']

def _write_one_file_xml(outfile, rel_path, abs_path, skip_binfiles=None):
    if is_binary_file(abs_path):
        if skip_binfiles is not None:
            skip_binfiles.append(rel_path)
        return
    outfile.write(f"{rel_path}:\n<code>\n")
    try:
        with open(abs_path, "r", encoding="utf-8", errors="ignore") as infile:
            outfile.write(infile.read())
    except Exception:
        outfile.write(".. contents skipped (read error) ..")
    outfile.write("\n</code>\n\n")

from aicodeprep_gui.smart_logic import is_binary_file

def _write_one_file_md(outfile, rel_path, abs_path, skip_binfiles=None):
    if is_binary_file(abs_path):
        if skip_binfiles is not None:
            skip_binfiles.append(rel_path)
        return
    outfile.write(f"### START OF FILE {rel_path} ###\n")
    try:
        with open(abs_path, "r", encoding="utf-8", errors="ignore") as infile:
            outfile.write(infile.read())
    except Exception:
        outfile.write(".. contents skipped (read error) ..\n")
    outfile.write(f"\n### END OF FILE {rel_path} ###\n\n")

def process_files(
    selected_files: List[str],
    output_file: str,
    fmt: OutputFmt = 'xml',
    prompt: str = "",
    prompt_to_top: bool = False,
    prompt_to_bottom: bool = True
) -> int:
    """
    Process selected files and write their contents to output_file.
    Optionally prepend and/or append a prompt/question.
    Returns the number of files processed.
    """
    try:
        output_path = os.path.join(os.getcwd(), output_file)
        logging.info(f"Writing output to: {output_path}")

        skip_binfiles = []
        writer = _write_one_file_xml if fmt == 'xml' else _write_one_file_md

        with open(output_path, 'w', encoding='utf-8') as outfile:
            # Write prompt at the top if requested
            if prompt and prompt_to_top:
                outfile.write(prompt.strip() + "\n\n")

            for file_path in selected_files:
                try:
                    try:
                        rel_path = os.path.relpath(file_path, os.getcwd())
                    except ValueError:
                        rel_path = file_path
                    writer(outfile, rel_path, file_path, skip_binfiles=skip_binfiles)
                    logging.info(f"Processed: {rel_path}")
                except Exception as exc:
                    logging.error(f"Error processing {file_path}: {exc}")

            if skip_binfiles:
                outfile.write("\n")
                for rel_path in skip_binfiles:
                    outfile.write(f"{rel_path} binary file skipped..\n")

            # Write prompt at the bottom if requested
            if prompt and prompt_to_bottom:
                outfile.write("\n\n" + prompt.strip())

        return len(selected_files)
    except Exception as exc:
        logging.error(f"Error writing output file: {exc}")
        return 0

</code>

aicodeprep_gui\gui.py:
<code>
import os
import sys
import platform
import logging
import uuid
from PySide6 import QtWidgets, QtCore, QtGui, QtNetwork
from importlib import resources
from aicodeprep_gui.apptheme import system_pref_is_dark, apply_dark_palette, apply_light_palette, get_checkbox_style_dark, get_checkbox_style_light
from typing import List, Tuple
from aicodeprep_gui import smart_logic
from aicodeprep_gui.file_processor import process_files
from aicodeprep_gui import __version__

class FlowLayout(QtWidgets.QLayout):
    def __init__(self, parent=None, margin=-1, hspacing=-1, vspacing=-1):
        super(FlowLayout, self).__init__(parent)
        self._items = []
        self.setContentsMargins(margin, margin, margin, margin)
        self._hspacing = hspacing
        self._vspacing = vspacing

    def __del__(self):
        del self._items[:]

    def addItem(self, item):
        self._items.append(item)
        self.invalidate()

    def horizontalSpacing(self):
        if self._hspacing >= 0:
            return self._hspacing
        return self.smartSpacing(QtWidgets.QStyle.PM_LayoutHorizontalSpacing)

    def verticalSpacing(self):
        if self._vspacing >= 0:
            return self._vspacing
        return self.smartSpacing(QtWidgets.QStyle.PM_LayoutVerticalSpacing)

    def count(self):
        return len(self._items)

    def itemAt(self, index):
        if 0 <= index < len(self._items):
            return self._items[index]
        return None

    def takeAt(self, index):
        if 0 <= index < len(self._items):
            item = self._items.pop(index)
            self.invalidate()
            return item
        return None
        
    def insertWidget(self, index, widget):
        self.insertItem(index, QtWidgets.QWidgetItem(widget))

    def insertItem(self, index, item):
        self._items.insert(index, item)
        self.invalidate()

    def removeWidget(self, widget):
        for i, item in enumerate(self._items):
            if item.widget() is widget:
                self.takeAt(i)
                # Do not delete the widget, the caller is responsible
                break
    
    def expandingDirections(self):
        return QtCore.Qt.Orientation(0)

    def hasHeightForWidth(self):
        return True

    def heightForWidth(self, width):
        return self.doLayout(QtCore.QRect(0, 0, width, 0), True)

    def setGeometry(self, rect):
        super(FlowLayout, self).setGeometry(rect)
        self.doLayout(rect, False)

    def sizeHint(self):
        return self.minimumSize()

    def minimumSize(self):
        size = QtCore.QSize()
        for item in self._items:
            size = size.expandedTo(item.minimumSize())
        margins = self.contentsMargins()
        size += QtCore.QSize(margins.left() + margins.right(), margins.top() + margins.bottom())
        return size

    def doLayout(self, rect, testOnly):
        m = self.contentsMargins()
        x = rect.x() + m.left()
        y = rect.y() + m.top()
        lineHeight = 0

        spaceX = self.horizontalSpacing()
        spaceY = self.verticalSpacing()

        for item in self._items:
            nextX = x + item.sizeHint().width() + spaceX
            if nextX - spaceX > rect.right() - m.right() and lineHeight > 0:
                x = rect.x() + m.left()
                y = y + lineHeight + spaceY
                lineHeight = 0
            
            if not testOnly:
                item.setGeometry(QtCore.QRect(QtCore.QPoint(x, y), item.sizeHint()))

            x = x + item.sizeHint().width() + spaceX
            lineHeight = max(lineHeight, item.sizeHint().height())

        return y + lineHeight + m.bottom()

    def smartSpacing(self, pm):
        parent = self.parent()
        if not parent:
            return -1
        if parent.isWidgetType():
            return parent.style().pixelMetric(pm, None, parent)
        else:
            return parent.spacing()

# Version for .aicodeprep-gui file format
AICODEPREP_GUI_VERSION = "1.0"

class GlobalPresetManager:
    def __init__(self):
        try:
            self.settings = QtCore.QSettings("aicodeprep-gui", "ButtonPresets")
            self._ensure_default_presets()
        except Exception as e:
            logging.error(f"Failed to initialize global preset manager: {e}")
            self.settings = None
    
    def _ensure_default_presets(self):
        """Create default presets if they don't exist"""
        try:
            if not self.settings:
                return
                
            self.settings.beginGroup("presets")
            existing_keys = self.settings.childKeys()
            self.settings.endGroup()
            
            if not existing_keys:
                default_presets = [
                    ("Debug", "Can you help me debug this code?"),
                    ("Security check", "Can you analyze this code for any security issues?"),
                    ("Best Practices", "Please analyze this code for: Error handling, Edge cases, Performance optimization, Best practices, Please do not unnecessarily remove any comments or code. Generate the code with clear comments explaining the logic."),
                    ("Please review for", "Code quality and adherence to best practices, Potential bugs or edge cases, Performance optimizations, Readability and maintainability, Security concerns. Suggest improvements and explain your reasoning for each suggestion"),
                    ("Cline, Roo Code Prompt", "Write a prompt for Cline, an AI coding agent, to make the necessary changes. Enclose the entire Cline prompt in one single code tag for easy copy and paste.")
                ]
                
                self.settings.beginGroup("presets")
                for label, text in default_presets:
                    self.settings.setValue(label, text)
                self.settings.endGroup()
                logging.info("Created default button presets")
        except Exception as e:
            logging.error(f"Failed to create default presets: {e}")
    
    def get_all_presets(self):
        """Get all saved presets as list of (label, text) tuples"""
        try:
            if not self.settings: return []
            presets = []
            self.settings.beginGroup("presets")
            for key in self.settings.childKeys():
                presets.append((key, self.settings.value(key, "")))
            self.settings.endGroup()
            return presets
        except Exception as e:
            logging.error(f"Failed to get presets: {e}")
            return []
    
    def add_preset(self, label, text):
        try:
            if not self.settings or not label.strip() or not text.strip(): return False
            self.settings.beginGroup("presets")
            self.settings.setValue(label.strip(), text.strip())
            self.settings.endGroup()
            return True
        except Exception as e:
            logging.error(f"Failed to add preset '{label}': {e}")
            return False
    
    def delete_preset(self, label):
        try:
            if not self.settings or not label.strip(): return False
            self.settings.beginGroup("presets")
            self.settings.remove(label.strip())
            self.settings.endGroup()
            return True
        except Exception as e:
            logging.error(f"Failed to delete preset '{label}': {e}")
            return False

global_preset_manager = GlobalPresetManager()

class FileSelectionGUI(QtWidgets.QMainWindow):
    def open_settings_folder(self):
        """Open the folder containing the .aicodeprep-gui settings file in the system file explorer."""
        folder_path = os.getcwd()
        if sys.platform.startswith("win"):
            os.startfile(folder_path)
        elif sys.platform.startswith("darwin"):
            import subprocess
            subprocess.Popen(["open", folder_path])
        else:
            import subprocess
            subprocess.Popen(["xdg-open", folder_path])

    def __init__(self, files):
        super().__init__()
        # Set application icon
        try:
            with resources.path('aicodeprep_gui.images', 'favicon.ico') as icon_path:
                app_icon = QtGui.QIcon(str(icon_path))
            self.setWindowIcon(app_icon)
            # Add system tray icon with context menu
            from PySide6.QtWidgets import QSystemTrayIcon, QMenu
            from PySide6.QtGui import QAction
            tray = QSystemTrayIcon(app_icon, parent=self)
            # build a minimal context menu
            menu = QMenu()
            show_act = QAction("Show", self)
            quit_act = QAction("Quit", self)
            show_act.triggered.connect(self.show)
            quit_act.triggered.connect(self.quit_without_processing)
            menu.addAction(show_act)
            menu.addSeparator()
            menu.addAction(quit_act)
            tray.setContextMenu(menu)
            tray.show()
            self.tray_icon = tray  # keep a reference so it doesn't get garbage‐collected
        except FileNotFoundError:
            logging.warning("Application icon 'favicon.ico' not found in package resources.")

        self.presets = [] # This local 'presets' list is not used for global presets, but for local ones (which are not saved to the .aicodeprep-gui file, but managed by global_preset_manager through QSettings)
        self.setAcceptDrops(True)
        self.files = files

        # Get or create anonymous user UUID
        settings = QtCore.QSettings("aicodeprep-gui", "UserIdentity")
        user_uuid = settings.value("user_uuid")
        if not user_uuid:
            import uuid
            user_uuid = str(uuid.uuid4())
            settings.setValue("user_uuid", user_uuid)
            logging.info(f"Generated new anonymous user UUID: {user_uuid}")

        from datetime import datetime
        self.network_manager = QtNetwork.QNetworkAccessManager(self)
        now = datetime.now()
        time_str = f"{now.strftime('%I').lstrip('0') or '12'}{now.strftime('%M')}{now.strftime('%p').lower()}"
        request = QtNetwork.QNetworkRequest(QtCore.QUrl(f"https://wuu73.org/dixels/newaicp.html?t={time_str}&user={user_uuid}"))
        self.network_manager.get(request)

        self.setWindowTitle("aicodeprep-gui - File Selection")
        self.app = QtWidgets.QApplication.instance()
        if self.app is None:
            self.app = QtWidgets.QApplication([])
        self.action = 'quit'

        self.prefs_filename = ".aicodeprep-gui"
        self.remember_checkbox = None 
        self.checked_files_from_prefs = set()
        self.prefs_loaded = False
        self.window_size_from_prefs = None
        self.splitter_state_from_prefs = None # Initialize this attribute
        self.load_prefs_if_exists()

        if platform.system() == 'Windows':
            scale_factor = self.app.primaryScreen().logicalDotsPerInch() / 96.0
        else:
            scale_factor = self.app.primaryScreen().devicePixelRatio()

        default_font_size = 9
        font_stack = '"Segoe UI", "Ubuntu", "Helvetica Neue", Arial, sans-serif'
        default_font_size = int(default_font_size * scale_factor)
        self.default_font = QtGui.QFont("Segoe UI", default_font_size)
        self.setFont(self.default_font)
        self.setStyleSheet(f"font-family: {font_stack};")
        style = self.style()
        self.folder_icon = style.standardIcon(QtWidgets.QStyle.SP_DirIcon)
        self.file_icon = style.standardIcon(QtWidgets.QStyle.SP_FileIcon)

        if self.window_size_from_prefs:
            w, h = self.window_size_from_prefs
            self.setGeometry(100, 100, w, h)
        else:
            self.setGeometry(100, 100, int(600 * scale_factor), int(400 * scale_factor))

        self.is_dark_mode = system_pref_is_dark()
        if self.is_dark_mode: apply_dark_palette(self.app)

        central = QtWidgets.QWidget()
        self.setCentralWidget(central)
        main_layout = QtWidgets.QVBoxLayout(central)
        main_layout.setContentsMargins(20, 10, 20, 10)

        mb = self.menuBar()
        file_menu = mb.addMenu("&File")

        # Add this new block for the Windows-only menu item
        if platform.system() == "Windows":
            from aicodeprep_gui import windows_registry
            class RegistryManagerDialog(QtWidgets.QDialog):
                def __init__(self, parent=None):
                    super().__init__(parent)
                    self.setWindowTitle("Windows Context Menu Manager")
                    self.setMinimumWidth(450)
                    
                    self.layout = QtWidgets.QVBoxLayout(self)
                    
                    info_text = (
                        "This tool can add or remove a right-click context menu item in "
                        "Windows Explorer to open `aicodeprep-gui` in any folder.<br><br>"
                        "<b>Note:</b> This operation requires administrator privileges. "
                        "A UAC prompt will appear."
                    )
                    self.info_label = QtWidgets.QLabel(info_text)
                    self.info_label.setWordWrap(True)
                    self.layout.addWidget(self.info_label)

                    # Add custom menu text input
                    menu_text_label = QtWidgets.QLabel("Custom menu text:")
                    self.layout.addWidget(menu_text_label)
                    
                    self.menu_text_input = QtWidgets.QLineEdit()
                    self.menu_text_input.setPlaceholderText("Open with aicodeprep-gui")
                    self.menu_text_input.setText("Open with aicodeprep-gui")
                    self.menu_text_input.setToolTip("Enter the text that will appear in the right-click context menu")
                    self.layout.addWidget(self.menu_text_input)
                    
                    # Add some spacing
                    self.layout.addSpacing(10)

                    self.status_label = QtWidgets.QLabel("Ready.")
                    self.status_label.setStyleSheet("font-style: italic;")
                    
                    self.install_button = QtWidgets.QPushButton("Install Right-Click Menu")
                    self.install_button.clicked.connect(self.run_install)
                    
                    self.uninstall_button = QtWidgets.QPushButton("Uninstall Right-Click Menu")
                    self.uninstall_button.clicked.connect(self.run_uninstall)

                    button_layout = QtWidgets.QHBoxLayout()
                    button_layout.addWidget(self.install_button)
                    button_layout.addWidget(self.uninstall_button)
                    
                    self.layout.addLayout(button_layout)
                    self.layout.addWidget(self.status_label)

                def _run_action(self, action_name):
                    if windows_registry.is_admin():
                        # Already running as admin, just do the action
                        if action_name == 'install':
                            custom_text = self.menu_text_input.text().strip()
                            success, message = windows_registry.install_context_menu(custom_text if custom_text else None)
                        else:
                            success, message = windows_registry.remove_context_menu()
                        
                        self.status_label.setText(message)
                        if success:
                            QtWidgets.QMessageBox.information(self, "Success", message)
                        else:
                            QtWidgets.QMessageBox.warning(self, "Error", message)
                    else:
                        # Not admin, need to elevate
                        if action_name == 'install':
                            custom_text = self.menu_text_input.text().strip()
                            success, message = windows_registry.run_as_admin(action_name, custom_text if custom_text else None)
                        else:
                            success, message = windows_registry.run_as_admin(action_name)
                        self.status_label.setText(message)
                        if success:
                            # Close the main app window as a new elevated process will take over
                            self.parent().close()
                
                def run_install(self):
                    self._run_action('install')

                def run_uninstall(self):
                    self._run_action('remove')

            def open_registry_manager(self):
                dialog = RegistryManagerDialog(self)
                dialog.exec()

            install_menu_act = QtGui.QAction("Install Right-Click Menu...", self)
            install_menu_act.triggered.connect(lambda: open_registry_manager(self))
            file_menu.addAction(install_menu_act)
            file_menu.addSeparator() # Optional, for visual separation

        # Add macOS-only menu item
        if platform.system() == "Darwin":
            from aicodeprep_gui import macos_installer

            class MacInstallerDialog(QtWidgets.QDialog):
                def __init__(self, parent=None):
                    super().__init__(parent)
                    self.setWindowTitle("macOS Quick Action Manager")
                    self.setMinimumWidth(450)
                    self.layout = QtWidgets.QVBoxLayout(self)

                    info_text = (
                        "This tool installs or removes a <b>Quick Action</b> to open `aicodeprep-gui` "
                        "from the right-click menu in Finder (under Quick Actions or Services).<br><br>"
                        "The action is installed in your user's Library folder, so no administrator "
                        "privileges are required."
                    )
                    self.info_label = QtWidgets.QLabel(info_text)
                    self.info_label.setWordWrap(True)
                    self.layout.addWidget(self.info_label)
                    self.layout.addSpacing(10)

                    self.install_button = QtWidgets.QPushButton("Install Quick Action")
                    self.install_button.clicked.connect(self.run_install)
                    
                    self.uninstall_button = QtWidgets.QPushButton("Uninstall Quick Action")
                    self.uninstall_button.clicked.connect(self.run_uninstall)

                    button_layout = QtWidgets.QHBoxLayout()
                    button_layout.addWidget(self.install_button)
                    button_layout.addWidget(self.uninstall_button)
                    self.layout.addLayout(button_layout)

                def run_install(self):
                    success, message = macos_installer.install_quick_action()
                    if success:
                        QtWidgets.QMessageBox.information(self, "Success", message)
                    else:
                        QtWidgets.QMessageBox.warning(self, "Error", message)

                def run_uninstall(self):
                    success, message = macos_installer.uninstall_quick_action()
                    if success:
                        QtWidgets.QMessageBox.information(self, "Success", message)
                    else:
                        QtWidgets.QMessageBox.warning(self, "Error", message)

            def open_mac_installer(self):
                dialog = MacInstallerDialog(self)
                dialog.exec()

            install_menu_act = QtGui.QAction("Install Finder Quick Action...", self)
            install_menu_act.triggered.connect(lambda: open_mac_installer(self))
            file_menu.addAction(install_menu_act)
            file_menu.addSeparator()

        # Add Linux-only menu item
        if platform.system() == "Linux":
            from aicodeprep_gui import linux_installer

            class LinuxInstallerDialog(QtWidgets.QDialog):
                def __init__(self, parent=None):
                    super().__init__(parent)
                    self.setWindowTitle("Linux File Manager Integration")
                    self.setMinimumWidth(500)
                    self.layout = QtWidgets.QVBoxLayout(self)

                    self.tabs = QtWidgets.QTabWidget()
                    
                    # Automated Installer Tab
                    automated_tab = QtWidgets.QWidget()
                    automated_layout = QtWidgets.QVBoxLayout(automated_tab)
                    self.tabs.addTab(automated_tab, "Automated Setup")

                    info_text = QtWidgets.QLabel(
                        "This tool can attempt to install a context menu script for your file manager."
                    )
                    info_text.setWordWrap(True)
                    automated_layout.addWidget(info_text)
                    automated_layout.addSpacing(10)

                    self.nautilus_group = QtWidgets.QGroupBox("Nautilus (GNOME, Cinnamon, etc.)")
                    nautilus_layout = QtWidgets.QVBoxLayout(self.nautilus_group)
                    
                    self.install_nautilus_btn = QtWidgets.QPushButton("Install Nautilus Script")
                    self.install_nautilus_btn.clicked.connect(self.run_install_nautilus)
                    self.uninstall_nautilus_btn = QtWidgets.QPushButton("Uninstall Nautilus Script")
                    self.uninstall_nautilus_btn.clicked.connect(self.run_uninstall_nautilus)
                    
                    nautilus_layout.addWidget(self.install_nautilus_btn)
                    nautilus_layout.addWidget(self.uninstall_nautilus_btn)
                    
                    automated_layout.addWidget(self.nautilus_group)
                    automated_layout.addStretch()

                    # Disable if Nautilus is not detected
                    if not linux_installer.is_nautilus_installed():
                        self.nautilus_group.setDisabled(True)
                        self.nautilus_group.setToolTip("Nautilus file manager not detected in your system's PATH.")

                    # Manual Instructions Tab
                    manual_tab = QtWidgets.QWidget()
                    manual_layout = QtWidgets.QVBoxLayout(manual_tab)
                    self.tabs.addTab(manual_tab, "Manual Instructions")
                    
                    manual_text = QtWidgets.QLabel(
                        "If your file manager is not listed above, you can likely add a custom action manually. "
                        "Create a new executable script with the content below and add it to your file manager's "
                        "scripting or custom actions feature. The selected folder path will be passed as the first argument ($1)."
                    )
                    manual_text.setWordWrap(True)
                    manual_layout.addWidget(manual_text)

                    script_box = QtWidgets.QPlainTextEdit()
                    script_box.setPlainText(linux_installer.NAUTILUS_SCRIPT_CONTENT)
                    script_box.setReadOnly(True)
                    script_box.setFont(QtGui.QFont("Monospace"))
                    manual_layout.addWidget(script_box)
                    
                    self.layout.addWidget(self.tabs)

                def run_install_nautilus(self):
                    success, message = linux_installer.install_nautilus_script()
                    if success:
                        QtWidgets.QMessageBox.information(self, "Success", message)
                    else:
                        QtWidgets.QMessageBox.warning(self, "Error", message)

                def run_uninstall_nautilus(self):
                    success, message = linux_installer.uninstall_nautilus_script()
                    if success:
                        QtWidgets.QMessageBox.information(self, "Success", message)
                    else:
                        QtWidgets.QMessageBox.warning(self, "Error", message)

            def open_linux_installer(self):
                dialog = LinuxInstallerDialog(self)
                dialog.exec()

            install_menu_act = QtGui.QAction("Install File Manager Action...", self)
            install_menu_act.triggered.connect(lambda: open_linux_installer(self))
            file_menu.addAction(install_menu_act)
            file_menu.addSeparator()

        quit_act = QtGui.QAction("&Quit", self); quit_act.triggered.connect(self.quit_without_processing); file_menu.addAction(quit_act)
        edit_menu = mb.addMenu("&Edit")
        new_preset_act = QtGui.QAction("&New Preset…", self); new_preset_act.triggered.connect(self.add_new_preset_dialog); edit_menu.addAction(new_preset_act)
        open_settings_folder_act = QtGui.QAction("Open Settings Folder…", self)
        open_settings_folder_act.triggered.connect(self.open_settings_folder)
        edit_menu.addAction(open_settings_folder_act)

        self.format_combo = QtWidgets.QComboBox()
        self.format_combo.addItems(["XML <code>", "Markdown ###"])
        self.format_combo.setFixedWidth(130)
        self.format_combo.setItemData(0, 'xml')
        self.format_combo.setItemData(1, 'markdown')
        output_label = QtWidgets.QLabel("&Output format:")
        output_label.setBuddy(self.format_combo)
        self.dark_mode_box = QtWidgets.QCheckBox("Dark mode")
        self.dark_mode_box.setChecked(self.is_dark_mode)
        self.dark_mode_box.stateChanged.connect(self.toggle_dark_mode)
        self.token_label = QtWidgets.QLabel("Estimated tokens: 0")
        main_layout.addWidget(self.token_label)
        main_layout.addSpacing(8)

        self.vibe_label = QtWidgets.QLabel("AI Code Prep GUI")
        vibe_font = QtGui.QFont(self.default_font)
        vibe_font.setBold(True)
        vibe_font.setPointSize(self.default_font.pointSize() + 8)
        self.vibe_label.setFont(vibe_font)
        self.vibe_label.setAlignment(QtCore.Qt.AlignHCenter | QtCore.Qt.AlignVCenter)
        self.vibe_label.setStyleSheet(
            "background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #40203f, stop:1 #1f103f); "
            "color: white; padding: 0px 0px 0px 0px; border-radius: 8px;"
        )
        self.vibe_label.setFixedHeight(44)
        banner_wrap = QtWidgets.QWidget()
        banner_layout = QtWidgets.QHBoxLayout(banner_wrap)
        banner_layout.setContentsMargins(14, 0, 14, 0)
        banner_layout.addWidget(self.vibe_label)
        main_layout.addWidget(banner_wrap)
        main_layout.addSpacing(8)
        self.info_label = QtWidgets.QLabel("likely code files are already checked, adjust as needed")
        self.info_label.setAlignment(QtCore.Qt.AlignHCenter)
        main_layout.addWidget(self.info_label)

        self.text_label = QtWidgets.QLabel("")
        self.text_label.setWordWrap(True)
        main_layout.addWidget(self.text_label)

        # Add "Prompt Preset Buttons:" label above presets section
        prompt_header_label = QtWidgets.QLabel("Prompt Preset Buttons:")
        main_layout.addWidget(prompt_header_label)
        
        # Create scrollable preset area
        presets_wrapper = QtWidgets.QHBoxLayout()
        
        # Scrollable area for preset buttons
        scroll_area = QtWidgets.QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll_area.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        scroll_area.setFixedHeight(52)  # Enough height for 22px buttons + padding
        
        scroll_widget = QtWidgets.QWidget()
        self.preset_strip = QtWidgets.QHBoxLayout(scroll_widget)
        self.preset_strip.setContentsMargins(0, 0, 0, 0)
        
        add_preset_btn = QtWidgets.QPushButton("✚")
        add_preset_btn.setFixedSize(24, 24)
        add_preset_btn.setToolTip("New Preset…")
        add_preset_btn.clicked.connect(self.add_new_preset_dialog)
        self.preset_strip.addWidget(add_preset_btn)

        delete_preset_btn = QtWidgets.QPushButton("🗑️")
        delete_preset_btn.setFixedSize(24, 24)
        delete_preset_btn.setToolTip("Delete a preset…")
        delete_preset_btn.clicked.connect(self.delete_preset_dialog)
        self.preset_strip.addWidget(delete_preset_btn)
        
        self.preset_strip.addStretch()
        
        scroll_area.setWidget(scroll_widget)
        presets_wrapper.addWidget(scroll_area)
        
        main_layout.addLayout(presets_wrapper)
        
        # Add explanation text below presets
        preset_explanation = QtWidgets.QLabel("Presets help you save more time and will be saved for later use")
        preset_explanation.setObjectName("preset_explanation")
        preset_explanation.setStyleSheet(
            f"font-size: 10px; color: {'#bbbbbb' if self.is_dark_mode else '#444444'};"
        )
        main_layout.addWidget(preset_explanation)
        
        main_layout.addSpacing(8)

        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)
        self.tree_widget = QtWidgets.QTreeWidget()
        self.tree_widget.setHeaderLabels(["File/Folder"])
        self.tree_widget.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        # Apply initial checkbox styling along with other styles
        base_style = """
            QTreeView, QTreeWidget {
                outline: 2; /* Remove focus rectangle */
            }
        """
        checkbox_style = get_checkbox_style_dark() if self.is_dark_mode else get_checkbox_style_light()
        self.tree_widget.setStyleSheet(base_style + checkbox_style)
        
        self.splitter.addWidget(self.tree_widget)
        prompt_widget = QtWidgets.QWidget(); prompt_layout = QtWidgets.QVBoxLayout(prompt_widget); prompt_layout.setContentsMargins(0,0,0,0)
        prompt_layout.addWidget(QtWidgets.QLabel("Optional prompt/question for LLM (will be appended to the end):")); prompt_layout.addSpacing(8)
        self.prompt_textbox = QtWidgets.QPlainTextEdit()
        self.prompt_textbox.setPlaceholderText("Type your question or prompt here (optional)…")
        prompt_layout.addWidget(self.prompt_textbox)

        # Add Clear button below the prompt box
        self.clear_prompt_btn = QtWidgets.QPushButton("Clear")
        self.clear_prompt_btn.setToolTip("Clear the prompt box")
        self.clear_prompt_btn.clicked.connect(self.prompt_textbox.clear)
        prompt_layout.addWidget(self.clear_prompt_btn)
        self.splitter.addWidget(prompt_widget)
        self.splitter.setStretchFactor(0, 4); self.splitter.setStretchFactor(1, 1)
        main_layout.addWidget(self.splitter)

        # Apply saved splitter state if available
        if self.splitter_state_from_prefs: 
            try:
                self.splitter.restoreState(self.splitter_state_from_prefs)
                logging.info("Restored splitter state from preferences")
            except Exception as e:
                logging.warning(f"Failed to restore splitter state: {e}")

        # --- NEW TREE BUILDING LOGIC ---
        self.path_to_item = {}  # Maps relative_path to QTreeWidgetItem
        root_node = self.tree_widget.invisibleRootItem()
        for abs_path, rel_path, is_checked in files:
            parts = rel_path.split(os.sep)
            parent_node = root_node
            path_so_far = ""
            for part in parts[:-1]:
                path_so_far = os.path.join(path_so_far, part) if path_so_far else part
                if path_so_far in self.path_to_item:
                    parent_node = self.path_to_item[path_so_far]
                else:
                    # This case implies a directory was not in the `files` list, create it
                    new_parent = QtWidgets.QTreeWidgetItem(parent_node, [part])
                    new_parent.setIcon(0, self.folder_icon)
                    new_parent.setFlags(new_parent.flags() | QtCore.Qt.ItemIsUserCheckable)
                    new_parent.setCheckState(0, QtCore.Qt.Unchecked)
                    self.path_to_item[path_so_far] = new_parent
                    parent_node = new_parent

            # Create the final item
            item_text = parts[-1]
            item = QtWidgets.QTreeWidgetItem(parent_node, [item_text])
            item.setData(0, QtCore.Qt.UserRole, abs_path) # Store absolute path
            self.path_to_item[rel_path] = item

            if self.prefs_loaded:
                is_checked = rel_path in self.checked_files_from_prefs
            
            if os.path.isdir(abs_path):
                item.setIcon(0, self.folder_icon)
                item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
                # For directories, default to unchecked during initial population.
                # Their checked state will reflect children or be set explicitly by load_prefs_if_exists
                item.setCheckState(0, QtCore.Qt.Unchecked) 
            else: # It's a file
                item.setIcon(0, self.file_icon)
                item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
                # Don't block binary files, just leave them unchecked by default
                if smart_logic.is_binary_file(abs_path):
                    is_checked = False
            
            item.setCheckState(0, QtCore.Qt.Checked if is_checked else QtCore.Qt.Unchecked)

        # Connect signals for lazy loading and item changes
        self.tree_widget.itemExpanded.connect(self.on_item_expanded)
        self.tree_widget.itemChanged.connect(self.handle_item_changed)
        
        # Auto-expand folders containing checked files
        if self.prefs_loaded and self.checked_files_from_prefs:
            self._expand_folders_for_paths(self.checked_files_from_prefs)
        else:
            # On first load (no prefs), expand based on smart-selected files
            initial_checked_paths = {rel_path for _, rel_path, is_checked in files if is_checked}
            self._expand_folders_for_paths(initial_checked_paths)
        
        # --- Remember checked files checkbox with tooltip and ? icon ---
        self.remember_checkbox = QtWidgets.QCheckBox("Remember checked files for this folder, window size information")
        self.remember_checkbox.setChecked(True)
        self.remember_checkbox.setToolTip("Saves which files are included in the context for this folder, so you don't have to keep doing it over and over")
        remember_help = QtWidgets.QLabel("<b style='color:#0078D4; font-size:14px; cursor:help;'>?</b>")
        remember_help.setToolTip("Saves which files are included in the context for this folder, so you don't have to keep doing it over and over")
        remember_help.setAlignment(QtCore.Qt.AlignVCenter)
        remember_layout = QtWidgets.QHBoxLayout()
        remember_layout.setContentsMargins(0,0,0,0)
        remember_layout.addWidget(self.remember_checkbox)
        remember_layout.addWidget(remember_help)
        remember_layout.addStretch()

        # --- Prompt/question to top checkbox with tooltip and ? icon ---
        self.prompt_top_checkbox = QtWidgets.QCheckBox("Add prompt/question to top")
        self.prompt_top_checkbox.setToolTip("Research shows that asking your question before AND after the code context, can improve quality and ability of the AI responses! Highly recommended to check both of these")
        prompt_top_help = QtWidgets.QLabel("<b style='color:#0078D4; font-size:14px; cursor:help;'>?</b>")
        prompt_top_help.setToolTip("Research shows that asking your question before AND after the code context, can improve quality and ability of the AI responses! Highly recommended to check both of these")
        prompt_top_help.setAlignment(QtCore.Qt.AlignVCenter)
        prompt_top_layout = QtWidgets.QHBoxLayout()
        prompt_top_layout.setContentsMargins(0,0,0,0)
        prompt_top_layout.addWidget(self.prompt_top_checkbox)
        prompt_top_layout.addWidget(prompt_top_help)
        prompt_top_layout.addStretch()

        # --- Prompt/question to bottom checkbox with tooltip and ? icon ---
        self.prompt_bottom_checkbox = QtWidgets.QCheckBox("Add prompt/question to bottom")
        self.prompt_bottom_checkbox.setToolTip("Research shows that asking your question before AND after the code context, can improve quality and ability of the AI responses! Highly recommended to check both of these")
        prompt_bottom_help = QtWidgets.QLabel("<b style='color:#0078D4; font-size:14px; cursor:help;'>?</b>")
        prompt_bottom_help.setToolTip("Research shows that asking your question before AND after the code context, can improve quality and ability of the AI responses! Highly recommended to check both of these")
        prompt_bottom_help.setAlignment(QtCore.Qt.AlignVCenter)
        prompt_bottom_layout = QtWidgets.QHBoxLayout()
        prompt_bottom_layout.setContentsMargins(0,0,0,0)
        prompt_bottom_layout.addWidget(self.prompt_bottom_checkbox)
        prompt_bottom_layout.addWidget(prompt_bottom_help)
        prompt_bottom_layout.addStretch()

        # Load global prompt option settings
        self._load_prompt_options()

        # Save settings when toggled
        self.prompt_top_checkbox.stateChanged.connect(self._save_prompt_options)
        self.prompt_bottom_checkbox.stateChanged.connect(self._save_prompt_options)

        # --- New Options & Settings Group ---
        options_group_box = QtWidgets.QGroupBox("Options & Settings")
        options_group_layout = QtWidgets.QVBoxLayout(options_group_box)

        # First row: Output format and Dark mode
        options_top_row = QtWidgets.QHBoxLayout()
        options_top_row.addWidget(output_label)
        options_top_row.addWidget(self.format_combo)
        options_top_row.addStretch()
        options_top_row.addWidget(self.dark_mode_box)
        options_group_layout.addLayout(options_top_row)

        # Add the three checkbox layouts
        options_group_layout.addLayout(remember_layout)
        options_group_layout.addLayout(prompt_top_layout)
        options_group_layout.addLayout(prompt_bottom_layout)

        main_layout.addWidget(options_group_box)
        
        button_layout1 = QtWidgets.QHBoxLayout(); button_layout2 = QtWidgets.QHBoxLayout()
        main_layout.addLayout(button_layout1); main_layout.addLayout(button_layout2)
        website_label = QtWidgets.QLabel("<a href=\"https://wuu73.org/aicp\">aicodeprep-gui @ wuu73.org</a>"); website_label.setOpenExternalLinks(True); main_layout.insertWidget(main_layout.count() - 2, website_label)
        button_layout1.addStretch()
        process_button = QtWidgets.QPushButton("Process Selected"); process_button.clicked.connect(self.process_selected); button_layout1.addWidget(process_button)
        select_all_button = QtWidgets.QPushButton("Select All"); select_all_button.clicked.connect(self.select_all); button_layout1.addWidget(select_all_button)
        deselect_all_button = QtWidgets.QPushButton("Deselect All"); deselect_all_button.clicked.connect(self.deselect_all); button_layout1.addWidget(deselect_all_button)
        button_layout2.addStretch()
        load_prefs_button = QtWidgets.QPushButton("Load preferences"); load_prefs_button.clicked.connect(self.load_from_prefs_button_clicked); button_layout2.addWidget(load_prefs_button)
        quit_button = QtWidgets.QPushButton("Quit"); quit_button.clicked.connect(self.quit_without_processing); button_layout2.addWidget(quit_button)

        self.selected_files = []
        self.file_token_counts = {}
        self.update_token_counter()
        self._load_global_presets()

    def on_item_expanded(self, item):
        """Handler for when a tree item is expanded, used for lazy loading."""
        dir_path = item.data(0, QtCore.Qt.UserRole)
        if not dir_path or not os.path.isdir(dir_path): 
            return
            
        # Check if children have already been loaded by verifying if first child is a real item.
        # If it has children and the first one has a UserRole data, it implies content has been loaded.
        if item.childCount() > 0 and item.child(0).data(0, QtCore.Qt.UserRole) is not None:
            return
            
        try:
            # Clear any existing children (e.g., a dummy placeholder item)
            item.takeChildren()
        
            for name in sorted(os.listdir(dir_path)):
                abs_path = os.path.join(dir_path, name)
                
                try:
                    rel_path = os.path.relpath(abs_path, os.getcwd())
                except ValueError: # Path is on a different drive on Windows
                    logging.warning(f"Skipping {abs_path}: not on current drive.")
                    continue
                
                # If an item for this relative path already exists in the dictionary, skip
                # This can happen if some subdirectories were part of the initial 'files' list
                if rel_path in self.path_to_item:
                    continue

                new_item = QtWidgets.QTreeWidgetItem(item, [name])
                new_item.setData(0, QtCore.Qt.UserRole, abs_path)
                new_item.setFlags(new_item.flags() | QtCore.Qt.ItemIsUserCheckable)
                self.path_to_item[rel_path] = new_item
                
                is_excluded = smart_logic.exclude_spec.match_file(rel_path) or smart_logic.exclude_spec.match_file(rel_path + '/')
                
                if os.path.isdir(abs_path):
                    new_item.setIcon(0, self.folder_icon)
                    # For newly loaded directories, inherit check state from parent if not excluded
                    if is_excluded:
                        new_item.setCheckState(0, QtCore.Qt.Unchecked)
                    else:
                        new_item.setCheckState(0, item.checkState(0)) # Inherit from parent
                else: # File
                    new_item.setIcon(0, self.file_icon)
                    # Treat binary files as implicitly excluded
                    if smart_logic.is_binary_file(abs_path):
                        is_excluded = True

                    # Set check state based on parent, unless it's excluded or was specifically unchecked in prefs
                    if is_excluded:
                        new_item.setCheckState(0, QtCore.Qt.Unchecked)
                    elif self.prefs_loaded and rel_path in self.checked_files_from_prefs:
                        new_item.setCheckState(0, QtCore.Qt.Checked)
                    else:
                        # Inherit from parent if not specifically in prefs and not excluded
                        new_item.setCheckState(0, item.checkState(0))

        except OSError as e:
            logging.error(f"Error scanning directory {dir_path}: {e}")

    def handle_item_changed(self, item, column):
        if column == 0:
            self.tree_widget.blockSignals(True)
            try:
                new_state = item.checkState(0)
                # Apply check state to children
                def apply_to_children(parent_item, state):
                    for i in range(parent_item.childCount()):
                        child = parent_item.child(i)
                        if child.flags() & QtCore.Qt.ItemIsUserCheckable and child.flags() & QtCore.Qt.ItemIsEnabled:
                            abs_path = child.data(0, QtCore.Qt.UserRole)
                            
                            # Prevent checking excluded binary files if state is QtCore.Qt.Checked
                            if state == QtCore.Qt.Checked and abs_path and os.path.isfile(abs_path) and smart_logic.is_binary_file(abs_path):
                                child.setCheckState(0, QtCore.Qt.Unchecked)
                            else:
                                child.setCheckState(0, state)
                            
                            # Recursively apply to children of directories
                            if os.path.isdir(abs_path):
                                apply_to_children(child, state)
                                
                apply_to_children(item, new_state)

                # Update parent state based on children (if all children are checked/unchecked)
                parent = item.parent()
                while parent:
                    all_children_checked = True
                    all_children_unchecked = True
                    has_checkable_children = False
                    
                    for i in range(parent.childCount()):
                        child = parent.child(i)
                        if child.flags() & QtCore.Qt.ItemIsUserCheckable and child.flags() & QtCore.Qt.ItemIsEnabled:
                            has_checkable_children = True
                            if child.checkState(0) == QtCore.Qt.Checked:
                                all_children_unchecked = False
                            elif child.checkState(0) == QtCore.Qt.Unchecked:
                                all_children_checked = False
                            else: # Partially checked
                                all_children_checked = False
                                all_children_unchecked = False
                    
                    if has_checkable_children:
                        if all_children_checked:
                            parent.setCheckState(0, QtCore.Qt.Checked)
                        elif all_children_unchecked:
                            parent.setCheckState(0, QtCore.Qt.Unchecked)
                        else:
                            parent.setCheckState(0, QtCore.Qt.PartiallyChecked)
                    else: # No checkable children, or directory that has no files/folders to check
                        parent.setCheckState(0, QtCore.Qt.Unchecked) # Explicitly set to unchecked
                    parent = parent.parent()

            finally:
                self.tree_widget.blockSignals(False)

            # Auto-expand parent folders if a file is checked (using QTimer to avoid timing issues)
            if item.checkState(0) == QtCore.Qt.Checked:
                file_path = item.data(0, QtCore.Qt.UserRole)
                if file_path and os.path.isfile(file_path):
                    # Use QTimer to ensure expansion happens after signal processing
                    QtCore.QTimer.singleShot(0, lambda: self.expand_parents_of_item(item))

            self.update_token_counter()
            # Only save preferences when explicitly requested by the user, or on window close.

    def expand_parents_of_item(self, item):
        """Expand all parent folders of the given item."""
        parent = item.parent()
        while parent is not None:
            self.tree_widget.expandItem(parent)
            parent = parent.parent()
    
    def _load_global_presets(self):
        try:
            presets = global_preset_manager.get_all_presets()
            for label, text in presets:
                self._add_preset_button(label, text, from_global=True)
        except Exception as e: 
            logging.error(f"Failed to load global presets: {e}")
            
    def _add_preset_button(self, label: str, text: str, from_local=False, from_global=False):
        btn = QtWidgets.QPushButton(label)
        btn.setFixedHeight(22)
        btn.clicked.connect(lambda _=None, t=text: self._apply_preset(t))
        
        if from_global:
            btn.setToolTip(f"Global preset: {label}")
        else:
            btn.setToolTip(f"Preset: {label}")
            
        # Insert before the stretch. The add/delete buttons are at the start.
        # Layout: [add_btn, delete_btn, ..., stretch]
        # We want to insert before 'stretch'.
        insert_index = self.preset_strip.count() - 1 
        self.preset_strip.insertWidget(insert_index, btn)

    def _delete_preset(self, label, button, from_global):
        reply = QtWidgets.QMessageBox.question(self, "Delete Preset", f"Are you sure you want to delete the preset '{label}'?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)
        if reply == QtWidgets.QMessageBox.Yes:
            if from_global:
                if not global_preset_manager.delete_preset(label): 
                    QtWidgets.QMessageBox.warning(self, "Error", f"Failed to delete global preset '{label}'")
                    return
            else: 
                # This branch for 'local' presets is currently not used, as all presets are global.
                # It's kept for logical completeness but would require a local preset saving mechanism.
                self.presets = [(l, t) for l, t in self.presets if l != label]
            self.preset_strip.removeWidget(button)
            button.deleteLater()
            logging.info(f"Deleted preset: {label}")
    
    def _apply_preset(self, preset_text: str):
        current = self.prompt_textbox.toPlainText(); self.prompt_textbox.setPlainText((current.rstrip() + "\n\n" if current else "") + preset_text)

    def delete_preset_dialog(self):
        presets = global_preset_manager.get_all_presets()
        if not presets:
            QtWidgets.QMessageBox.information(self, "No Presets", "There are no presets to delete.")
            return

        preset_labels = [p[0] for p in presets]
        label_to_delete, ok = QtWidgets.QInputDialog.getItem(self, "Delete Preset", 
                                                             "Select a preset to delete:", preset_labels, 0, False)

        if ok and label_to_delete:
            # Find the button widget corresponding to the label
            button_to_remove = None
            for i in range(self.preset_strip.count()):
                item = self.preset_strip.itemAt(i)
                if item and item.widget():
                    widget = item.widget()
                    if isinstance(widget, QtWidgets.QPushButton) and widget.text() == label_to_delete:
                        button_to_remove = widget
                        break
            
            if button_to_remove:
                # Call the existing delete logic, which includes the confirmation dialog.
                # All presets managed this way are considered global.
                self._delete_preset(label_to_delete, button_to_remove, from_global=True)
            else:
                # This is a descriptive error for debugging, in case the UI and data get out of sync.
                QtWidgets.QMessageBox.warning(self, "Error", "Could not find the corresponding button to delete. The UI might be out of sync.")
                
    def add_new_preset_dialog(self):
        lbl, ok = QtWidgets.QInputDialog.getText(self, "New preset", "Button label:");
        if not ok or not lbl.strip(): return
        dlg = QtWidgets.QDialog(self); dlg.setWindowTitle("Preset text"); dlg.setMinimumSize(400, 300); v = QtWidgets.QVBoxLayout(dlg)
        v.addWidget(QtWidgets.QLabel("Enter the preset text:")); text_edit = QtWidgets.QPlainTextEdit(); v.addWidget(text_edit)
        bb = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel); v.addWidget(bb); bb.accepted.connect(dlg.accept); bb.rejected.connect(dlg.reject)
        if dlg.exec() != QtWidgets.QDialog.Accepted: return
        txt = text_edit.toPlainText().strip()
        if txt and global_preset_manager.add_preset(lbl.strip(), txt): self._add_preset_button(lbl.strip(), txt, from_global=True)
        else: QtWidgets.QMessageBox.warning(self, "Error", "Failed to save preset.")
        
    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls() and event.mimeData().urls()[0].isLocalFile() and os.path.isdir(event.mimeData().urls()[0].toLocalFile()):
            event.acceptProposedAction()
    def dropEvent(self, event):
        folder_path = event.mimeData().urls()[0].toLocalFile()
        os.chdir(folder_path); from aicodeprep_gui.smart_logic import collect_all_files
        self.new_gui = FileSelectionGUI(collect_all_files()); self.new_gui.show(); self.close()
        
    def select_all(self):
        def check_all(item):
            # Only check if it's a file or a non-excluded folder
            abs_path = item.data(0, QtCore.Qt.UserRole)
            rel_path = os.path.relpath(abs_path, os.getcwd()) if abs_path else None
            is_excluded = False
            if rel_path:
                is_excluded = smart_logic.exclude_spec.match_file(rel_path) or smart_logic.exclude_spec.match_file(rel_path + '/')
                if os.path.isfile(abs_path) and smart_logic.is_binary_file(abs_path):
                    is_excluded = True # Treat binary files as implicitly excluded from 'select all'
            
            if item.flags() & QtCore.Qt.ItemIsUserCheckable and item.flags() & QtCore.Qt.ItemIsEnabled and not is_excluded:
                item.setCheckState(0, QtCore.Qt.Checked)
            else: # If it's excluded, uncheck it or keep unchecked
                 item.setCheckState(0, QtCore.Qt.Unchecked)

            for i in range(item.childCount()): 
                # Ensure children are loaded before processing, if it's a directory
                if os.path.isdir(abs_path):
                    self.on_item_expanded(item) # Ensures children are present for checking
                check_all(item.child(i))
        
        # Block signals temporarily to prevent recursive updates during mass selection
        self.tree_widget.blockSignals(True)
        try:
            for i in range(self.tree_widget.topLevelItemCount()): 
                check_all(self.tree_widget.topLevelItem(i))
        finally:
            self.tree_widget.blockSignals(False)
        self.update_token_counter()
        
    def deselect_all(self):
        iterator = QtWidgets.QTreeWidgetItemIterator(self.tree_widget)
        self.tree_widget.blockSignals(True) # Block signals during mass deselect
        try:
            while iterator.value():
                item = iterator.value()
                if item.flags() & QtCore.Qt.ItemIsUserCheckable: item.setCheckState(0, QtCore.Qt.Unchecked)
                iterator += 1
        finally:
            self.tree_widget.blockSignals(False)
        self.update_token_counter()

    def get_selected_files(self):
        selected = []; iterator = QtWidgets.QTreeWidgetItemIterator(self.tree_widget)
        while iterator.value():
            item = iterator.value()
            # Only consider files that are checked and not directories
            file_path = item.data(0, QtCore.Qt.UserRole)
            if file_path and os.path.isfile(file_path) and item.checkState(0) == QtCore.Qt.Checked:
                selected.append(file_path)
            iterator += 1
        return selected

    def process_selected(self):
        self.action = 'process'
        selected_files = self.get_selected_files()
        chosen_fmt = self.format_combo.currentData()
        prompt = self.prompt_textbox.toPlainText().strip()

        if process_files(
            selected_files,
            "fullcode.txt",
            fmt=chosen_fmt,
            prompt=prompt,
            prompt_to_top=self.prompt_top_checkbox.isChecked(),
            prompt_to_bottom=self.prompt_bottom_checkbox.isChecked()
        ) > 0:
            output_path = os.path.join(os.getcwd(), "fullcode.txt")
            # Now, just read the final content for the clipboard
            with open(output_path, "r", encoding="utf-8") as f:
                content = f.read()
            QtWidgets.QApplication.clipboard().setText(content)
            logging.info(f"Copied {len(content)} chars to clipboard.")
            self.text_label.setStyleSheet(
                f"font-size: 20px; color: {'#00c3ff' if self.is_dark_mode else '#0078d4'}; font-weight: bold;"
            )
            self.text_label.setText("Copied to clipboard and fullcode.txt")
            self.save_prefs()
            QtCore.QTimer.singleShot(1500, self.close)
        else:
            self.close()
            
    def quit_without_processing(self): self.action = 'quit'; self.close()
    
    def update_token_counter(self):
        total_tokens = 0
        for file_path in self.get_selected_files():
            if file_path not in self.file_token_counts:
                try:
                    with open(file_path, "r", encoding="utf-8", errors="ignore") as f: text = f.read()
                    self.file_token_counts[file_path] = len(text) // 4
                except Exception: self.file_token_counts[file_path] = 0
            total_tokens += self.file_token_counts[file_path]
        self.total_tokens = total_tokens; self.token_label.setText(f"Estimated tokens: {total_tokens:,}")
        
    def _expand_folders_for_paths(self, checked_paths: set):
        """Auto-expand folders that contain files from the given paths."""
        folders_to_expand = set()
        
        # Find all folders that should be expanded (containing checked files)
        for checked_path in checked_paths:
            # Get all parent directories of checked files
            path_parts = checked_path.split(os.sep)
            # Iterate up the path hierarchy to find parent directories
            current_path = ""
            for i, part in enumerate(path_parts):
                if i == 0:
                    current_path = part
                else:
                    current_path = os.path.join(current_path, part)
                
                # If it's a directory (and not the file itself)
                if current_path in self.path_to_item and os.path.isdir(self.path_to_item[current_path].data(0, QtCore.Qt.UserRole)):
                    folders_to_expand.add(self.path_to_item[current_path])
        
        # Expand the folders
        for item in folders_to_expand:
            self.tree_widget.expandItem(item)

    def auto_expand_common_folders(self):
        """Auto-expand common project folders on first load. (Currently not called from __init__)"""
        common_folders = ['src', 'lib', 'app', 'components', 'utils', 'helpers', 'models', 'views', 'controllers']
        
        for folder_name in common_folders:
            if folder_name in self.path_to_item:
                item = self.path_to_item[folder_name]
                self.tree_widget.expandItem(item)

    def load_from_prefs_button_clicked(self):
        prefs_path = _prefs_path()
        if os.path.exists(prefs_path):
            self.load_prefs_if_exists() # This re-populates self.checked_files_from_prefs etc.
            self.tree_widget.blockSignals(True)
            try:
                # First, deselect all files to provide a clean slate.
                # Directory states will be updated by handle_item_changed based on their children.
                iterator = QtWidgets.QTreeWidgetItemIterator(self.tree_widget)
                while iterator.value():
                    item = iterator.value()
                    # Only affect files here directly, directories will update based on children
                    if item.flags() & QtCore.Qt.ItemIsUserCheckable and os.path.isfile(item.data(0, QtCore.Qt.UserRole)):
                        item.setCheckState(0, QtCore.Qt.Unchecked) # Deselect all files first
                    iterator += 1

                # Then, check files based on preferences
                for rel_path in self.checked_files_from_prefs:
                    if rel_path in self.path_to_item:
                        item = self.path_to_item[rel_path]
                        if os.path.isfile(item.data(0, QtCore.Qt.UserRole)): # Only check files here
                            item.setCheckState(0, QtCore.Qt.Checked)
                            # Manually trigger parent updates for checked files, if not handled by setCheckState
                            parent = item.parent()
                            while parent:
                                if parent.checkState(0) != QtCore.Qt.PartiallyChecked and parent.checkState(0) != QtCore.Qt.Checked:
                                    # Set to partially checked if it was unchecked. Full check requires all children to be checked.
                                    parent.setCheckState(0, QtCore.Qt.PartiallyChecked) 
                                parent = parent.parent()

            finally:
                self.tree_widget.blockSignals(False)
            # Auto-expand folders after loading preferences
            self._expand_folders_for_paths(self.checked_files_from_prefs)
            file_type = ".auicp" if prefs_path.endswith(".auicp") else ".aicodeprep-gui"
            self.text_label.setText(f"Loaded selection from {file_type}")
            self.update_token_counter()
        else: 
            self.text_label.setText("No preferences file found (.aicodeprep-gui)")

    def closeEvent(self, event):
        if self.remember_checkbox and self.remember_checkbox.isChecked():
            self.save_prefs() # Save prefs only if 'remember' is checked
        if self.action != 'process': self.action = 'quit'
        super(FileSelectionGUI, self).closeEvent(event)

    def load_prefs_if_exists(self):
        checked, window_size, splitter_state = _read_prefs_file()
        self.checked_files_from_prefs = checked
        self.window_size_from_prefs = window_size
        self.splitter_state_from_prefs = splitter_state
        self.prefs_loaded = True

    def save_prefs(self):
        checked_relpaths = []
        # Iterate through path_to_item to get only the checked files (not directories)
        for rel_path, item in self.path_to_item.items():
            if item.checkState(0) == QtCore.Qt.Checked:
                file_path_abs = item.data(0, QtCore.Qt.UserRole)
                if file_path_abs and os.path.isfile(file_path_abs): # Only save files, not directories
                    checked_relpaths.append(rel_path)
        
        size = self.size()
        splitter_state = self.splitter.saveState()
        _write_prefs_file(checked_relpaths, window_size=(size.width(), size.height()), splitter_state=splitter_state)
        self._save_prompt_options()

    def _load_prompt_options(self):
        """Load global prompt/question placement options from QSettings."""
        settings = QtCore.QSettings("aicodeprep-gui", "PromptOptions")
        self.prompt_top_checkbox.setChecked(settings.value("prompt_to_top", True, type=bool))
        self.prompt_bottom_checkbox.setChecked(settings.value("prompt_to_bottom", True, type=bool))

    def _save_prompt_options(self):
        """Save global prompt/question placement options to QSettings."""
        settings = QtCore.QSettings("aicodeprep-gui", "PromptOptions")
        settings.setValue("prompt_to_top", self.prompt_top_checkbox.isChecked())
        settings.setValue("prompt_to_bottom", self.prompt_bottom_checkbox.isChecked())

    def toggle_dark_mode(self, state):
        self.is_dark_mode = bool(state)
        # 1. Apply the correct palette for the entire application
        if self.is_dark_mode:
            apply_dark_palette(self.app)
        else:
            apply_light_palette(self.app)

        # 2. Re-apply the main window's font stylesheet to force style refresh
        font_stack = '"Segoe UI", "Ubuntu", "Helvetica Neue", Arial, sans-serif'
        self.setStyleSheet(f"font-family: {font_stack};")

        # 3. Now, apply the more specific widget styles as before
        base_style = """
            QTreeView, QTreeWidget {
                outline: 2; /* Remove focus rectangle */
            }
        """
        checkbox_style = get_checkbox_style_dark() if self.is_dark_mode else get_checkbox_style_light()
        self.tree_widget.setStyleSheet(base_style + checkbox_style)
        
        # Update theme-aware styles for other widgets
        self.vibe_label.setStyleSheet(
            "background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #40203f, stop:1 #1f103f); "
            "color: white; padding: 0px 0px 0px 0px; border-radius: 8px;"
        )
        # Find preset_explanation and text_label by attribute
        for child in self.findChildren(QtWidgets.QLabel):
            if getattr(child, "objectName", lambda: "")() == "preset_explanation":
                child.setStyleSheet(
                    f"font-size: 10px; color: {'#bbbbbb' if self.is_dark_mode else '#444444'};"
                )
        # Update the status label's style if it has text
        if self.text_label.text():
            self.text_label.setStyleSheet(
                f"font-size: 20px; color: {'#00c3ff' if self.is_dark_mode else '#0078d4'}; font-weight: bold;"
            )

def show_file_selection_gui(files):
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])
    gui = FileSelectionGUI(files)
    gui.show()
    app.exec()
    return gui.action, gui.get_selected_files()

def _prefs_path():
    """Get the path to the preferences file, preferring .aicodeprep-gui, with .auicp as legacy for migration"""
    new_path = os.path.join(os.getcwd(), ".aicodeprep-gui")
    legacy_path = os.path.join(os.getcwd(), ".auicp")
    # Prefer new file
    if os.path.exists(new_path):
        return new_path
    # Fallback to legacy for migration
    elif os.path.exists(legacy_path):
        return legacy_path
    # Default to new file for new saves
    else:
        return new_path

def _write_prefs_file(checked_relpaths, window_size=None, splitter_state=None):
    """Write preferences to .aicodeprep-gui file"""
    new_path = os.path.join(os.getcwd(), ".aicodeprep-gui")
    try:
        with open(new_path, "w", encoding="utf-8") as f:
            header = (
                f"# .aicodeprep-gui LLM/AI context helper settings file\n"
                f"# This file stores your preferences (checked code files, window size) for this folder.\n"
                f"# Generated by aicodeprep-gui.\n"
                f"# Homepage: https://wuu73.org/aicp\n"
                f"# GitHub: https://github.com/detroittommy879/aicodeprep-gui\n"
                f"# ----------------------------------------------------------\n"
                f"# aicodeprep-gui preferences file version {AICODEPREP_GUI_VERSION}\n"
            )
            f.write(header)
            f.write(f"version={AICODEPREP_GUI_VERSION}\n\n")
            if window_size:
                f.write(f"[window]\nwidth={window_size[0]}\nheight={window_size[1]}\n")
                if splitter_state is not None:
                    # Convert QByteArray to base64 string for storage
                    import base64
                    splitter_data = base64.b64encode(splitter_state).decode('utf-8')
                    f.write(f"splitter_state={splitter_data}\n")
                f.write("\n")
            if checked_relpaths: f.write("[files]\n" + "\n".join(checked_relpaths) + "\n")
        logging.info(f"Saved preferences to {new_path}")
    except Exception as e: 
        logging.warning(f"Could not write .aicodeprep-gui: {e}")

def _read_prefs_file():
    """Read preferences file with backwards compatibility for legacy .auicp files (migrates to .aicodeprep-gui)"""
    checked, window_size, splitter_state = set(), None, None
    width_val, height_val = None, None 

    legacy_path = os.path.join(os.getcwd(), ".auicp")
    new_path = os.path.join(os.getcwd(), ".aicodeprep-gui")

    prefs_path = _prefs_path()

    try:
        with open(prefs_path, "r", encoding="utf-8") as f:
            section = None
            for line in f.read().splitlines():
                if line.strip().startswith('[') and line.strip().endswith(']'):
                    section = line.strip()[1:-1]
                    continue
                if not section: continue

                if section == "files":
                    if line.strip(): checked.add(line.strip())
                elif section == "window":
                    if line.startswith('width='):
                        try: width_val = int(line.split('=')[1])
                        except (ValueError, IndexError): pass
                    elif line.startswith('height='):
                        try: height_val = int(line.split('=')[1])
                        except (ValueError, IndexError): pass
                    elif line.startswith('splitter_state='):
                        try:
                            import base64
                            splitter_data = line.split('=', 1)[1]
                            splitter_state = base64.b64decode(splitter_data.encode('utf-8'))
                        except Exception as e:
                            logging.warning(f"Failed to decode splitter state: {e}")

            if width_val is not None and height_val is not None:
                window_size = (width_val, height_val)

        # Migration logic: if we read from .auicp, migrate to .aicodeprep-gui
        if prefs_path == legacy_path and not os.path.exists(new_path):
            logging.info("Migrating preferences from .auicp to .aicodeprep-gui")
            try:
                # Write the data to the new .aicodeprep-gui file
                _write_prefs_file(list(checked), window_size, splitter_state) 
                logging.info("Successfully migrated preferences to .aicodeprep-gui")
            except Exception as e:
                logging.error(f"Failed to migrate preferences: {e}")

    except FileNotFoundError:
        file_type = ".auicp" if prefs_path.endswith(".auicp") else ".aicodeprep-gui"
        logging.info(f"{file_type} file not found, will create on save.")
    except Exception as e:
        logging.error(f"Error reading preferences file: {e}")

    return checked, window_size, splitter_state

</code>

aicodeprep_gui\linux_installer.py:
<code>
import os
import shutil
import logging

NAUTILUS_SCRIPTS_DIR = os.path.expanduser("~/.local/share/nautilus/scripts")
SCRIPT_NAME = "Open with aicodeprep-gui"

# The shell script to be placed in the Nautilus scripts directory.
NAUTILUS_SCRIPT_CONTENT = """
#!/bin/bash

# Nautilus script for aicodeprep-gui.
# It processes the first selected directory.

# Find the command path. 'which' should work as this script runs in a user session.
CMD_PATH=$(which aicodeprep-gui)

if [ -z "$CMD_PATH" ]; then
    # Use zenity for a graphical error message if available
    if command -v zenity &> /dev/null; then
        zenity --error --width=300 --text="<b>aicodeprep-gui command not found.</b>\\n\\nPlease ensure it's installed and accessible from your terminal's PATH."
    fi
    exit 1
fi

# Nautilus provides selected paths as arguments.
TARGET_DIR="$1"

if [ -n "$TARGET_DIR" ] && [ -d "$TARGET_DIR" ]; then
    # Run the GUI, passing the selected directory.
    # Run in the background to not block Nautilus.
    "$CMD_PATH" "$TARGET_DIR" &
else
    if command -v zenity &> /dev/null; then
        zenity --info --text="Please select a directory to use this script."
    fi
fi
"""

def is_nautilus_installed():
    """Check if Nautilus file manager is likely installed."""
    return shutil.which('nautilus') is not None

def install_nautilus_script():
    """Installs the context menu script for the Nautilus file manager."""
    if not is_nautilus_installed():
        return False, "Nautilus file manager not found."

    try:
        os.makedirs(NAUTILUS_SCRIPTS_DIR, exist_ok=True)
        script_path = os.path.join(NAUTILUS_SCRIPTS_DIR, SCRIPT_NAME)
        
        with open(script_path, "w") as f:
            f.write(NAUTILUS_SCRIPT_CONTENT)
        
        # Make the script executable
        os.chmod(script_path, 0o755)

        msg = (f"Nautilus script '{SCRIPT_NAME}' installed successfully. "
               "Please restart Nautilus (nautilus -q) or log out and back in for it to appear.")
        logging.info(msg)
        return True, msg
    except Exception as e:
        msg = f"Failed to install Nautilus script: {e}"
        logging.error(msg)
        return False, msg

def uninstall_nautilus_script():
    """Uninstalls the context menu script for Nautilus."""
    script_path = os.path.join(NAUTILUS_SCRIPTS_DIR, SCRIPT_NAME)
    if os.path.exists(script_path):
        try:
            os.remove(script_path)
            msg = f"Nautilus script '{SCRIPT_NAME}' has been uninstalled."
            logging.info(msg)
            return True, msg
        except Exception as e:
            msg = f"Failed to uninstall Nautilus script: {e}"
            logging.error(msg)
            return False, msg
    else:
        msg = "Nautilus script not found (already uninstalled)."
        return True, msg

</code>

aicodeprep_gui\macos_installer.py:
<code>
import os
import shutil
import tempfile
import subprocess
import logging

# Template for the main workflow logic file.
# The {EXECUTABLE_PATH} will be replaced with the actual path.
DOCUMENT_WFLOW_TEMPLATE = """
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>AMApplicationBuild</key>
    <string>526</string>
    <key>AMApplicationVersion</key>
    <string>2.10</string>
    <key>AMDocumentVersion</key>
    <string>2</string>
    <key>actions</key>
    <array>
        <dict>
            <key>action</key>
            <dict>
                <key>AMAccepts</key>
                <dict>
                    <key>Container</key>
                    <string>List</string>
                    <key>Optional</key>
                    <true/>
                    <key>Types</key>
                    <array>
                        <string>com.apple.cocoa.string</string>
                    </array>
                </dict>
                <key>AMActionVersion</key>
                <string>2.0.3</string>
                <key>AMApplication</key>
                <array>
                    <string>Automator</string>
                </array>
                <key>AMParameterProperties</key>
                <dict>
                    <key>COMMAND_STRING</key>
                    <dict/>
                    <key>CheckedForUserDefaultShell</key>
                    <dict/>
                    <key>inputMethod</key>
                    <dict/>
                    <key>shell</key>
                    <dict/>
                    <key>source</key>
                    <dict/>
                </dict>
                <key>AMProvides</key>
                <dict>
                    <key>Container</key>
                    <string>List</string>
                    <key>Types</key>
                    <array>
                        <string>com.apple.cocoa.string</string>
                    </array>
                </dict>
                <key>ActionBundlePath</key>
                <string>/System/Library/Automator/Run Shell Script.action</string>
                <key>ActionName</key>
                <string>Run Shell Script</string>
                <key>ActionParameters</key>
                <dict>
                    <key>COMMAND_STRING</key>
                    <string>#!/bin/bash
# This Quick Action was generated by aicodeprep-gui.

# The full path to the executable was detected during generation.
CMD_PATH="{EXECUTABLE_PATH}"

if [ ! -x "$CMD_PATH" ]; then
  osascript -e 'display dialog "Error: The aicodeprep-gui executable was not found at its expected location: {EXECUTABLE_PATH}. You may need to reinstall the context menu from the app." buttons {{"OK"}} default button 1'
  exit 1
fi

# We will process the first selected folder.
# Automator passes selected items as arguments to the script.
if [ "$#" -eq 0 ]; then
    osascript -e 'display dialog "Please right-click on a folder to use this Quick Action." buttons {{"OK"}} default button 1'
    exit 1
fi

FOLDER_PATH="$1"

# Launch the GUI, passing the folder path.
# We run it in the background so the Automator action finishes immediately.
"$CMD_PATH" "$FOLDER_PATH" > /dev/null 2>&1 &
</string>
                    <key>CheckedForUserDefaultShell</key>
                    <true/>
                    <key>inputMethod</key>
                    <integer>1</integer>
                    <key>shell</key>
                    <string>/bin/bash</string>
                    <key>source</key>
                    <string></string>
                </dict>
                <key>BundleIdentifier</key>
                <string>com.apple.RunShellScript</string>
                <key>UUID</key>
                <string>725FD07E-C1D8-4B66-8B0D-751256D26C99</string>
            </dict>
        </dict>
    </array>
    <key>connectors</key>
    <dict/>
    <key>workflowMetaData</key>
    <dict>
        <key>workflowTypeIdentifier</key>
        <string>com.apple.Automator.servicesMenu</string>
        <key>serviceInputTypeIdentifier</key>
        <string>com.apple.Automator.fileSystemObject.folder</string>
        <key>serviceOutputTypeIdentifier</key>
        <string>com.apple.Automator.nothing</string>
        <key>serviceApplicationBundleID</key>
        <string>com.apple.finder</string>
        <key>serviceApplicationPath</key>
        <string>/System/Library/CoreServices/Finder.app</string>
        <key>serviceName</key>
        <string>Open with aicodeprep-gui</string>
    </dict>
</dict>
</plist>
"""

# Template for the Info.plist file, which defines the service menu item.
INFO_PLIST_TEMPLATE = """
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>NSServices</key>
    <array>
        <dict>
            <key>NSMenuItem</key>
            <dict>
                <key>default</key>
                <string>Open with aicodeprep-gui</string>
            </dict>
            <key>NSMessage</key>
            <string>runWorkflowAsService</string>
            <key>NSRequiredContext</key>
            <dict>
                <key>NSApplicationIdentifier</key>
                <string>com.apple.finder</string>
            </dict>
            <key>NSSendFileTypes</key>
            <array>
                <string>public.folder</string>
            </array>
        </dict>
    </array>
</dict>
</plist>
"""

WORKFLOW_NAME = "Open with aicodeprep-gui.workflow"
SERVICES_DIR = os.path.expanduser("~/Library/Services")

def install_quick_action():
    """Generates and installs the macOS Quick Action."""
    executable_path = shutil.which('aicodeprep-gui')
    if not executable_path:
        msg = "Could not find 'aicodeprep-gui' executable in PATH."
        logging.error(msg)
        return False, msg

    try:
        # Create the .workflow bundle structure in a temporary directory
        temp_dir = tempfile.mkdtemp()
        workflow_path = os.path.join(temp_dir, WORKFLOW_NAME)
        contents_path = os.path.join(workflow_path, "Contents")
        os.makedirs(contents_path, exist_ok=True)

        # Write the templated files
        wflow_content = DOCUMENT_WFLOW_TEMPLATE.format(EXECUTABLE_PATH=executable_path)
        with open(os.path.join(contents_path, "document.wflow"), "w") as f:
            f.write(wflow_content)

        with open(os.path.join(contents_path, "Info.plist"), "w") as f:
            f.write(INFO_PLIST_TEMPLATE)
            
        # Move the generated workflow to the user's Services directory
        dest_path = os.path.join(SERVICES_DIR, WORKFLOW_NAME)
        if os.path.exists(dest_path):
            shutil.rmtree(dest_path) # Remove old version if it exists
        
        shutil.move(workflow_path, SERVICES_DIR)
        
        # Clean up temporary directory
        shutil.rmtree(temp_dir)

        msg = (f"Quick Action '{WORKFLOW_NAME}' installed successfully to {SERVICES_DIR}. "
               "It should now appear in the right-click menu for folders in Finder.")
        logging.info(msg)
        return True, msg

    except Exception as e:
        msg = f"Failed to install Quick Action: {e}"
        logging.error(msg)
        return False, msg

def uninstall_quick_action():
    """Removes the macOS Quick Action from the user's Library."""
    dest_path = os.path.join(SERVICES_DIR, WORKFLOW_NAME)
    if os.path.exists(dest_path):
        try:
            shutil.rmtree(dest_path)
            msg = f"Quick Action '{WORKFLOW_NAME}' has been uninstalled."
            logging.info(msg)
            return True, msg
        except Exception as e:
            msg = f"Failed to uninstall Quick Action: {e}"
            logging.error(msg)
            return False, msg
    else:
        msg = "Quick Action was not found (already uninstalled)."
        logging.info(msg)
        return True, msg

</code>

aicodeprep_gui\main.py:
<code>
import os
import sys
import platform
import ctypes
from PySide6.QtCore import QSettings

# Handle --delset command-line option to delete user settings and exit
if "--delset" in sys.argv:
    # Delete ButtonPresets
    QSettings("aicodeprep-gui", "ButtonPresets").clear()
    # Delete PromptOptions
    QSettings("aicodeprep-gui", "PromptOptions").clear()
    # Delete UserIdentity
    QSettings("aicodeprep-gui", "UserIdentity").clear()
    print("All aicodeprep-gui user settings deleted.")
    sys.exit(0)
import argparse
import logging
from typing import List
from aicodeprep_gui.smart_logic import collect_all_files
from aicodeprep_gui.gui import show_file_selection_gui

# Configure logging with explicit console handler only
logger = logging.getLogger()

# Remove any existing handlers to prevent duplicate logging
for handler in logger.handlers:
    logger.removeHandler(handler)

logger.setLevel(logging.INFO)

# Create console handler
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
console_handler.setFormatter(formatter)

# Add handler to root logger
logger.addHandler(console_handler)

def main():
    parser = argparse.ArgumentParser(description="aicodeprep-gui: A smart GUI for preparing code repositories for AI analysis. Select and bundle files to be copied into your clipboard.")
    parser.add_argument("-n", "--no-copy", action="store_true",
                        help="Do NOT copy output to clipboard (default: copy to clipboard)")
    parser.add_argument("-o", "--output", default="fullcode.txt",
                        help="Output file name (default: fullcode.txt)")
    parser.add_argument("-d", "--debug", action="store_true",
                        help="Enable debug logging")
    parser.add_argument("directory", nargs="?", default=".",
                        help="Directory to process (default: current directory)")

    # --- ADD THESE NEW ARGUMENTS ---
    if platform.system() == "Windows":
        parser.add_argument("--install-context-menu-privileged", action="store_true", help=argparse.SUPPRESS)
        parser.add_argument("--remove-context-menu-privileged", action="store_true", help=argparse.SUPPRESS)
        parser.add_argument("--menu-text", type=str, help=argparse.SUPPRESS)
    # --- END OF NEW ARGUMENTS ---

    args = parser.parse_args()

    # Set Windows AppUserModelID for proper taskbar icon
    if platform.system() == "Windows":
        myappid = 'wuu73.aicodeprep-gui.1.0.0'  # arbitrary unique string
        try:
            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)
        except AttributeError:
            # Fails on older Windows versions, but that's acceptable.
            logging.warning("Could not set AppUserModelID. Taskbar icon may not be correct on older Windows.")

    # --- ADD THIS NEW LOGIC BLOCK ---
    if platform.system() == "Windows":
        try:
            from aicodeprep_gui import windows_registry
        except ImportError:
            windows_registry = None
        if args.install_context_menu_privileged and windows_registry:
            print("Running privileged action: Install context menu...")
            menu_text = getattr(args, 'menu_text', None)
            windows_registry.install_context_menu(menu_text)
            sys.exit(0)
        if args.remove_context_menu_privileged and windows_registry:
            print("Running privileged action: Remove context menu...")
            windows_registry.remove_context_menu()
            sys.exit(0)
    # --- END OF NEW LOGIC BLOCK ---

    # Ensure Fusion style for QSS consistency
    from PySide6 import QtWidgets
    app = QtWidgets.QApplication.instance()
    if app is None:
        app = QtWidgets.QApplication(sys.argv)
    app.setStyle("Fusion")

    # Set application icon from package favicon.ico
    from PySide6.QtGui import QIcon
    from importlib import resources
    with resources.as_file(resources.files('aicodeprep_gui.images').joinpath('favicon.ico')) as icon_path:
        app.setWindowIcon(QIcon(str(icon_path)))

    if args.debug:
        logger.setLevel(logging.DEBUG)
        console_handler.setLevel(logging.DEBUG)

    # Get the target directory from the parsed arguments
    target_dir = args.directory
    logger.info(f"Target directory: {target_dir}")

    # Change to the specified directory with error handling
    try:
        os.chdir(target_dir)
    except FileNotFoundError:
        logger.error(f"Directory not found: {target_dir}")
        return
    except Exception as e:
        logger.error(f"Error changing directory: {e}")
        return

    logger.info("Starting code concatenation...")

    all_files_with_flags = collect_all_files()

    if not all_files_with_flags:
        logger.warning("No files found to process!")
        return

    action, _ = show_file_selection_gui(all_files_with_flags)

    if action != 'quit':
        logger.info("Buy my cat a treat, comments, ideas for improvement appreciated: ")
        logger.info("https://wuu73.org/hello.html")

if __name__ == "__main__":
    main()

</code>

aicodeprep_gui\smart_logic.py:
<code>
from importlib import resources
import os
import sys
import logging
from typing import List, Tuple
import fnmatch

# New imports for the refactoring
import toml
from pathspec import PathSpec
from pathspec.patterns import GitWildMatchPattern

def get_config_path():
    """Get the path to the default configuration file."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
        config_path = os.path.join(base_path, 'aicodeprep_gui', 'data', 'default_config.toml')
    else:
        try:
            with resources.path('aicodeprep_gui.data', 'default_config.toml') as config_file:
                config_path = str(config_file)
        except ModuleNotFoundError:
            config_path = os.path.join(os.path.dirname(__file__), 'data', 'default_config.toml')
    return config_path

def load_config_from_path(path: str) -> dict:
    """Loads a TOML configuration file from a given path."""
    if not os.path.exists(path):
        return {}
    try:
        with open(path, "r", encoding="utf-8") as f:
            return toml.load(f)
    except Exception as e:
        logging.error(f"Error loading or parsing TOML config at {path}: {e}")
        return {}

def load_configurations() -> dict:
    """Load default config, then load user config and merge them."""
    default_config_path = get_config_path()
    config = load_config_from_path(default_config_path)
    if not config:
        logging.critical("Failed to load default configuration. Exiting.")
        sys.exit("Could not load the default configuration file.")
    user_config_path = os.path.join(os.getcwd(), 'aicodeprep-gui.toml')
    user_config = load_config_from_path(user_config_path)
    if user_config:
        logging.info(f"Found user configuration at {user_config_path}. Merging settings.")
        config.update(user_config)
    return config

def is_binary_file(filepath: str) -> bool:
    """Return True if this file is likely binary."""
    try:
        with open(filepath, 'rb') as f: chunk = f.read(1024)
    except OSError: return False
    if chunk.startswith((b'\xEF\xBB\xBF', b'\xFF\xFE', b'\xFE\xFF', b'\xFF\xFE\x00\x00', b'\x00\x00\xFE\xFF')): return False
    return b'\x00' in chunk

# --- CONFIG AND PATHSPEC LOADING ---
config = load_configurations()
CODE_EXTENSIONS = set(config.get('code_extensions', []))
MAX_FILE_SIZE = config.get('max_file_size', 1000000)
exclude_spec = PathSpec.from_lines(GitWildMatchPattern, config.get('exclude_patterns', []))
include_spec = PathSpec.from_lines(GitWildMatchPattern, config.get('default_include_patterns', []))
# These are still useful for some simple checks in the GUI and logic
EXCLUDE_DIRS = [p.rstrip('/') for p in config.get('exclude_patterns', []) if p.endswith('/')]
EXCLUDE_FILES = [p for p in config.get('exclude_patterns', []) if not p.endswith('/')]
EXCLUDE_PATTERNS = EXCLUDE_FILES # Simplified for backward compatibility
INCLUDE_FILES = config.get('default_include_patterns', [])
INCLUDE_DIRS = [p.rstrip('/') for p in INCLUDE_FILES if p.endswith('/')]
EXCLUDE_EXTENSIONS = [] # This concept is now handled by patterns

# --- REWRITTEN collect_all_files FOR LAZY LOADING ---
def collect_all_files() -> List[Tuple[str, str, bool]]:
    """
    Collects files and directories. For excluded directories, it returns them as
    a single entry without their contents, allowing the GUI to lazy-load them.
    Returns a list of (absolute_path, relative_path, is_checked_by_default).
    """
    all_paths = []
    root_dir = os.getcwd()
    seen_paths = set()
    logging.info(f"Starting initial fast scan in: {root_dir}")

    for root, dirs, files in os.walk(root_dir, topdown=True):
        rel_root = os.path.relpath(root, root_dir)
        if rel_root == '.': rel_root = ''

        # Add the directory itself unless it's the root
        if rel_root and root not in seen_paths:
             all_paths.append((root, rel_root, False))
             seen_paths.add(root)

        # Prune directories from the walk
        dirs_to_prune = []
        for d in dirs:
            rel_dir_path = os.path.join(rel_root, d)
            if exclude_spec.match_file(rel_dir_path + '/'):
                dirs_to_prune.append(d)
        dirs[:] = [d for d in dirs if d not in dirs_to_prune]

        # Process all items (unpruned dirs and files)
        for name in dirs + files:
            abs_path = os.path.join(root, name)
            rel_path = os.path.join(rel_root, name)
            if abs_path in seen_paths: continue

            # Determine default check state
            is_checked = False
            check_path = rel_path + '/' if os.path.isdir(abs_path) else rel_path

            if include_spec.match_file(check_path):
                is_checked = True
            elif os.path.isfile(abs_path) and os.path.splitext(name)[1].lower() in CODE_EXTENSIONS:
                 is_checked = True

            # Final filters for files
            if os.path.isfile(abs_path):
                if is_binary_file(abs_path) or os.path.getsize(abs_path) > MAX_FILE_SIZE:
                    is_checked = False

            all_paths.append((abs_path, rel_path, is_checked))
            seen_paths.add(abs_path)

    logging.info(f"Initial scan collected {len(all_paths)} items.")
    return all_paths

def is_excluded_directory(path: str) -> bool:
    """Simplified check used by GUI folder-click logic."""
    dir_name = os.path.basename(path)
    return any(fnmatch.fnmatch(dir_name, pat) for pat in EXCLUDE_DIRS)

def matches_pattern(filename: str, pattern: str) -> bool:
    """Helper used by GUI logic."""
    return fnmatch.fnmatch(filename.lower(), pattern.lower())

</code>

aicodeprep_gui\windows_registry.py:
<code>
import sys
import os
import winreg
import ctypes
import shutil
import logging

def is_admin():
    """Check if the script is running with administrative privileges."""
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except Exception as e:
        logging.error(f"Failed to check admin status: {e}")
        return False

def run_as_admin(action, menu_text=None):
    """
    Re-launches the script with admin rights to perform a specific action.
    'action' can be 'install' or 'remove'.
    'menu_text' is optional custom text for the context menu (only used with 'install').
    """
    if sys.platform != 'win32' and sys.platform != 'Windows':
        return False, "This feature is only for Windows."

    verb = "runas"
    executable = sys.executable  # The python interpreter

    # Use -m to run the main module
    script_entry_point = "aicodeprep_gui.main"

    if action == 'install':
        params = f'-m {script_entry_point} --install-context-menu-privileged'
        if menu_text and menu_text.strip():
            # Escape quotes and pass the menu text as an argument
            escaped_text = menu_text.replace('"', '\\"')
            params += f' --menu-text "{escaped_text}"'
    elif action == 'remove':
        params = f'-m {script_entry_point} --remove-context-menu-privileged'
    else:
        return False, "Invalid action."

    try:
        ret = ctypes.windll.shell32.ShellExecuteW(None, verb, executable, params, None, 1)
        if ret > 32:
            return True, "UAC prompt initiated. The application will close."
        else:
            return False, "UAC prompt was cancelled or failed."
    except Exception as e:
        logging.error(f"Failed to elevate privileges: {e}")
        return False, f"An error occurred while trying to elevate: {e}"

def get_registry_command():
    """
    Constructs the command to be written into the registry.
    Uses pythonw.exe to avoid a console window flashing on execution.
    """
    python_exe = sys.executable
    pythonw_exe = python_exe.replace("python.exe", "pythonw.exe")

    script_path = shutil.which('aicodeprep-gui')
    if not script_path:
        logging.error("Could not find 'aicodeprep-gui' script in system PATH.")
        return None

    # The command to be stored in the registry. Explorer replaces %V with the directory path.
    return f'"{pythonw_exe}" "{script_path}" "%V"'

def install_context_menu(menu_text=None):
    """Adds the context menu item to the Windows Registry. Assumes admin rights."""
    if not is_admin():
        logging.error("Install function called without admin rights.")
        print("Administrator rights required.")
        return False, "Administrator rights required."

    command = get_registry_command()
    if not command:
        return False, "'aicodeprep-gui' not found. Is it installed and in your PATH?"

    # Use custom menu text if provided, otherwise use default
    if menu_text is None or menu_text.strip() == "":
        menu_text = "Open with aicodeprep-gui"
    else:
        menu_text = menu_text.strip()

    try:
        key_path = r'Directory\\Background\\shell\\aicodeprep-gui'
        with winreg.CreateKey(winreg.HKEY_CLASSES_ROOT, key_path) as key:
            winreg.SetValue(key, '', winreg.REG_SZ, menu_text)
            with winreg.CreateKey(key, 'command') as command_key:
                winreg.SetValue(command_key, '', winreg.REG_SZ, command)

        logging.info(f"Context menu installed successfully with text: '{menu_text}'")
        restart_explorer()
        return True, f"Context menu installed successfully with text: '{menu_text}'! Explorer has been restarted."
    except Exception as e:
        logging.error(f"Failed to install context menu: {e}")
        return False, f"An error occurred: {e}"

def remove_context_menu():
    """Removes the context menu item from the Windows Registry. Assumes admin rights."""
    if not is_admin():
        logging.error("Remove function called without admin rights.")
        print("Administrator rights required.")
        return False, "Administrator rights required."

    try:
        key_path = r'Directory\\Background\\shell\\aicodeprep-gui'
        winreg.DeleteKey(winreg.HKEY_CLASSES_ROOT, f"{key_path}\\command")
        winreg.DeleteKey(winreg.HKEY_CLASSES_ROOT, key_path)

        logging.info("Context menu removed successfully.")
        restart_explorer()
        return True, "Context menu removed successfully! Explorer has been restarted."
    except FileNotFoundError:
        return True, "Context menu item was not found (already removed)."
    except Exception as e:
        logging.error(f"Failed to remove context menu: {e}")
        return False, f"An error occurred: {e}"

def restart_explorer():
    """Restarts the Windows Explorer process to apply registry changes."""
    try:
        os.system("taskkill /f /im explorer.exe")
        os.system("start explorer.exe")
    except Exception as e:
        logging.error(f"Failed to restart explorer.exe: {e}")

</code>

aicodeprep_gui\__init__.py:
<code>
# Package initialization
__version__ = "1.0.0"

</code>

pyproject.toml:
<code>
[build-system]
requires = ["setuptools>=61.0.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
# CRITICAL: Changed name to match your new package name
name = "aicodeprep-gui" 
version = "1.0.0"
description = "A smart GUI to select, filter, and concatenate code files for large language model (LLM) and AI analysis."
readme = "README.md"
authors = [{ name = "Tom Brothers", email = "tom@wuu73.org" }]
license = { file = "LICENSE" }
classifiers = [
    # NOTE: You might want to change "Proprietary" to an open-source license like "MIT"
    # if you intend for others to use and contribute.
    "License :: OSI Approved :: MIT License", 
    "Programming Language :: Python",
    "Programming Language :: Python :: 3",
    "Operating System :: OS Independent",
    "Topic :: Software Development",
    "Environment :: X11 Applications :: Qt",
    "Environment :: Win32 (MS Windows)",
    "Environment :: MacOS X",
]
keywords = ["ai", "code", "preparation", "llm", "gui", "pyside6"]
dependencies = [
    # These are the RUNTIME dependencies. Users who pip install your package need these.
    "PySide6>=6.7.0", # Simplified dependency, Essentials and Addons are included
    "toml",
    "pathspec",
    "requests" # for your network check
]
requires-python = ">=3.8" # PySide6 requires Python 3.8+

[project.scripts]
# CRITICAL: Changed script name and entry point module
aicodeprep-gui = "aicodeprep_gui.main:main"
aicp = "aicodeprep_gui.main:main"

[project.urls]
# SUGGESTION: Update this once you rename the GitHub repo
Homepage = "https://github.com/detroittommy879/aicodeprep-gui" 

[tool.setuptools.packages.find]
# This is correct and will find your `aicodeprep_gui` package
where = ["."] 

[tool.setuptools.package-data]
# CRITICAL: Changed key to match your actual package name `aicodeprep_gui`
aicodeprep_gui = ["data/default_config.toml", "images/*.png", "images/*.ico"]

# SUGGESTION: Create optional dependencies for developers/builders
[project.optional-dependencies]
build = [
    "pyinstaller>=6.0.0",
    "pyinstaller-hooks-contrib",
    "setuptools",
    "wheel"
]

</code>



can you create a privacy policy file, and make a new info menu next to file, edit... and then Info/Privacy policy will show it in a new window (with just an ok button to close it, or close button)? Analyze the code for any data it collects, which should be just anonymous information like when it tries to fetch the dixels url just to count how many people use the app etc. or what time they use it but nothing identifiyable. Write a prompt for Cline the ai coding agent to make the new file and make the edits for the menu changes, enclose the whole cline prompt in a single code tag.