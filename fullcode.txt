aicodeprep_gui_c\data\default_config.toml:
<code>
# AI Code Prep GUI Default Configuration File
# This file uses the TOML format.
# All exclusion patterns use the same syntax as a .gitignore file.
# A trailing slash '/' matches a directory.
# A leading '!' negates a pattern.

max_file_size = 4000000

# File extensions that are considered code and will be checked by default.
code_extensions = [
    ".md", ".py", ".js", ".jsx", ".ts", ".tsx", ".java", ".cpp", ".c", ".h",
    ".cs", ".php", ".rb", ".go", ".rs", ".swift", ".kt", ".scala", ".html",
    ".css", ".scss", ".sass", ".less", ".sql", ".sh", ".yaml", ".yml",
    ".json", ".xml", ".vue", ".r", ".m", ".f90", ".f95", ".f03", ".f08",
    ".gradle", ".groovy", ".ps1", ".psm1", ".ipynb", ".txt", ".lock",
    ".toml", ".ini", ".conf", ".cfg", ".properties"
]

# --- UNIFIED INCLUSION/EXCLUSION LISTS using .gitignore syntax ---

# Patterns for files/dirs to be checked *by default*.
default_include_patterns = [
    "README.md",
    "CONTRIBUTING.md",
    "important.txt",
    "important_docs/",
    "requirements.txt"
]

# Patterns for files/dirs to be excluded from the GUI list or unchecked.
exclude_patterns = [
    # Directories (note the trailing slash)
    ".git/",
    "node_modules/",
    "venv/",
    ".venv/",
    "__pycache__/",
    "build/",
    "dist/",
    ".idea/",
    "Lib/",
    "site-packages/",
    ".vscode/",
    ".github/",
    "spec/",
    "fixtures/",
    "migrations/",
    "logs/",
    "tmp/",
    "cache/",
    "assets/",
    "public/",
    "static/",
    "uploads/",
    "vendor/",
    "bin/",
    "obj/",
    "out/",
    "target/",
    "coverage/",
    "reports/",
    ".pytest_cache/",
    ".mypy_cache/",
    ".ipynb_checkpoints/",
    ".nyc_output/",
    "test-results/",
    "debug/",
    ".jest/",
    ".next/",
    ".nuxt/",
    ".svelte-kit/",
    ".expo/",
    "dist-ssr/",
    ".parcel-cache/",
    ".serverless/",
    ".vercel/",
    ".angular/",
    ".quasar/",
    ".redwood/",
    ".fusebox/",
    ".docusaurus/",
    ".terraform/",
    "*snapshots*/",

    # Lock files and metadata
    "package-lock.json",
    "yarn.lock",
    "Gemfile.lock",
    "composer.lock",
    "pnpm-lock.yaml",
    "bun.lock",
    "bun.lockb",
    "cargo.lock",
    "poetry.lock",
    "Pipfile.lock",
    ".DS_Store",
    "Thumbs.db",

    # Secrets and Keys
    ".npmrc",
    ".env",
    ".env.*",
    ".flaskenv",
    ".dockerenv",
    "env.json",
    "credentials.yaml",
    "secret*.json",
    "*.key",
    "*.pem",
    "*.crt",
    "*.pub",
    "id_rsa",
    "id_dsa",

    # Build artifacts & logs
    "Dockerfile.*.cache",
    "coverage.xml",
    "*.lcov",
    "*.log",

    # Binary and compiled files by extension
    "*.exe", "*.dll", "*.so", "*.dylib", "*.jar", "*.war",
    "*.ear", "*.o", "*.class",

    # General patterns
    "*.min.js", "*.min.css", "*bundle.js", "*chunk.js",
    "*test.js", "*spec.js", "*generated.ts",
    "*.swp", "*.swo", "*.un~", "~$*",
    "*.min.*", "*-lock.*", "*.snap",
    ".test.", ".spec.", ".bench.",
    "*.cache", "*.temp"
]

</code>

aicodeprep_gui_c\apptheme.py:
<code>
from PySide6 import QtCore, QtGui, QtWidgets
import platform
import os
import sys
import ctypes
import json

def system_pref_is_dark() -> bool:
    """Detect if system is using dark mode."""
    system = platform.system()
    
    if system == "Darwin":  # macOS
        try:
            import subprocess
            cmd = "defaults read -g AppleInterfaceStyle"
            result = subprocess.run(cmd, shell=True, text=True, capture_output=True)
            return result.stdout.strip() == "Dark"
        except:
            pass
    
    elif system == "Windows":  # Windows 10+
        try:
            import winreg
            registry = winreg.ConnectRegistry(None, winreg.HKEY_CURRENT_USER)
            reg_keypath = r"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize"
            key = winreg.OpenKey(registry, reg_keypath)
            value, _ = winreg.QueryValueEx(key, "AppsUseLightTheme")
            return value == 0
        except:
            pass
    
    # Fallback: use palette heuristic
    return QtWidgets.QApplication.palette().color(QtGui.QPalette.Window).lightness() < 128

def apply_dark_palette(app: QtWidgets.QApplication):
    """Apply dark color palette to application."""
    dark = QtGui.QPalette()
    dark.setColor(QtGui.QPalette.Window, QtGui.QColor(53, 53, 53))
    dark.setColor(QtGui.QPalette.WindowText, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Base, QtGui.QColor(42, 42, 42))
    dark.setColor(QtGui.QPalette.AlternateBase, QtGui.QColor(66, 66, 66))
    dark.setColor(QtGui.QPalette.ToolTipBase, QtGui.QColor(53, 53, 53))
    dark.setColor(QtGui.QPalette.ToolTipText, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Text, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Button, QtGui.QColor(53, 53, 53))
    dark.setColor(QtGui.QPalette.ButtonText, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Link, QtGui.QColor(42, 130, 218))
    dark.setColor(QtGui.QPalette.Highlight, QtGui.QColor(42, 130, 218))
    dark.setColor(QtGui.QPalette.HighlightedText, QtGui.QColor(255, 255, 255))
    
    # Disabled colors
    dark.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.Text, QtGui.QColor(128, 128, 128))
    dark.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, QtGui.QColor(128, 128, 128))
    dark.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, QtGui.QColor(128, 128, 128))
    
    app.setPalette(dark)

def apply_light_palette(app: QtWidgets.QApplication):
    """Apply light color palette to application."""
    light = QtGui.QPalette()
    light.setColor(QtGui.QPalette.Window, QtGui.QColor(240, 240, 240))
    light.setColor(QtGui.QPalette.WindowText, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Base, QtGui.QColor(255, 255, 255))
    light.setColor(QtGui.QPalette.AlternateBase, QtGui.QColor(233, 233, 233))
    light.setColor(QtGui.QPalette.ToolTipBase, QtGui.QColor(255, 255, 255))
    light.setColor(QtGui.QPalette.ToolTipText, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Text, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Button, QtGui.QColor(240, 240, 240))
    light.setColor(QtGui.QPalette.ButtonText, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Link, QtGui.QColor(0, 0, 255))
    light.setColor(QtGui.QPalette.Highlight, QtGui.QColor(42, 130, 218))
    light.setColor(QtGui.QPalette.HighlightedText, QtGui.QColor(255, 255, 255))
    
    # Disabled colors
    light.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.Text, QtGui.QColor(120, 120, 120))
    light.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, QtGui.QColor(120, 120, 120))
    light.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, QtGui.QColor(120, 120, 120))
    
    app.setPalette(light)

def create_checkmark_pixmap(size=16, color="#0078D4"):
    """Create a checkmark pixmap programmatically."""
    pixmap = QtGui.QPixmap(size, size)
    pixmap.fill(QtCore.Qt.transparent)
    
    painter = QtGui.QPainter(pixmap)
    painter.setRenderHint(QtGui.QPainter.Antialiasing)
    
    pen = QtGui.QPen(QtGui.QColor(color))
    pen.setWidth(2)
    pen.setCapStyle(QtCore.Qt.RoundCap)
    pen.setJoinStyle(QtCore.Qt.RoundJoin)
    painter.setPen(pen)
    
    # Draw checkmark
    painter.drawLine(4, 8, 7, 11)
    painter.drawLine(7, 11, 12, 4)
    
    painter.end()
    return pixmap

def create_x_mark_pixmap(size=16, color="#0078D4"):
    """Create an X mark pixmap programmatically (alternative to checkmark)."""
    pixmap = QtGui.QPixmap(size, size)
    pixmap.fill(QtCore.Qt.transparent)
    
    painter = QtGui.QPainter(pixmap)
    painter.setRenderHint(QtGui.QPainter.Antialiasing)
    
    pen = QtGui.QPen(QtGui.QColor(color))
    pen.setWidth(2)
    pen.setCapStyle(QtCore.Qt.RoundCap)
    painter.setPen(pen)
    
    # Draw X mark
    margin = 3
    painter.drawLine(margin, margin, size-margin, size-margin)
    painter.drawLine(margin, size-margin, size-margin, margin)
    
    painter.end()
    return pixmap

def _checkbox_style_with_images(dark: bool) -> str:
    """Use SVG-based checkboxes - same as _checkbox_style but with descriptive name."""
    return _checkbox_style(dark)



def _checkbox_style(dark: bool) -> str:
    """Return checkbox styling using permanent image files."""
    
    # Get the directory where this module is located
    module_dir = os.path.dirname(os.path.abspath(__file__))
    images_dir = os.path.join(module_dir, "images")
    
    # Use appropriate images for theme
    if dark:
        unchecked_filename = "checkbox_unchecked_dark.png"
        checked_filename = "checkbox_checked_dark.png"
    else:
        unchecked_filename = "checkbox_unchecked.png"
        checked_filename = "checkbox_checked.png"
    
    unchecked_path = os.path.join(images_dir, unchecked_filename)
    checked_path = os.path.join(images_dir, checked_filename)
    
    # Convert Windows paths to proper URLs for Qt
    if os.name == 'nt':  # Windows
        unchecked_url = unchecked_path.replace('\\', '/')
        checked_url = checked_path.replace('\\', '/')
    else:
        unchecked_url = unchecked_path
        checked_url = checked_path
    
    hover_border_color = "#00c3ff"
    
    return f"""
    QTreeView::indicator, QTreeWidget::indicator {{
        width: 16px;
        height: 16px;
        border: none;
        background: transparent;
        image: url({unchecked_url});
    }}
    
    QTreeView::indicator:checked, QTreeWidget::indicator:checked {{
        image: url({checked_url});
    }}
    
    QTreeView::indicator:hover, QTreeWidget::indicator:hover {{
        border: 1px solid {hover_border_color};
        border-radius: 2px;
    }}
    
    QTreeView::indicator:checked:hover, QTreeWidget::indicator:checked:hover {{
        border: 1px solid {hover_border_color};
        border-radius: 2px;
        image: url({checked_url});
    }}
    """

def get_checkbox_style_dark()  -> str: 
    return _checkbox_style(True)

def get_checkbox_style_light() -> str: 
    return _checkbox_style(False)

</code>

aicodeprep_gui_c\file_processor.py:
<code>
import os
import sys
import logging
from typing import List, Literal

OutputFmt = Literal['xml', 'markdown']

def _write_one_file_xml(outfile, rel_path, abs_path):
    outfile.write(f"{rel_path}:\n<code>\n")
    if is_binary_file(abs_path):
        outfile.write(".. contents skipped (binary file) ..")
    else:
        try:
            with open(abs_path, "r", encoding="utf-8", errors="ignore") as infile:
                outfile.write(infile.read())
        except Exception:
            outfile.write(".. contents skipped (read error) ..")
    outfile.write("\n</code>\n\n")

from aicodeprep_gui_c.smart_logic import is_binary_file

def _write_one_file_md(outfile, rel_path, abs_path):
    outfile.write(f"### {rel_path}\n")
    if is_binary_file(abs_path):
        outfile.write(".. contents skipped (binary file) ..\n")
    else:
        try:
            with open(abs_path, "r", encoding="utf-8", errors="ignore") as infile:
                outfile.write(infile.read())
        except Exception:
            outfile.write(".. contents skipped (read error) ..\n")
    outfile.write(f"\n### END {rel_path}\n\n")

def process_files(selected_files: List[str], output_file: str, fmt: OutputFmt = 'xml', prompt: str = "") -> int:
    """
    Write the concatenation of `selected_files` into `output_file`.
    `fmt` is either 'xml' (default, uses <code> … </code>) or
    'markdown' (### path … ### END path).
    """
    try:
        output_path = os.path.join(os.getcwd(), output_file)
        logging.info(f"Writing output to: {output_path}")

        writer = _write_one_file_xml if fmt == 'xml' else _write_one_file_md

        with open(output_path, 'w', encoding='utf-8') as outfile:
            for file_path in selected_files:
                try:
                    try:
                        rel_path = os.path.relpath(file_path, os.getcwd())
                    except ValueError:
                        rel_path = file_path
                    writer(outfile, rel_path, file_path)
                    logging.info(f"Processed: {rel_path}")
                except Exception as exc:
                    logging.error(f"Error processing {file_path}: {exc}")

            if prompt:
                outfile.write("\n\n" + prompt.strip())

            # generic tail line – no XML tags any more
            outfile.write("\n\n.. some other files were skipped ..\n")

        return len(selected_files)
    except Exception as exc:
        logging.error(f"Error writing output file: {exc}")
        return 0

</code>

aicodeprep_gui_c\gui.py:
<code>
import os
import sys
import platform
import logging
from PySide6 import QtWidgets, QtCore, QtGui, QtNetwork
from aicodeprep_gui_c.apptheme import system_pref_is_dark, apply_dark_palette, apply_light_palette, get_checkbox_style_dark, get_checkbox_style_light
from typing import List, Tuple
from aicodeprep_gui_c import smart_logic
from aicodeprep_gui_c.file_processor import process_files

class FlowLayout(QtWidgets.QLayout):
    def __init__(self, parent=None, margin=-1, hspacing=-1, vspacing=-1):
        super(FlowLayout, self).__init__(parent)
        self._items = []
        self.setContentsMargins(margin, margin, margin, margin)
        self._hspacing = hspacing
        self._vspacing = vspacing

    def __del__(self):
        del self._items[:]

    def addItem(self, item):
        self._items.append(item)
        self.invalidate()

    def horizontalSpacing(self):
        if self._hspacing >= 0:
            return self._hspacing
        return self.smartSpacing(QtWidgets.QStyle.PM_LayoutHorizontalSpacing)

    def verticalSpacing(self):
        if self._vspacing >= 0:
            return self._vspacing
        return self.smartSpacing(QtWidgets.QStyle.PM_LayoutVerticalSpacing)

    def count(self):
        return len(self._items)

    def itemAt(self, index):
        if 0 <= index < len(self._items):
            return self._items[index]
        return None

    def takeAt(self, index):
        if 0 <= index < len(self._items):
            item = self._items.pop(index)
            self.invalidate()
            return item
        return None
        
    def insertWidget(self, index, widget):
        self.insertItem(index, QtWidgets.QWidgetItem(widget))

    def insertItem(self, index, item):
        self._items.insert(index, item)
        self.invalidate()

    def removeWidget(self, widget):
        for i, item in enumerate(self._items):
            if item.widget() is widget:
                self.takeAt(i)
                # Do not delete the widget, the caller is responsible
                break
    
    def expandingDirections(self):
        return QtCore.Qt.Orientation(0)

    def hasHeightForWidth(self):
        return True

    def heightForWidth(self, width):
        return self.doLayout(QtCore.QRect(0, 0, width, 0), True)

    def setGeometry(self, rect):
        super(FlowLayout, self).setGeometry(rect)
        self.doLayout(rect, False)

    def sizeHint(self):
        return self.minimumSize()

    def minimumSize(self):
        size = QtCore.QSize()
        for item in self._items:
            size = size.expandedTo(item.minimumSize())
        margins = self.contentsMargins()
        size += QtCore.QSize(margins.left() + margins.right(), margins.top() + margins.bottom())
        return size

    def doLayout(self, rect, testOnly):
        m = self.contentsMargins()
        x = rect.x() + m.left()
        y = rect.y() + m.top()
        lineHeight = 0

        spaceX = self.horizontalSpacing()
        spaceY = self.verticalSpacing()

        for item in self._items:
            nextX = x + item.sizeHint().width() + spaceX
            if nextX - spaceX > rect.right() - m.right() and lineHeight > 0:
                x = rect.x() + m.left()
                y = y + lineHeight + spaceY
                lineHeight = 0
            
            if not testOnly:
                item.setGeometry(QtCore.QRect(QtCore.QPoint(x, y), item.sizeHint()))

            x = x + item.sizeHint().width() + spaceX
            lineHeight = max(lineHeight, item.sizeHint().height())

        return y + lineHeight + m.bottom()

    def smartSpacing(self, pm):
        parent = self.parent()
        if not parent:
            return -1
        if parent.isWidgetType():
            return parent.style().pixelMetric(pm, None, parent)
        else:
            return parent.spacing()

# Version for .aicodeprep file format
AICODEPREP_VERSION = "1.0"

class GlobalPresetManager:
    def __init__(self):
        try:
            self.settings = QtCore.QSettings("AICodePrep", "ButtonPresets")
            self._ensure_default_presets()
        except Exception as e:
            logging.error(f"Failed to initialize global preset manager: {e}")
            self.settings = None
    
    def _ensure_default_presets(self):
        """Create default presets if they don't exist"""
        try:
            if not self.settings:
                return
                
            self.settings.beginGroup("presets")
            existing_keys = self.settings.childKeys()
            self.settings.endGroup()
            
            if not existing_keys:
                default_presets = [
                    ("Debug", "Can you help me debug this code?"),
                    ("Security check", "Can you analyze this code for any security issues?"),
                    ("Best Practices", "Please keep in mind: Error handling, Edge cases, Performance optimization, Best practices, Please do not unnecessarily remove any comments or code. Generate the code with clear comments explaining the logic."),
                    ("Please review for", "Code quality and adherence to best practices, Potential bugs or edge cases, Performance optimizations, Readability and maintainability, Any security concerns, Suggest improvements and explain your reasoning for each suggestion")
                ]
                
                self.settings.beginGroup("presets")
                for label, text in default_presets:
                    self.settings.setValue(label, text)
                self.settings.endGroup()
                logging.info("Created default button presets")
        except Exception as e:
            logging.error(f"Failed to create default presets: {e}")
    
    def get_all_presets(self):
        """Get all saved presets as list of (label, text) tuples"""
        try:
            if not self.settings: return []
            presets = []
            self.settings.beginGroup("presets")
            for key in self.settings.childKeys():
                presets.append((key, self.settings.value(key, "")))
            self.settings.endGroup()
            return presets
        except Exception as e:
            logging.error(f"Failed to get presets: {e}")
            return []
    
    def add_preset(self, label, text):
        try:
            if not self.settings or not label.strip() or not text.strip(): return False
            self.settings.beginGroup("presets")
            self.settings.setValue(label.strip(), text.strip())
            self.settings.endGroup()
            return True
        except Exception as e:
            logging.error(f"Failed to add preset '{label}': {e}")
            return False
    
    def delete_preset(self, label):
        try:
            if not self.settings or not label.strip(): return False
            self.settings.beginGroup("presets")
            self.settings.remove(label.strip())
            self.settings.endGroup()
            return True
        except Exception as e:
            logging.error(f"Failed to delete preset '{label}': {e}")
            return False

global_preset_manager = GlobalPresetManager()

class FileSelectionGUI(QtWidgets.QMainWindow):
    def __init__(self, files):
        super().__init__()
        self.presets = []
        self.setAcceptDrops(True)
        self.files = files

        from datetime import datetime
        self.network_manager = QtNetwork.QNetworkAccessManager(self)
        now = datetime.now()
        time_str = f"{now.strftime('%I').lstrip('0') or '12'}{now.strftime('%M')}{now.strftime('%p').lower()}"
        request = QtNetwork.QNetworkRequest(QtCore.QUrl(f"https://wuu73.org/dixels/loads.html?t={time_str}"))
        self.network_manager.get(request)

        self.setWindowTitle("AI Code Prep - File Selection")
        self.app = QtWidgets.QApplication.instance()
        if self.app is None: self.app = QtWidgets.QApplication([])
        self.action = 'quit'

        self.prefs_filename = ".aicodeprep"
        self.remember_checkbox = None
        self.checked_files_from_prefs = set()
        self.prefs_loaded = False
        self.window_size_from_prefs = None
        self.load_prefs_if_exists()

        if platform.system() == 'Windows':
            scale_factor = self.app.primaryScreen().logicalDotsPerInch() / 96.0
        else:
            scale_factor = self.app.primaryScreen().devicePixelRatio()

        default_font_size = 9
        system_font = 'Segoe UI' if platform.system() == 'Windows' else 'Arial'
        default_font_size = int(default_font_size * scale_factor)
        self.default_font = QtGui.QFont(system_font, default_font_size)
        self.setFont(self.default_font)
        style = self.style()
        self.folder_icon = style.standardIcon(QtWidgets.QStyle.SP_DirIcon)
        self.file_icon = style.standardIcon(QtWidgets.QStyle.SP_FileIcon)

        if self.window_size_from_prefs:
            w, h = self.window_size_from_prefs
            self.setGeometry(100, 100, w, h)
        else:
            self.setGeometry(100, 100, int(600 * scale_factor), int(400 * scale_factor))

        self.is_dark_mode = system_pref_is_dark()
        if self.is_dark_mode: apply_dark_palette(self.app)

        central = QtWidgets.QWidget()
        self.setCentralWidget(central)
        main_layout = QtWidgets.QVBoxLayout(central)
        main_layout.setContentsMargins(20, 10, 20, 10)

        mb = self.menuBar()
        file_menu = mb.addMenu("&File")
        quit_act = QtGui.QAction("&Quit", self); quit_act.triggered.connect(self.quit_without_processing); file_menu.addAction(quit_act)
        edit_menu = mb.addMenu("&Edit")
        new_preset_act = QtGui.QAction("&New Preset…", self); new_preset_act.triggered.connect(self.add_new_preset_dialog); edit_menu.addAction(new_preset_act)

        title_bar_layout = QtWidgets.QHBoxLayout()
        self.format_combo = QtWidgets.QComboBox(); self.format_combo.addItems(["XML <code>", "Markdown ###"]); self.format_combo.setFixedWidth(130)
        self.format_combo.setItemData(0, 'xml'); self.format_combo.setItemData(1, 'markdown')
        output_label = QtWidgets.QLabel("&Output format:"); output_label.setBuddy(self.format_combo)
        title_bar_layout.addWidget(output_label); title_bar_layout.addWidget(self.format_combo); title_bar_layout.addStretch()
        self.dark_mode_box = QtWidgets.QCheckBox("Dark mode"); self.dark_mode_box.setChecked(self.is_dark_mode); self.dark_mode_box.stateChanged.connect(self.toggle_dark_mode)
        title_bar_layout.addWidget(self.dark_mode_box)
        main_layout.addLayout(title_bar_layout)
        self.token_label = QtWidgets.QLabel("Estimated tokens: 0")
        main_layout.addWidget(self.token_label)
        main_layout.addSpacing(8)

        self.vibe_label = QtWidgets.QLabel("AI Code Prep GUI")
        vibe_font = QtGui.QFont(self.default_font); vibe_font.setBold(True); vibe_font.setPointSize(self.default_font.pointSize() + 8)
        self.vibe_label.setFont(vibe_font); self.vibe_label.setAlignment(QtCore.Qt.AlignHCenter)
        self.vibe_label.setStyleSheet("background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #00c3ff, stop:1 #7f00ff); color: white; padding: 0; border-radius: 8px;")
        self.vibe_label.setFixedHeight(44)
        banner_wrap = QtWidgets.QWidget(); banner_layout = QtWidgets.QHBoxLayout(banner_wrap); banner_layout.setContentsMargins(14, 0, 14, 0); banner_layout.addWidget(self.vibe_label)
        main_layout.addWidget(banner_wrap)
        main_layout.addSpacing(8)
        self.info_label = QtWidgets.QLabel("I tried to guess which code files you will likely want included, adjust as needed")
        self.info_label.setAlignment(QtCore.Qt.AlignHCenter)
        main_layout.addWidget(self.info_label)

        self.text_label = QtWidgets.QLabel("")
        self.text_label.setWordWrap(True)
        main_layout.addWidget(self.text_label)

        # Create scrollable preset area
        presets_wrapper = QtWidgets.QHBoxLayout()
        presets_wrapper.addWidget(QtWidgets.QLabel("Presets:"))
        
        # Scrollable area for preset buttons
        scroll_area = QtWidgets.QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll_area.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        scroll_area.setFixedHeight(52)  # Enough height for 22px buttons + padding
        
        scroll_widget = QtWidgets.QWidget()
        self.preset_strip = QtWidgets.QHBoxLayout(scroll_widget)
        self.preset_strip.setContentsMargins(0, 0, 0, 0)
        
        add_preset_btn = QtWidgets.QPushButton("✚")
        add_preset_btn.setFixedSize(24, 24)
        add_preset_btn.setToolTip("New Preset…")
        add_preset_btn.clicked.connect(self.add_new_preset_dialog)
        self.preset_strip.addWidget(add_preset_btn)
        self.preset_strip.addStretch()
        
        scroll_area.setWidget(scroll_widget)
        presets_wrapper.addWidget(scroll_area)
        
        main_layout.addLayout(presets_wrapper)
        main_layout.addSpacing(8)

        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)
        self.tree_widget = QtWidgets.QTreeWidget()
        self.tree_widget.setHeaderLabels(["File/Folder"])
        self.tree_widget.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        # Fix: The original code had a syntax error here, it should be a direct string assignment.
        # Apply initial checkbox styling along with other styles
        base_style = """
            QTreeView, QTreeWidget {
                outline: 2; /* Remove focus rectangle */
            }
        """
        checkbox_style = get_checkbox_style_dark() if self.is_dark_mode else get_checkbox_style_light()
        self.tree_widget.setStyleSheet(base_style + checkbox_style)
        
        self.splitter.addWidget(self.tree_widget)
        prompt_widget = QtWidgets.QWidget(); prompt_layout = QtWidgets.QVBoxLayout(prompt_widget); prompt_layout.setContentsMargins(0,0,0,0)
        prompt_layout.addWidget(QtWidgets.QLabel("Optional prompt/question for LLM (will be appended to the end):")); prompt_layout.addSpacing(8)
        self.prompt_textbox = QtWidgets.QPlainTextEdit(); self.prompt_textbox.setPlaceholderText("Type your question or prompt here (optional)…")
        prompt_layout.addWidget(self.prompt_textbox)
        self.splitter.addWidget(prompt_widget)
        self.splitter.setStretchFactor(0, 4); self.splitter.setStretchFactor(1, 1)
        main_layout.addWidget(self.splitter)

        # --- NEW TREE BUILDING LOGIC ---
        self.path_to_item = {}  # Maps relative_path to QTreeWidgetItem
        root_node = self.tree_widget.invisibleRootItem()
        for abs_path, rel_path, is_checked in files:
            parts = rel_path.split(os.sep)
            parent_node = root_node
            path_so_far = ""
            for part in parts[:-1]:
                path_so_far = os.path.join(path_so_far, part) if path_so_far else part
                if path_so_far in self.path_to_item:
                    parent_node = self.path_to_item[path_so_far]
                else:
                    # This case implies a directory was not in the `files` list, create it
                    new_parent = QtWidgets.QTreeWidgetItem(parent_node, [part])
                    new_parent.setIcon(0, self.folder_icon)
                    new_parent.setFlags(new_parent.flags() | QtCore.Qt.ItemIsUserCheckable)
                    new_parent.setCheckState(0, QtCore.Qt.Unchecked)
                    self.path_to_item[path_so_far] = new_parent
                    parent_node = new_parent

            # Create the final item
            item_text = parts[-1]
            item = QtWidgets.QTreeWidgetItem(parent_node, [item_text])
            item.setData(0, QtCore.Qt.UserRole, abs_path) # Store absolute path
            self.path_to_item[rel_path] = item

            if self.prefs_loaded:
                is_checked = rel_path in self.checked_files_from_prefs
            
            if os.path.isdir(abs_path):
                item.setIcon(0, self.folder_icon)
                item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
            else: # It's a file
                item.setIcon(0, self.file_icon)
                item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
                # Don't block binary files, just leave them unchecked by default
                if smart_logic.is_binary_file(abs_path):
                    is_checked = False
            
            item.setCheckState(0, QtCore.Qt.Checked if is_checked else QtCore.Qt.Unchecked)

        # Connect signals for lazy loading and item changes
        self.tree_widget.itemExpanded.connect(self.on_item_expanded)
        self.tree_widget.itemChanged.connect(self.handle_item_changed)
        
        # Auto-expand folders containing checked files and common project folders
        if self.prefs_loaded and self.checked_files_from_prefs:
            self.auto_expand_checked_folders()
        else:
            # Auto-expand common folders on first load
            self.auto_expand_common_folders()
        
        prefs_checkbox_layout = QtWidgets.QHBoxLayout()
        self.remember_checkbox = QtWidgets.QCheckBox("Remember checked files for this folder (.aicodeprep) and window size")
        self.remember_checkbox.setChecked(True)
        prefs_checkbox_layout.addWidget(self.remember_checkbox)
        main_layout.addLayout(prefs_checkbox_layout)
        
        button_layout1 = QtWidgets.QHBoxLayout(); button_layout2 = QtWidgets.QHBoxLayout()
        main_layout.addLayout(button_layout1); main_layout.addLayout(button_layout2)
        website_label = QtWidgets.QLabel("<a href=\"https://wuu73.org/aicp\">wuu73.org/aicp</a>"); website_label.setOpenExternalLinks(True); main_layout.insertWidget(main_layout.count() - 2, website_label)
        button_layout1.addStretch()
        process_button = QtWidgets.QPushButton("Process Selected"); process_button.clicked.connect(self.process_selected); button_layout1.addWidget(process_button)
        select_all_button = QtWidgets.QPushButton("Select All"); select_all_button.clicked.connect(self.select_all); button_layout1.addWidget(select_all_button)
        deselect_all_button = QtWidgets.QPushButton("Deselect All"); deselect_all_button.clicked.connect(self.deselect_all); button_layout1.addWidget(deselect_all_button)
        button_layout2.addStretch()
        load_prefs_button = QtWidgets.QPushButton("Load from .aicodeprep"); load_prefs_button.clicked.connect(self.load_from_prefs_button_clicked); button_layout2.addWidget(load_prefs_button)
        quit_button = QtWidgets.QPushButton("Quit"); quit_button.clicked.connect(self.quit_without_processing); button_layout2.addWidget(quit_button)

        self.selected_files = []
        self.file_token_counts = {}
        self.update_token_counter()
        self._load_global_presets()
        if self.prefs_loaded and self.loaded_presets:
            for label, text in self.loaded_presets: self._add_preset_button(label, text, from_local=True)

    def on_item_expanded(self, item):
        """Handler for when a tree item is expanded, used for lazy loading."""
        # Check if this folder has already been loaded
        dir_path = item.data(0, QtCore.Qt.UserRole)
        if not dir_path or not os.path.isdir(dir_path): 
            return
            
        # Check if children have already been loaded
        if item.childCount() > 0:
            # If first child is a real item (not placeholder), already loaded
            first_child = item.child(0)
            if first_child.data(0, QtCore.Qt.UserRole):
                return
            
        try:
            # Clear any existing children first
            item.takeChildren()
        
            for name in sorted(os.listdir(dir_path)):
                abs_path = os.path.join(dir_path, name)
                rel_path = os.path.relpath(abs_path, os.getcwd())
                
                if rel_path in self.path_to_item: continue # Already exists

                new_item = QtWidgets.QTreeWidgetItem(item, [name])
                new_item.setData(0, QtCore.Qt.UserRole, abs_path)
                new_item.setFlags(new_item.flags() | QtCore.Qt.ItemIsUserCheckable)
                self.path_to_item[rel_path] = new_item
                
                is_excluded = smart_logic.exclude_spec.match_file(rel_path) or smart_logic.exclude_spec.match_file(rel_path + '/')
                
                if os.path.isdir(abs_path):
                    new_item.setIcon(0, self.folder_icon)
                else: # File
                    new_item.setIcon(0, self.file_icon)
                    # Don't block binary files, just leave them unchecked
                    if smart_logic.is_binary_file(abs_path):
                        is_excluded = True

                # Set check state based on parent, unless it's excluded
                if is_excluded:
                    new_item.setCheckState(0, QtCore.Qt.Unchecked)
                else:
                    new_item.setCheckState(0, item.checkState(0))

        except OSError as e:
            logging.error(f"Error scanning directory {dir_path}: {e}")

    def handle_item_changed(self, item, column):
        if column == 0:
            self.tree_widget.blockSignals(True)
            try:
                new_state = item.checkState(0)
                def apply_to_children(parent_item, state):
                    for i in range(parent_item.childCount()):
                        child = parent_item.child(i)
                        if child.flags() & QtCore.Qt.ItemIsUserCheckable and child.flags() & QtCore.Qt.ItemIsEnabled:
                            child.setCheckState(0, state)
                            if child.childCount() > 0:
                                apply_to_children(child, state)
                apply_to_children(item, new_state)
            finally:
                self.tree_widget.blockSignals(False)

            self.update_token_counter()
            if self.remember_checkbox and self.remember_checkbox.isChecked():
                self.save_prefs()
    
    def _load_global_presets(self):
        try:
            presets = global_preset_manager.get_all_presets()
            for label, text in presets:
                self._add_preset_button(label, text, from_global=True)
        except Exception as e: 
            logging.error(f"Failed to load global presets: {e}")
    def _add_preset_button(self, label: str, text: str, from_local=False, from_global=False):
        btn = QtWidgets.QPushButton(label); btn.setFixedHeight(22); btn.clicked.connect(lambda _=None, t=text: self._apply_preset(t))
        btn.setContextMenuPolicy(QtCore.Qt.CustomContextMenu); btn.customContextMenuRequested.connect(lambda pos, l=label, b=btn, fg=from_global: self._show_preset_context_menu(pos, l, b, fg))
        if from_global: btn.setToolTip(f"Global preset: {label}\nRight-click to delete")
        else: btn.setToolTip(f"Preset: {label}\nRight-click to delete")
        # Insert before the "✚" button (which is the last widget)
        insert_index = self.preset_strip.count() - 1
        self.preset_strip.insertWidget(insert_index, btn)
    def _show_preset_context_menu(self, pos, label, button, from_global):
        menu = QtWidgets.QMenu(self); delete_action = menu.addAction("Delete Preset")
        if menu.exec(button.mapToGlobal(pos)) == delete_action: self._delete_preset(label, button, from_global)
    def _delete_preset(self, label, button, from_global):
        reply = QtWidgets.QMessageBox.question(self, "Delete Preset", f"Are you sure you want to delete the preset '{label}'?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)
        if reply == QtWidgets.QMessageBox.Yes:
            if from_global:
                if not global_preset_manager.delete_preset(label): QtWidgets.QMessageBox.warning(self, "Error", f"Failed to delete global preset '{label}'"); return
            else: self.presets = [(l, t) for l, t in self.presets if l != label]; self.save_prefs()
            self.preset_strip.removeWidget(button)
            button.deleteLater()
            logging.info(f"Deleted preset: {label}")
    def _apply_preset(self, preset_text: str):
        current = self.prompt_textbox.toPlainText(); self.prompt_textbox.setPlainText((current.rstrip() + "\n\n" if current else "") + preset_text)
    def add_new_preset_dialog(self):
        lbl, ok = QtWidgets.QInputDialog.getText(self, "New preset", "Button label:");
        if not ok or not lbl.strip(): return
        dlg = QtWidgets.QDialog(self); dlg.setWindowTitle("Preset text"); dlg.setMinimumSize(400, 300); v = QtWidgets.QVBoxLayout(dlg)
        v.addWidget(QtWidgets.QLabel("Enter the preset text:")); text_edit = QtWidgets.QPlainTextEdit(); v.addWidget(text_edit)
        bb = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel); v.addWidget(bb); bb.accepted.connect(dlg.accept); bb.rejected.connect(dlg.reject)
        if dlg.exec() != QtWidgets.QDialog.Accepted: return
        txt = text_edit.toPlainText().strip()
        if txt and global_preset_manager.add_preset(lbl.strip(), txt): self._add_preset_button(lbl.strip(), txt, from_global=True)
        else: QtWidgets.QMessageBox.warning(self, "Error", "Failed to save preset.")
    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls() and event.mimeData().urls()[0].isLocalFile() and os.path.isdir(event.mimeData().urls()[0].toLocalFile()):
            event.acceptProposedAction()
    def dropEvent(self, event):
        folder_path = event.mimeData().urls()[0].toLocalFile()
        os.chdir(folder_path); from aicodeprep_gui_c.smart_logic import collect_all_files
        self.new_gui = FileSelectionGUI(collect_all_files()); self.new_gui.show(); self.close()
    def select_all(self):
        def check_all(item):
            if item.flags() & QtCore.Qt.ItemIsUserCheckable and item.flags() & QtCore.Qt.ItemIsEnabled: item.setCheckState(0, QtCore.Qt.Checked)
            for i in range(item.childCount()): check_all(item.child(i))
        for i in range(self.tree_widget.topLevelItemCount()): check_all(self.tree_widget.topLevelItem(i))
        self.update_token_counter()
    def deselect_all(self):
        iterator = QtWidgets.QTreeWidgetItemIterator(self.tree_widget)
        while iterator.value():
            item = iterator.value()
            if item.flags() & QtCore.Qt.ItemIsUserCheckable: item.setCheckState(0, QtCore.Qt.Unchecked)
            iterator += 1
        self.update_token_counter()
    def get_selected_files(self):
        selected = []; iterator = QtWidgets.QTreeWidgetItemIterator(self.tree_widget)
        while iterator.value():
            item = iterator.value()
            if item.checkState(0) == QtCore.Qt.Checked:
                file_path = item.data(0, QtCore.Qt.UserRole)
                if file_path and os.path.isfile(file_path): selected.append(file_path)
            iterator += 1
        return selected
    def process_selected(self):
        self.action = 'process'
        selected_files = self.get_selected_files()
        chosen_fmt = self.format_combo.currentData()
        prompt = self.prompt_textbox.toPlainText().strip()

        if process_files(selected_files, "fullcode.txt", fmt=chosen_fmt, prompt=prompt) > 0:
            output_path = os.path.join(os.getcwd(), "fullcode.txt")
            
            # Now, just read the final content for the clipboard
            with open(output_path, "r", encoding="utf-8") as f:
                content = f.read()

            QtWidgets.QApplication.clipboard().setText(content)
            logging.info(f"Copied {len(content)} chars to clipboard.")
            self.text_label.setStyleSheet("font-size: 20px; color: #00c3ff; font-weight: bold;")
            self.text_label.setText("Copied to clipboard and fullcode.txt")
            QtCore.QTimer.singleShot(1500, self.close)
            if self.remember_checkbox and self.remember_checkbox.isChecked():
                self.save_prefs()
        else:
            self.close()
    def quit_without_processing(self): self.action = 'quit'; self.close()
    def update_token_counter(self):
        total_tokens = 0
        for file_path in self.get_selected_files():
            if file_path not in self.file_token_counts:
                try:
                    with open(file_path, "r", encoding="utf-8", errors="ignore") as f: text = f.read()
                    self.file_token_counts[file_path] = len(text) // 4
                except Exception: self.file_token_counts[file_path] = 0
            total_tokens += self.file_token_counts[file_path]
        self.total_tokens = total_tokens; self.token_label.setText(f"Estimated tokens: {total_tokens:,}")
    def auto_expand_checked_folders(self):
        """Auto-expand folders that contain checked files from preferences."""
        folders_to_expand = set()
        
        # Find all folders that should be expanded (containing checked files)
        for checked_path in self.checked_files_from_prefs:
            # Get all parent directories of checked files
            path_parts = checked_path.split(os.sep)
            for i in range(1, len(path_parts)):
                folder_path = os.sep.join(path_parts[:i])
                if folder_path and folder_path in self.path_to_item:
                    folders_to_expand.add(folder_path)
        
        # Expand the folders
        for folder_path in folders_to_expand:
            item = self.path_to_item[folder_path]
            self.tree_widget.expandItem(item)

    def auto_expand_common_folders(self):
        """Auto-expand common project folders on first load."""
        common_folders = ['src', 'lib', 'app', 'components', 'utils', 'helpers', 'models', 'views', 'controllers']
        
        for folder_name in common_folders:
            if folder_name in self.path_to_item:
                item = self.path_to_item[folder_name]
                self.tree_widget.expandItem(item)

    def load_from_prefs_button_clicked(self):
        if os.path.exists(_prefs_path()):
            self.load_prefs_if_exists()
            self.deselect_all()
            for rel_path, item in self.path_to_item.items():
                if rel_path in self.checked_files_from_prefs: item.setCheckState(0, QtCore.Qt.Checked)
            # Auto-expand folders after loading preferences
            self.auto_expand_checked_folders()
            self.text_label.setText("Loaded selection from .aicodeprep")
            self.update_token_counter()
        else: self.text_label.setText(".aicodeprep not found")

    def closeEvent(self, event):
        if self.action != 'process': self.action = 'quit'
        super(FileSelectionGUI, self).closeEvent(event)

    def load_prefs_if_exists(self):
        if os.path.exists(_prefs_path()):
            checked, window_size, _, presets = _read_prefs_file() # The _read_prefs_file returns 4 values, but only the first 3 are used here.
            self.checked_files_from_prefs = checked
            self.window_size_from_prefs = window_size
            self.prefs_loaded = True
            self.loaded_presets = presets # This will be None based on _read_prefs_file

    def save_prefs(self):
        checked_relpaths = []
        for rel_path, item in self.path_to_item.items():
            if item.checkState(0) == QtCore.Qt.Checked:
                checked_relpaths.append(rel_path)
        size = self.size()
        _write_prefs_file(checked_relpaths, window_size=(size.width(), size.height()))

    def toggle_dark_mode(self, state):
        self.is_dark_mode = bool(state)
        base_style = """
            QTreeView, QTreeWidget {
                outline: 2; /* Remove focus rectangle */
            }
        """
        if self.is_dark_mode:
            apply_dark_palette(self.app)
            checkbox_style = get_checkbox_style_dark()
        else:
            apply_light_palette(self.app)
            checkbox_style = get_checkbox_style_light()
        
        self.tree_widget.setStyleSheet(base_style + checkbox_style)

def show_file_selection_gui(files):
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])
    gui = FileSelectionGUI(files)
    gui.show()
    app.exec()
    return gui.action, gui.get_selected_files()

def _prefs_path(): return os.path.join(os.getcwd(), ".aicodeprep")
def _write_prefs_file(checked_relpaths, window_size=None, splitter_state=None, presets=None):
    try:
        with open(_prefs_path(), "w", encoding="utf-8") as f:
            f.write(f"# AICodePrep preferences file version {AICODEPREP_VERSION}\nversion={AICODEPREP_VERSION}\n\n")
            if window_size: f.write(f"[window]\nwidth={window_size[0]}\nheight={window_size[1]}\n\n")
            if checked_relpaths: f.write("[files]\n" + "\n".join(checked_relpaths) + "\n")
    except Exception as e: logging.warning(f"Could not write .aicodeprep: {e}")
def _read_prefs_file():
    checked, window_size, presets = set(), None, None # Initialize presets to None
    
    # Initialize temporary variables for window size parsing
    width_val, height_val = None, None 
    
    try:
        with open(_prefs_path(), "r", encoding="utf-8") as f:
            section = None
            for line in f.read().splitlines():
                if line.strip().startswith('[') and line.strip().endswith(']'):
                    section = line.strip()[1:-1]
                    continue
                if not section: continue # Skip lines before the first section header

                if section == "files":
                    if line.strip(): checked.add(line.strip())
                elif section == "window":
                    if line.startswith('width='):
                        try: width_val = int(line.split('=')[1])
                        except (ValueError, IndexError): pass
                    elif line.startswith('height='):
                        try: height_val = int(line.split('=')[1])
                        except (ValueError, IndexError): pass
            
            if width_val is not None and height_val is not None:
                window_size = (width_val, height_val)
                
    except FileNotFoundError:
        logging.info(".aicodeprep file not found, creating a new one on save.")
    except Exception as e:
        logging.error(f"Error reading .aicodeprep file: {e}")
    return checked, window_size, None, presets # Return None for splitter_state and presets

</code>

aicodeprep_gui_c\main.py:
<code>
import os
import sys
import argparse
import logging
from typing import List
from aicodeprep_gui_c.smart_logic import collect_all_files
from aicodeprep_gui_c.gui import show_file_selection_gui

# Configure logging with explicit console handler only
logger = logging.getLogger()

# Remove any existing handlers to prevent duplicate logging
for handler in logger.handlers:
    logger.removeHandler(handler)

logger.setLevel(logging.INFO)

# Create console handler
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
console_handler.setFormatter(formatter)

# Add handler to root logger
logger.addHandler(console_handler)

def main():
    parser = argparse.ArgumentParser(description="Concatenate code files into a single text file.")
    parser.add_argument("-n", "--no-copy", action="store_true",
                        help="Do NOT copy output to clipboard (default: copy to clipboard)")
    parser.add_argument("-o", "--output", default="fullcode.txt",
                        help="Output file name (default: fullcode.txt)")
    parser.add_argument("-d", "--debug", action="store_true",
                        help="Enable debug logging")
    parser.add_argument("directory", nargs="?", default=".",
                        help="Directory to process (default: current directory)")

    args = parser.parse_args()

    # Ensure Fusion style for QSS consistency
    from PySide6 import QtWidgets
    app = QtWidgets.QApplication.instance()
    if app is None:
        app = QtWidgets.QApplication(sys.argv)
    app.setStyle("Fusion")

    if args.debug:
        logger.setLevel(logging.DEBUG)
        console_handler.setLevel(logging.DEBUG)

    # Get the target directory from the parsed arguments
    target_dir = args.directory
    logger.info(f"Target directory: {target_dir}")

    # Change to the specified directory with error handling
    try:
        os.chdir(target_dir)
    except FileNotFoundError:
        logger.error(f"Directory not found: {target_dir}")
        return
    except Exception as e:
        logger.error(f"Error changing directory: {e}")
        return

    logger.info("Starting code concatenation...")

    all_files_with_flags = collect_all_files()

    if not all_files_with_flags:
        logger.warning("No files found to process!")
        return

    action, _ = show_file_selection_gui(all_files_with_flags)

    if action != 'quit':
        logger.info("Buy my cat a treat, comments, ideas for improvement appreciated: ")
        logger.info("https://wuu73.org/hello.html")

if __name__ == "__main__":
    main()

</code>

aicodeprep_gui_c\smart_logic.py:
<code>
from importlib import resources
import os
import sys
import logging
from typing import List, Tuple
import fnmatch

# New imports for the refactoring
import toml
from pathspec import PathSpec
from pathspec.patterns import GitWildMatchPattern

def get_config_path():
    """Get the path to the default configuration file."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
        config_path = os.path.join(base_path, 'aicodeprep_gui_c', 'data', 'default_config.toml')
    else:
        try:
            with resources.path('aicodeprep_gui_c.data', 'default_config.toml') as config_file:
                config_path = str(config_file)
        except ModuleNotFoundError:
            config_path = os.path.join(os.path.dirname(__file__), 'data', 'default_config.toml')
    return config_path

def load_config_from_path(path: str) -> dict:
    """Loads a TOML configuration file from a given path."""
    if not os.path.exists(path):
        return {}
    try:
        with open(path, "r", encoding="utf-8") as f:
            return toml.load(f)
    except Exception as e:
        logging.error(f"Error loading or parsing TOML config at {path}: {e}")
        return {}

def load_configurations() -> dict:
    """Load default config, then load user config and merge them."""
    default_config_path = get_config_path()
    config = load_config_from_path(default_config_path)
    if not config:
        logging.critical("Failed to load default configuration. Exiting.")
        sys.exit("Could not load the default configuration file.")
    user_config_path = os.path.join(os.getcwd(), 'aicodeprep.toml')
    user_config = load_config_from_path(user_config_path)
    if user_config:
        logging.info(f"Found user configuration at {user_config_path}. Merging settings.")
        config.update(user_config)
    return config

def is_binary_file(filepath: str) -> bool:
    """Return True if this file is likely binary."""
    try:
        with open(filepath, 'rb') as f: chunk = f.read(1024)
    except OSError: return False
    if chunk.startswith((b'\xEF\xBB\xBF', b'\xFF\xFE', b'\xFE\xFF', b'\xFF\xFE\x00\x00', b'\x00\x00\xFE\xFF')): return False
    return b'\x00' in chunk

# --- CONFIG AND PATHSPEC LOADING ---
config = load_configurations()
CODE_EXTENSIONS = set(config.get('code_extensions', []))
MAX_FILE_SIZE = config.get('max_file_size', 1000000)
exclude_spec = PathSpec.from_lines(GitWildMatchPattern, config.get('exclude_patterns', []))
include_spec = PathSpec.from_lines(GitWildMatchPattern, config.get('default_include_patterns', []))
# These are still useful for some simple checks in the GUI and logic
EXCLUDE_DIRS = [p.rstrip('/') for p in config.get('exclude_patterns', []) if p.endswith('/')]
EXCLUDE_FILES = [p for p in config.get('exclude_patterns', []) if not p.endswith('/')]
EXCLUDE_PATTERNS = EXCLUDE_FILES # Simplified for backward compatibility
INCLUDE_FILES = config.get('default_include_patterns', [])
INCLUDE_DIRS = [p.rstrip('/') for p in INCLUDE_FILES if p.endswith('/')]
EXCLUDE_EXTENSIONS = [] # This concept is now handled by patterns

# --- REWRITTEN collect_all_files FOR LAZY LOADING ---
def collect_all_files() -> List[Tuple[str, str, bool]]:
    """
    Collects files and directories. For excluded directories, it returns them as
    a single entry without their contents, allowing the GUI to lazy-load them.
    Returns a list of (absolute_path, relative_path, is_checked_by_default).
    """
    all_paths = []
    root_dir = os.getcwd()
    seen_paths = set()
    logging.info(f"Starting initial fast scan in: {root_dir}")

    for root, dirs, files in os.walk(root_dir, topdown=True):
        rel_root = os.path.relpath(root, root_dir)
        if rel_root == '.': rel_root = ''

        # Add the directory itself unless it's the root
        if rel_root and root not in seen_paths:
             all_paths.append((root, rel_root, False))
             seen_paths.add(root)

        # Prune directories from the walk
        dirs_to_prune = []
        for d in dirs:
            rel_dir_path = os.path.join(rel_root, d)
            if exclude_spec.match_file(rel_dir_path + '/'):
                dirs_to_prune.append(d)
        dirs[:] = [d for d in dirs if d not in dirs_to_prune]

        # Process all items (unpruned dirs and files)
        for name in dirs + files:
            abs_path = os.path.join(root, name)
            rel_path = os.path.join(rel_root, name)
            if abs_path in seen_paths: continue

            # Determine default check state
            is_checked = False
            check_path = rel_path + '/' if os.path.isdir(abs_path) else rel_path

            if include_spec.match_file(check_path):
                is_checked = True
            elif os.path.isfile(abs_path) and os.path.splitext(name)[1].lower() in CODE_EXTENSIONS:
                 is_checked = True

            # Final filters for files
            if os.path.isfile(abs_path):
                if is_binary_file(abs_path) or os.path.getsize(abs_path) > MAX_FILE_SIZE:
                    is_checked = False

            all_paths.append((abs_path, rel_path, is_checked))
            seen_paths.add(abs_path)

    logging.info(f"Initial scan collected {len(all_paths)} items.")
    return all_paths

def is_excluded_directory(path: str) -> bool:
    """Simplified check used by GUI folder-click logic."""
    dir_name = os.path.basename(path)
    return any(fnmatch.fnmatch(dir_name, pat) for pat in EXCLUDE_DIRS)

def matches_pattern(filename: str, pattern: str) -> bool:
    """Helper used by GUI logic."""
    return fnmatch.fnmatch(filename.lower(), pattern.lower())

</code>

aicodeprep_gui_c\__init__.py:
<code>
from .main import main
</code>

pyproject.toml:
<code>
[build-system]
requires = ["setuptools>=61.0.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "aicodeprep_gui_c"
version = "0.9.8"
description = "Prepare code for AI chatbot assistance"
readme = "README.md"
authors = [{ name = "Tom Brothers", email = "wuu73@yahoo.com" }]
license = { file = "LICENSE" }
classifiers = [
    "License :: Proprietary",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3",
]
keywords = ["ai", "code", "preparation", "chatbot"]
dependencies = [
    "PySide6>=6.7",
    "toml",
    "pathspec"
]
requires-python = ">=3.6"

[project.scripts]
aicodeprep_gui_c = "aicodeprep_gui_c.main:main" # Use an underscore here

[project.urls]
Homepage = "https://github.com/detroittommy879/aicodeprep"

[tool.setuptools.packages.find]
where = ["."]

[tool.setuptools.package-data]
aicodeprep_gui_c = ["data/default_config.toml"]

</code>

requirements.txt:
<code>
altgraph==0.17.4
certifi==2025.4.26
charset-normalizer==3.4.1
idna==3.10
packaging==25.0
pefile==2023.2.7
pyinstaller==6.13.0
pyinstaller-hooks-contrib==2025.3
pyperclip==1.8.2
PySide6==6.8.1
PySide6_Addons==6.8.1
PySide6_Essentials==6.8.1
pywin32-ctypes==0.2.3
regex==2024.11.6
requests==2.32.3
shiboken6==6.8.1
urllib3==2.4.0
toml
pathspec

</code>



Can you help me debug this code?

.. some other files were skipped ..
