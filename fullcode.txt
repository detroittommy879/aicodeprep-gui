can you analyze the code, the changelog, and then update it for 1.0.6? i forgot to keep track, but a lot of it was minor bug fixes, fixed mac finder menu method etc

aicodeprep_gui\data\default_config.toml:
<code>
# aicodeprep-gui - Default Configuration File
# This file provides the baseline settings for file filtering.
# You can override these settings by creating an `aicodeprep-gui.toml` file
# in your project's root directory.
#
# This file uses the TOML format.
# All exclusion/inclusion patterns use the same syntax as a .gitignore file.
# - A trailing slash '/' matches a directory (e.g., "build/").
# - A leading '!' negates a pattern, re-including a file if it was excluded by a previous pattern.
# - Wildcards like '*' are supported.

max_file_size = 4000000

# File extensions that are considered code and will be checked by default.
# Grouped by category for easier review.
code_extensions = [
    # -- Web & Frontend --
    ".html", ".css", ".scss", ".sass", ".less", ".js", ".jsx", ".ts", ".tsx",
    ".vue", ".svelte", ".astro",

    # -- Backend & General Purpose --
    ".py", ".java", ".c", ".cpp", ".h", ".cs", ".php", ".rb", ".go", ".rs",
    ".swift", ".kt", ".scala", ".r", ".m", ".pl", ".lua", ".dart", ".erl",
    ".ex", ".exs", ".clj",

    # -- Scripts & Shell --
    ".sh", ".bash", ".zsh", ".ps1", ".psm1", ".groovy",

    # -- Data & Markup --
    ".json", ".xml", ".yaml", ".yml", ".toml", ".ini", ".md", ".sql", ".csv",
    ".tsv",

    # -- Config & Build --
    ".conf", ".cfg", ".properties", ".gradle", ".f90", ".f95", ".f03", ".f08",
    ".editorconfig", "Dockerfile", ".env.example", ".env.sample", "Jenkinsfile",
    
    # -- Notebooks & Text --
    ".ipynb", ".txt",

    # -- Lock files (sometimes useful for context, but often excluded below) --
    ".lock",
]

# --- UNIFIED INCLUSION/EXCLUSION LISTS using .gitignore syntax ---

# Patterns for files/dirs to be checked *by default*.
# These are high-value files that provide critical context about a project.
default_include_patterns = [
    # Core project documentation
    "README.md",
    "CONTRIBUTING.md",
    "CHANGELOG.md",
    "LICENSE",
    "CODE_OF_CONDUCT.md",

    # Core project definition files
    "pyproject.toml",
    "package.json",
    "requirements.txt",
    "pom.xml",
    "build.gradle",
    "Gemfile",
    "go.mod",
    "Cargo.toml",
    "composer.json",

    # Environment and containerization
    "Dockerfile",
    "docker-compose.yml",
    ".env.example",
    ".env.sample",

    # Important configuration or documentation
    "important.txt",
    "important_docs/",
]

# Patterns for files/dirs to be excluded from the GUI list or unchecked by default.
# Grouped by category for clarity.
exclude_patterns = [
    # -- Version Control --
    ".git/",
    ".svn/",
    ".hg/",

    # -- Dependency & Package Manager Directories --
    "node_modules/",
    "bower_components/",
    "vendor/",
    "deps/", # Elixir

    # -- Python-specific --
    "venv/",
    ".venv/",
    "__pycache__/",
    "Lib/",
    "site-packages/",
    "*.egg-info/",
    ".tox/",

    # -- IDE & Editor Directories --
    ".idea/",
    ".vscode/",
    ".project",
    ".classpath",
    ".settings/",
    "nbproject/", # Netbeans
    "*.sublime-project",
    "*.sublime-workspace",

    # -- Build, Dist & Compilation Output --
    "build/",
    "dist/",
    "dist-ssr/",
    "bin/",
    "obj/",
    "out/",
    "target/",
    "_build/", # Elixir, Erlang
    "*.o",
    "*.pyc",
    "*.class",
    "*.exe",
    "*.dll",
    "*.so",
    "*.dylib",
    "*.jar",
    "*.war",
    "*.ear",

    # -- Framework & Tool Caches/Builds --
    ".parcel-cache/",
    ".next/",
    ".nuxt/",
    ".svelte-kit/",
    ".docusaurus/",
    ".angular/",
    ".quasar/",
    ".redwood/",
    ".fusebox/",
    ".expo/",
    ".serverless/",
    ".vercel/",
    ".dart_tool/",
    ".elixir_ls/",

    # -- Test, Coverage & Report Artifacts --
    "coverage/",
    "reports/",
    "test-results/",
    "test-reports/",
    "playwright-report/",
    "junit.xml",
    "coverage.xml",
    "*.lcov",
    ".pytest_cache/",
    ".mypy_cache/",
    ".nyc_output/",
    ".jest/",
    "*snapshots*/",

    # -- Logs & Temporary Files --
    "logs/",
    "tmp/",
    "temp/",
    "cache/",
    ".cache/",
    "*.log",
    "*.log.*",
    "npm-debug.log*",
    "yarn-error.log",
    "*.swp",
    "*.swo",
    "*.un~",
    "~$*",
    "*.temp",

    # -- OS & System Files --
    ".DS_Store",
    "Thumbs.db",
    "desktop.ini",

    # -- Lock files (usually not needed as they are machine-generated) --
    "package-lock.json",
    "yarn.lock",
    "Gemfile.lock",
    "composer.lock",
    "pnpm-lock.yaml",
    "bun.lockb",
    "cargo.lock",
    "poetry.lock",
    "Pipfile.lock",

    # -- Secrets, Keys & Sensitive Environment Files --
    ".npmrc",
    ".env",
    ".env.*",
    "!.env.example", # Re-include example files if they were excluded by .env.*
    "!.env.sample",
    ".flaskenv",
    ".dockerenv",
    "env.json",
    "credentials.yaml",
    "secret*.json",
    "*.key",
    "*.pem",
    "*.crt",
    "*.pub",
    "id_rsa",
    "id_dsa",

    # -- Terraform State --
    ".terraform/",
    ".terraform.lock.hcl",
    "terraform.tfstate",
    "terraform.tfstate.backup",

    # -- General Generated & Minified Patterns --
    "*generated*",
    "*.min.js",
    "*.min.css",
    "*.min.*",
    "*bundle.js",
    "*chunk.js",
    "*.snap", # Jest snapshots
    "*.test.",
    ".spec.",
    ".bench.",

]

</code>

aicodeprep_gui\images\__init__.py:
<code>

</code>

aicodeprep_gui\apptheme.py:
<code>
from PySide6 import QtCore, QtGui, QtWidgets
import platform
import os
import sys
import ctypes
import json
import logging
from importlib import resources

def system_pref_is_dark() -> bool:
    """Detect if system is using dark mode."""
    system = platform.system()
    
    if system == "Darwin":  # macOS
        try:
            import subprocess
            cmd = "defaults read -g AppleInterfaceStyle"
            result = subprocess.run(cmd, shell=True, text=True, capture_output=True)
            return result.stdout.strip() == "Dark"
        except:
            pass
    
    elif system == "Windows":  # Windows 10+
        try:
            import winreg
            registry = winreg.ConnectRegistry(None, winreg.HKEY_CURRENT_USER)
            reg_keypath = r"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize"
            key = winreg.OpenKey(registry, reg_keypath)
            value, _ = winreg.QueryValueEx(key, "AppsUseLightTheme")
            return value == 0
        except:
            pass
    
    # Fallback: use palette heuristic
    return QtWidgets.QApplication.palette().color(QtGui.QPalette.Window).lightness() < 128

def apply_dark_palette(app: QtWidgets.QApplication):
    """Apply dark color palette to application."""
    dark = QtGui.QPalette()
    dark.setColor(QtGui.QPalette.Window, QtGui.QColor(53, 53, 53))
    dark.setColor(QtGui.QPalette.WindowText, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Base, QtGui.QColor(42, 42, 42))
    dark.setColor(QtGui.QPalette.AlternateBase, QtGui.QColor(66, 66, 66))
    dark.setColor(QtGui.QPalette.ToolTipBase, QtGui.QColor(53, 53, 53))
    dark.setColor(QtGui.QPalette.ToolTipText, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Text, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Button, QtGui.QColor(53, 53, 53))
    dark.setColor(QtGui.QPalette.ButtonText, QtGui.QColor(255, 255, 255))
    dark.setColor(QtGui.QPalette.Link, QtGui.QColor(42, 130, 218))
    dark.setColor(QtGui.QPalette.Highlight, QtGui.QColor(42, 130, 218))
    dark.setColor(QtGui.QPalette.HighlightedText, QtGui.QColor(255, 255, 255))
    
    # Disabled colors
    dark.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.Text, QtGui.QColor(128, 128, 128))
    dark.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, QtGui.QColor(128, 128, 128))
    dark.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, QtGui.QColor(128, 128, 128))
    
    app.setPalette(dark)

def apply_light_palette(app: QtWidgets.QApplication):
    """Apply light color palette to application."""
    light = QtGui.QPalette()
    light.setColor(QtGui.QPalette.Window, QtGui.QColor(240, 240, 240))
    light.setColor(QtGui.QPalette.WindowText, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Base, QtGui.QColor(255, 255, 255))
    light.setColor(QtGui.QPalette.AlternateBase, QtGui.QColor(233, 233, 233))
    light.setColor(QtGui.QPalette.ToolTipBase, QtGui.QColor(255, 255, 255))
    light.setColor(QtGui.QPalette.ToolTipText, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Text, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Button, QtGui.QColor(240, 240, 240))
    light.setColor(QtGui.QPalette.ButtonText, QtGui.QColor(0, 0, 0))
    light.setColor(QtGui.QPalette.Link, QtGui.QColor(0, 0, 255))
    light.setColor(QtGui.QPalette.Highlight, QtGui.QColor(42, 130, 218))
    light.setColor(QtGui.QPalette.HighlightedText, QtGui.QColor(255, 255, 255))
    
    # Disabled colors
    light.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.Text, QtGui.QColor(120, 120, 120))
    light.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, QtGui.QColor(120, 120, 120))
    light.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, QtGui.QColor(120, 120, 120))
    
    app.setPalette(light)

def create_checkmark_pixmap(size=16, color="#0078D4"):
    """Create a checkmark pixmap programmatically."""
    pixmap = QtGui.QPixmap(size, size)
    pixmap.fill(QtCore.Qt.transparent)
    
    painter = QtGui.QPainter(pixmap)
    painter.setRenderHint(QtGui.QPainter.Antialiasing)
    
    pen = QtGui.QPen(QtGui.QColor(color))
    pen.setWidth(2)
    pen.setCapStyle(QtCore.Qt.RoundCap)
    pen.setJoinStyle(QtCore.Qt.RoundJoin)
    painter.setPen(pen)
    
    # Draw checkmark
    painter.drawLine(4, 8, 7, 11)
    painter.drawLine(7, 11, 12, 4)
    
    painter.end()
    return pixmap

def create_x_mark_pixmap(size=16, color="#0078D4"):
    """Create an X mark pixmap programmatically (alternative to checkmark)."""
    pixmap = QtGui.QPixmap(size, size)
    pixmap.fill(QtCore.Qt.transparent)
    
    painter = QtGui.QPainter(pixmap)
    painter.setRenderHint(QtGui.QPainter.Antialiasing)
    
    pen = QtGui.QPen(QtGui.QColor(color))
    pen.setWidth(2)
    pen.setCapStyle(QtCore.Qt.RoundCap)
    painter.setPen(pen)
    
    # Draw X mark
    margin = 3
    painter.drawLine(margin, margin, size-margin, size-margin)
    painter.drawLine(margin, size-margin, size-margin, margin)
    
    painter.end()
    return pixmap

def _checkbox_style_with_images(dark: bool) -> str:
    """Use SVG-based checkboxes - same as _checkbox_style but with descriptive name."""
    return _checkbox_style(dark)



def _checkbox_style(dark: bool) -> str:
    """Return checkbox styling using packaged image files."""
    
    # Use appropriate images for theme
    if dark:
        unchecked_filename = "checkbox_unchecked_dark.png"
        checked_filename = "checkbox_checked_dark.png"
    else:
        unchecked_filename = "checkbox_unchecked.png"
        checked_filename = "checkbox_checked.png"
    
    # --- THIS IS THE NEW, PACKAGE-SAFE WAY TO FIND FILES ---
    try:
        # 'aicodeprep_gui.images' corresponds to the aicodeprep_gui/images folder
        with resources.as_file(resources.files('aicodeprep_gui.images').joinpath(unchecked_filename)) as p:
            unchecked_path = str(p)
        with resources.as_file(resources.files('aicodeprep_gui.images').joinpath(checked_filename)) as p:
            checked_path = str(p)
    except Exception as e:
        # Fallback or error logging if resources can't be found
        logging.error(f"Could not load checkbox images: {e}")
        return "" # Return empty style if images fail to load
    # --- END OF THE NEW SECTION ---

    # The rest of the function is the same as before
    # Convert Windows paths to proper URLs for Qt
    if os.name == 'nt':  # Windows
        unchecked_url = unchecked_path.replace('\\', '/')
        checked_url = checked_path.replace('\\', '/')
    else:
        unchecked_url = unchecked_path
        checked_url = checked_path
    
    hover_border_color = "#00c3ff"
    
    return f"""
    QTreeView::indicator, QTreeWidget::indicator {{
        width: 16px;
        height: 16px;
        border: none;
        background: transparent;
        image: url({unchecked_url});
    }}
    
    QTreeView::indicator:checked, QTreeWidget::indicator:checked {{
        image: url({checked_url});
    }}
    
    QTreeView::indicator:hover, QTreeWidget::indicator:hover {{
        border: 1px solid {hover_border_color};
        border-radius: 2px;
    }}
    
    QTreeView::indicator:checked:hover, QTreeWidget::indicator:checked:hover {{
        border: 1px solid {hover_border_color};
        border-radius: 2px;
        image: url({checked_url});
    }}
    """

def get_checkbox_style_dark()  -> str: 
    return _checkbox_style(True)

def get_checkbox_style_light() -> str: 
    return _checkbox_style(False)

</code>

aicodeprep_gui\file_processor.py:
<code>
import os
import sys
import logging
from typing import List, Literal

OutputFmt = Literal['xml', 'markdown']

def _write_one_file_xml(outfile, rel_path, abs_path, skip_binfiles=None):
    if is_binary_file(abs_path):
        if skip_binfiles is not None:
            skip_binfiles.append(rel_path)
        return
    outfile.write(f"{rel_path}:\n<code>\n")
    try:
        with open(abs_path, "r", encoding="utf-8", errors="ignore") as infile:
            outfile.write(infile.read())
    except Exception:
        outfile.write(".. contents skipped (read error) ..")
    outfile.write("\n</code>\n\n")

from aicodeprep_gui.smart_logic import is_binary_file

def _write_one_file_md(outfile, rel_path, abs_path, skip_binfiles=None):
    if is_binary_file(abs_path):
        if skip_binfiles is not None:
            skip_binfiles.append(rel_path)
        return
    outfile.write(f"### START OF FILE {rel_path} ###\n")
    try:
        with open(abs_path, "r", encoding="utf-8", errors="ignore") as infile:
            outfile.write(infile.read())
    except Exception:
        outfile.write(".. contents skipped (read error) ..\n")
    outfile.write(f"\n### END OF FILE {rel_path} ###\n\n")

def process_files(
    selected_files: List[str],
    output_file: str,
    fmt: OutputFmt = 'xml',
    prompt: str = "",
    prompt_to_top: bool = False,
    prompt_to_bottom: bool = True
) -> int:
    """
    Process selected files and write their contents to output_file.
    Optionally prepend and/or append a prompt/question.
    Returns the number of files processed.
    """
    try:
        output_path = os.path.join(os.getcwd(), output_file)
        logging.info(f"Writing output to: {output_path}")

        skip_binfiles = []
        writer = _write_one_file_xml if fmt == 'xml' else _write_one_file_md

        with open(output_path, 'w', encoding='utf-8') as outfile:
            # Write prompt at the top if requested
            if prompt and prompt_to_top:
                outfile.write(prompt.strip() + "\n\n")

            for file_path in selected_files:
                try:
                    try:
                        rel_path = os.path.relpath(file_path, os.getcwd())
                    except ValueError:
                        rel_path = file_path
                    writer(outfile, rel_path, file_path, skip_binfiles=skip_binfiles)
                    logging.info(f"Processed: {rel_path}")
                except Exception as exc:
                    logging.error(f"Error processing {file_path}: {exc}")

            if skip_binfiles:
                outfile.write("\n")
                for rel_path in skip_binfiles:
                    outfile.write(f"{rel_path} binary file skipped..\n")

            # Write prompt at the bottom if requested
            if prompt and prompt_to_bottom:
                outfile.write("\n\n" + prompt.strip())

        return len(selected_files)
    except Exception as exc:
        logging.error(f"Error writing output file: {exc}")
        return 0

</code>

aicodeprep_gui\gui.py:
<code>
import os
import sys
import platform
import logging
import uuid
from datetime import datetime, date
from PySide6 import QtWidgets, QtCore, QtGui, QtNetwork
from aicodeprep_gui import __version__
from aicodeprep_gui import update_checker
from PySide6 import QtWidgets, QtCore, QtGui, QtNetwork
from importlib import resources
from aicodeprep_gui.apptheme import system_pref_is_dark, apply_dark_palette, apply_light_palette, get_checkbox_style_dark, get_checkbox_style_light
from typing import List, Tuple
from aicodeprep_gui import smart_logic
from aicodeprep_gui.file_processor import process_files
from aicodeprep_gui import __version__

class FlowLayout(QtWidgets.QLayout):
    def __init__(self, parent=None, margin=-1, hspacing=-1, vspacing=-1):
        super(FlowLayout, self).__init__(parent)
        self._items = []
        self.setContentsMargins(margin, margin, margin, margin)
        self._hspacing = hspacing
        self._vspacing = vspacing

    def __del__(self):
        del self._items[:]

    def addItem(self, item):
        self._items.append(item)
        self.invalidate()

    def horizontalSpacing(self):
        if self._hspacing >= 0:
            return self._hspacing
        return self.smartSpacing(QtWidgets.QStyle.PM_LayoutHorizontalSpacing)

    def verticalSpacing(self):
        if self._vspacing >= 0:
            return self._vspacing
        return self.smartSpacing(QtWidgets.QStyle.PM_LayoutVerticalSpacing)

    def count(self):
        return len(self._items)

    def itemAt(self, index):
        if 0 <= index < len(self._items):
            return self._items[index]
        return None

    def takeAt(self, index):
        if 0 <= index < len(self._items):
            item = self._items.pop(index)
            self.invalidate()
            return item
        return None
        
    def insertWidget(self, index, widget):
        self.insertItem(index, QtWidgets.QWidgetItem(widget))

    def insertItem(self, index, item):
        self._items.insert(index, item)
        self.invalidate()

    def removeWidget(self, widget):
        for i, item in enumerate(self._items):
            if item.widget() is widget:
                self.takeAt(i)
                # Do not delete the widget, the caller is responsible
                break
    
    def expandingDirections(self):
        return QtCore.Qt.Orientation(0)

    def hasHeightForWidth(self):
        return True

    def heightForWidth(self, width):
        return self.doLayout(QtCore.QRect(0, 0, width, 0), True)

    def setGeometry(self, rect):
        super(FlowLayout, self).setGeometry(rect)
        self.doLayout(rect, False)

    def sizeHint(self):
        return self.minimumSize()

    def minimumSize(self):
        size = QtCore.QSize()
        for item in self._items:
            size = size.expandedTo(item.minimumSize())
        margins = self.contentsMargins()
        size += QtCore.QSize(margins.left() + margins.right(), margins.top() + margins.bottom())
        return size

    def doLayout(self, rect, testOnly):
        m = self.contentsMargins()
        x = rect.x() + m.left()
        y = rect.y() + m.top()
        lineHeight = 0

        spaceX = self.horizontalSpacing()
        spaceY = self.verticalSpacing()

        for item in self._items:
            nextX = x + item.sizeHint().width() + spaceX
            if nextX - spaceX > rect.right() - m.right() and lineHeight > 0:
                x = rect.x() + m.left()
                y = y + lineHeight + spaceY
                lineHeight = 0
            
            if not testOnly:
                item.setGeometry(QtCore.QRect(QtCore.QPoint(x, y), item.sizeHint()))

            x = x + item.sizeHint().width() + spaceX
            lineHeight = max(lineHeight, item.sizeHint().height())

        return y + lineHeight + m.bottom()

    def smartSpacing(self, pm):
        parent = self.parent()
        if not parent:
            return -1
        if parent.isWidgetType():
            return parent.style().pixelMetric(pm, None, parent)
        else:
            return parent.spacing()

# Version for .aicodeprep-gui file format
AICODEPREP_GUI_VERSION = "1.0"

# Default presets for button prompts (label, text)
DEFAULT_PRESETS = [
    ("Debug", "Can you help me debug this code?"),
    ("Security check", "Can you analyze this code for any security issues?"),
    ("Best Practices", "Please analyze this code for: Error handling, Edge cases, Performance optimization, Best practices, Please do not unnecessarily remove any comments or code. Generate the code with clear comments explaining the logic."),
    ("Please review for", "Code quality and adherence to best practices, Potential bugs or edge cases, Performance optimizations, Readability and maintainability, Security concerns. Suggest improvements and explain your reasoning for each suggestion"),
    ("Cline, Roo Code Prompt", "Write a prompt for Cline, an AI coding agent, to make the necessary changes. Enclose the entire Cline prompt in one single code tag for easy copy and paste.")
]

class GlobalPresetManager:
    PRESET_SCHEMA_VERSION = 1

    def __init__(self):
        try:
            self.settings = QtCore.QSettings("aicodeprep-gui", "ButtonPresets")
            self._ensure_default_presets()
        except Exception as e:
            logging.error(f"Failed to initialize global preset manager: {e}")
            self.settings = None

    def _ensure_default_presets(self):
        """
        Ensure default presets are present and up-to-date.
        If the preset schema version is outdated, update only the default presets.
        Custom user presets are preserved.
        """
        try:
            if not self.settings:
                return

            # Read last schema version from QSettings (internal group)
            self.settings.beginGroup("internal")
            last_version = self.settings.value("preset_version", 0, type=int)
            self.settings.endGroup()

            if last_version >= self.PRESET_SCHEMA_VERSION:
                return  # No update needed

            logging.info(f"Updating default button presets (schema version {last_version} -> {self.PRESET_SCHEMA_VERSION})")

            # Overwrite only the default presets in the "presets" group
            self.settings.beginGroup("presets")
            for label, text in DEFAULT_PRESETS:
                self.settings.setValue(label, text)
            self.settings.endGroup()

            # Update the stored schema version
            self.settings.beginGroup("internal")
            self.settings.setValue("preset_version", self.PRESET_SCHEMA_VERSION)
            self.settings.endGroup()

            logging.info("Default button presets updated successfully.")
        except Exception as e:
            logging.error(f"Failed to update default presets: {e}")

    def get_all_presets(self):
        """Get all saved presets as list of (label, text) tuples"""
        try:
            if not self.settings: return []
            presets = []
            self.settings.beginGroup("presets")
            for key in self.settings.childKeys():
                presets.append((key, self.settings.value(key, "")))
            self.settings.endGroup()
            return presets
        except Exception as e:
            logging.error(f"Failed to get presets: {e}")
            return []
    
    def add_preset(self, label, text):
        try:
            if not self.settings or not label.strip() or not text.strip(): return False
            self.settings.beginGroup("presets")
            self.settings.setValue(label.strip(), text.strip())
            self.settings.endGroup()
            return True
        except Exception as e:
            logging.error(f"Failed to add preset '{label}': {e}")
            return False
    
    def delete_preset(self, label):
        try:
            if not self.settings or not label.strip(): return False
            self.settings.beginGroup("presets")
            self.settings.remove(label.strip())
            self.settings.endGroup()
            return True
        except Exception as e:
            logging.error(f"Failed to delete preset '{label}': {e}")
            return False

global_preset_manager = GlobalPresetManager()

class FileSelectionGUI(QtWidgets.QMainWindow):
    def open_settings_folder(self):
        """Open the folder containing the .aicodeprep-gui settings file in the system file explorer."""
        folder_path = os.getcwd()
        if sys.platform.startswith("win"):
            os.startfile(folder_path)
        elif sys.platform.startswith("darwin"):
            import subprocess
            subprocess.Popen(["open", folder_path])
        else:
            import subprocess
            subprocess.Popen(["xdg-open", folder_path])

    def __init__(self, files, force_update=False):
        super().__init__()
        self.force_update = force_update
        self.initial_show_event = True
        # Set application icon
        try:
            with resources.path('aicodeprep_gui.images', 'favicon.ico') as icon_path:
                app_icon = QtGui.QIcon(str(icon_path))
            self.setWindowIcon(app_icon)
            # Add system tray icon with context menu
            from PySide6.QtWidgets import QSystemTrayIcon, QMenu
            from PySide6.QtGui import QAction
            tray = QSystemTrayIcon(app_icon, parent=self)
            # build a minimal context menu
            menu = QMenu()
            show_act = QAction("Show", self)
            quit_act = QAction("Quit", self)
            show_act.triggered.connect(self.show)
            quit_act.triggered.connect(self.quit_without_processing)
            menu.addAction(show_act)
            menu.addSeparator()
            menu.addAction(quit_act)
            tray.setContextMenu(menu)
            tray.show()
            self.tray_icon = tray  # keep a reference so it doesn't get garbage‐collected
        except FileNotFoundError:
            logging.warning("Application icon 'favicon.ico' not found in package resources.")

        self.presets = [] # This local 'presets' list is not used for global presets, but for local ones (which are not saved to the .aicodeprep-gui file, but managed by global_preset_manager through QSettings)
        self.setAcceptDrops(True)
        self.files = files
        self.latest_pypi_version = None

        # Get or create anonymous user UUID
        settings = QtCore.QSettings("aicodeprep-gui", "UserIdentity")
        user_uuid = settings.value("user_uuid")
        if not user_uuid:
            import uuid
            user_uuid = str(uuid.uuid4())
            settings.setValue("user_uuid", user_uuid)
            logging.info(f"Generated new anonymous user UUID: {user_uuid}")

        # --- Store install date if first run ---
        install_date_str = settings.value("install_date")
        if not install_date_str:
            # store ISO date on first launch
            today_iso = date.today().isoformat()
            settings.setValue("install_date", today_iso)
            install_date_str = today_iso
        logging.debug(f"Stored install_date: {install_date_str}")

        from datetime import datetime
        self.network_manager = QtNetwork.QNetworkAccessManager(self)
        now = datetime.now()
        time_str = f"{now.strftime('%I').lstrip('0') or '12'}{now.strftime('%M')}{now.strftime('%p').lower()}"
        request = QtNetwork.QNetworkRequest(QtCore.QUrl(f"https://wuu73.org/dixels/newaicp.html?t={time_str}&user={user_uuid}"))
        self.network_manager.get(request)

        # --- Schedule update checker (non-blocking, after telemetry) ---
        self.update_thread = None

        self.setWindowTitle("aicodeprep-gui - File Selection")
        self.app = QtWidgets.QApplication.instance()
        if self.app is None:
            self.app = QtWidgets.QApplication([])
        self.action = 'quit'

        self.prefs_filename = ".aicodeprep-gui"
        self.remember_checkbox = None 
        self.checked_files_from_prefs = set()
        self.prefs_loaded = False
        self.window_size_from_prefs = None
        self.splitter_state_from_prefs = None # Initialize this attribute
        self.load_prefs_if_exists()

        if platform.system() == 'Windows':
            scale_factor = self.app.primaryScreen().logicalDotsPerInch() / 96.0
        else:
            scale_factor = self.app.primaryScreen().devicePixelRatio()

        default_font_size = 9
        font_stack = '"Segoe UI", "Ubuntu", "Helvetica Neue", Arial, sans-serif'
        default_font_size = int(default_font_size * scale_factor)
        self.default_font = QtGui.QFont("Segoe UI", default_font_size)
        self.setFont(self.default_font)
        self.setStyleSheet(f"font-family: {font_stack};")
        style = self.style()
        self.folder_icon = style.standardIcon(QtWidgets.QStyle.SP_DirIcon)
        self.file_icon = style.standardIcon(QtWidgets.QStyle.SP_FileIcon)

        if self.window_size_from_prefs:
            w, h = self.window_size_from_prefs
            self.setGeometry(100, 100, w, h)
        else:
            self.setGeometry(100, 100, int(600 * scale_factor), int(400 * scale_factor))

        self.is_dark_mode = self._load_dark_mode_setting()
        if self.is_dark_mode: apply_dark_palette(self.app)

        central = QtWidgets.QWidget()
        self.setCentralWidget(central)
        main_layout = QtWidgets.QVBoxLayout(central)
        main_layout.setContentsMargins(20, 10, 20, 10)

        mb = self.menuBar()
        file_menu = mb.addMenu("&File")

        # Add this new block for the Windows-only menu item
        if platform.system() == "Windows":
            from aicodeprep_gui import windows_registry
            class RegistryManagerDialog(QtWidgets.QDialog):
                def __init__(self, parent=None):
                    super().__init__(parent)
                    self.setWindowTitle("Windows Context Menu Manager")
                    self.setMinimumWidth(450)
                    
                    self.layout = QtWidgets.QVBoxLayout(self)
                    
                    info_text = (
                        "This tool can add or remove a right-click context menu item in "
                        "Windows Explorer to open `aicodeprep-gui` in any folder.<br><br>"
                        "<b>Note:</b> This operation requires administrator privileges. "
                        "A UAC prompt will appear."
                    )
                    self.info_label = QtWidgets.QLabel(info_text)
                    self.info_label.setWordWrap(True)
                    self.layout.addWidget(self.info_label)

                    # Add custom menu text input
                    menu_text_label = QtWidgets.QLabel("Custom menu text:")
                    self.layout.addWidget(menu_text_label)
                    
                    self.menu_text_input = QtWidgets.QLineEdit()
                    self.menu_text_input.setPlaceholderText("Open with aicodeprep-gui")
                    self.menu_text_input.setText("Open with aicodeprep-gui")
                    self.menu_text_input.setToolTip("Enter the text that will appear in the right-click context menu")
                    self.layout.addWidget(self.menu_text_input)
                    
                    # Add some spacing
                    self.layout.addSpacing(10)

                    # Classic menu checkbox and help icon
                    self.classic_menu_checkbox = QtWidgets.QCheckBox("Enable Classic Right-Click Menu (for Windows 11)")
                    self.classic_menu_checkbox.setChecked(True)
                    classic_help = QtWidgets.QLabel("<b style='color:#0078D4; font-size:14px; cursor:help;'>?</b>")
                    classic_help.setToolTip("Restores the full right-click menu in Windows 11, so you don't have to click 'Show more options' to see this app's menu item.")
                    classic_help.setAlignment(QtCore.Qt.AlignVCenter)
                    classic_layout = QtWidgets.QHBoxLayout()
                    classic_layout.setContentsMargins(0,0,0,0)
                    classic_layout.addWidget(self.classic_menu_checkbox)
                    classic_layout.addWidget(classic_help)
                    classic_layout.addStretch()
                    self.layout.addLayout(classic_layout)

                    self.status_label = QtWidgets.QLabel("Ready.")
                    self.status_label.setStyleSheet("font-style: italic;")
                    
                    self.install_button = QtWidgets.QPushButton("Install Right-Click Menu")
                    self.install_button.clicked.connect(self.run_install)
                    
                    self.uninstall_button = QtWidgets.QPushButton("Uninstall Right-Click Menu")
                    self.uninstall_button.clicked.connect(self.run_uninstall)

                    button_layout = QtWidgets.QHBoxLayout()
                    button_layout.addWidget(self.install_button)
                    button_layout.addWidget(self.uninstall_button)
                    
                    self.layout.addLayout(button_layout)
                    self.layout.addWidget(self.status_label)

                def _run_action(self, action_name):
                    enable_classic = self.classic_menu_checkbox.isChecked()
                    if windows_registry.is_admin():
                        # Already running as admin, just do the action
                        if action_name == 'install':
                            custom_text = self.menu_text_input.text().strip()
                            success, message = windows_registry.install_context_menu(
                                custom_text if custom_text else None,
                                enable_classic_menu=enable_classic
                            )
                        else:
                            success, message = windows_registry.remove_context_menu()
                        
                        self.status_label.setText(message)
                        if success:
                            QtWidgets.QMessageBox.information(self, "Success", message)
                        else:
                            QtWidgets.QMessageBox.warning(self, "Error", message)
                    else:
                        # Not admin, need to elevate
                        if action_name == 'install':
                            custom_text = self.menu_text_input.text().strip()
                            success, message = windows_registry.run_as_admin(
                                action_name,
                                custom_text if custom_text else None,
                                enable_classic_menu=enable_classic
                            )
                        else:
                            success, message = windows_registry.run_as_admin(action_name)
                        self.status_label.setText(message)
                        if success:
                            # Close the main app window as a new elevated process will take over
                            self.parent().close()
                
                def run_install(self):
                    self._run_action('install')

                def run_uninstall(self):
                    self._run_action('remove')

            def open_registry_manager(self):
                dialog = RegistryManagerDialog(self)
                dialog.exec()

            install_menu_act = QtGui.QAction("Install Right-Click Menu...", self)
            install_menu_act.triggered.connect(lambda: open_registry_manager(self))
            file_menu.addAction(install_menu_act)
            file_menu.addSeparator() # Optional, for visual separation

        # Add macOS-only menu item
        if platform.system() == "Darwin":
            from aicodeprep_gui import macos_installer

            class MacInstallerDialog(QtWidgets.QDialog):
                def __init__(self, parent=None):
                    super().__init__(parent)
                    self.setWindowTitle("macOS Quick Action Manager")
                    self.setMinimumWidth(450)
                    self.layout = QtWidgets.QVBoxLayout(self)

                    info_text = (
                        "This tool installs or removes a <b>Quick Action</b> to open `aicodeprep-gui` "
                        "from the right-click menu in Finder (under Quick Actions or Services).<br><br>"
                        "The action is installed in your user's Library folder, so no administrator "
                        "privileges are required."
                    )
                    self.info_label = QtWidgets.QLabel(info_text)
                    self.info_label.setWordWrap(True)
                    self.layout.addWidget(self.info_label)
                    self.layout.addSpacing(10)

                    self.install_button = QtWidgets.QPushButton("Install Quick Action")
                    self.install_button.clicked.connect(self.run_install)
                    
                    self.uninstall_button = QtWidgets.QPushButton("Uninstall Quick Action")
                    self.uninstall_button.clicked.connect(self.run_uninstall)

                    button_layout = QtWidgets.QHBoxLayout()
                    button_layout.addWidget(self.install_button)
                    button_layout.addWidget(self.uninstall_button)
                    self.layout.addLayout(button_layout)

                def run_install(self):
                    success, message = macos_installer.install_quick_action()
                    if success:
                        QtWidgets.QMessageBox.information(self, "Success", message)
                    else:
                        QtWidgets.QMessageBox.warning(self, "Error", message)

                def run_uninstall(self):
                    success, message = macos_installer.uninstall_quick_action()
                    if success:
                        QtWidgets.QMessageBox.information(self, "Success", message)
                    else:
                        QtWidgets.QMessageBox.warning(self, "Error", message)

            def open_mac_installer(self):
                dialog = MacInstallerDialog(self)
                dialog.exec()

            install_menu_act = QtGui.QAction("Install Finder Quick Action...", self)
            install_menu_act.triggered.connect(lambda: open_mac_installer(self))
            file_menu.addAction(install_menu_act)
            file_menu.addSeparator()

        # Add Linux-only menu item
        if platform.system() == "Linux":
            from aicodeprep_gui import linux_installer

            class LinuxInstallerDialog(QtWidgets.QDialog):
                def __init__(self, parent=None):
                    super().__init__(parent)
                    self.setWindowTitle("Linux File Manager Integration")
                    self.setMinimumWidth(500)
                    self.layout = QtWidgets.QVBoxLayout(self)

                    self.tabs = QtWidgets.QTabWidget()
                    
                    # Automated Installer Tab
                    automated_tab = QtWidgets.QWidget()
                    automated_layout = QtWidgets.QVBoxLayout(automated_tab)
                    self.tabs.addTab(automated_tab, "Automated Setup")

                    info_text = QtWidgets.QLabel(
                        "This tool can attempt to install a context menu script for your file manager."
                    )
                    info_text.setWordWrap(True)
                    automated_layout.addWidget(info_text)
                    automated_layout.addSpacing(10)

                    self.nautilus_group = QtWidgets.QGroupBox("Nautilus (GNOME, Cinnamon, etc.)")
                    nautilus_layout = QtWidgets.QVBoxLayout(self.nautilus_group)
                    
                    self.install_nautilus_btn = QtWidgets.QPushButton("Install Nautilus Script")
                    self.install_nautilus_btn.clicked.connect(self.run_install_nautilus)
                    self.uninstall_nautilus_btn = QtWidgets.QPushButton("Uninstall Nautilus Script")
                    self.uninstall_nautilus_btn.clicked.connect(self.run_uninstall_nautilus)
                    
                    nautilus_layout.addWidget(self.install_nautilus_btn)
                    nautilus_layout.addWidget(self.uninstall_nautilus_btn)
                    
                    automated_layout.addWidget(self.nautilus_group)
                    automated_layout.addStretch()

                    # Disable if Nautilus is not detected
                    if not linux_installer.is_nautilus_installed():
                        self.nautilus_group.setDisabled(True)
                        self.nautilus_group.setToolTip("Nautilus file manager not detected in your system's PATH.")

                    # Manual Instructions Tab
                    manual_tab = QtWidgets.QWidget()
                    manual_layout = QtWidgets.QVBoxLayout(manual_tab)
                    self.tabs.addTab(manual_tab, "Manual Instructions")
                    
                    manual_text = QtWidgets.QLabel(
                        "If your file manager is not listed above, you can likely add a custom action manually. "
                        "Create a new executable script with the content below and add it to your file manager's "
                        "scripting or custom actions feature. The selected folder path will be passed as the first argument ($1)."
                    )
                    manual_text.setWordWrap(True)
                    manual_layout.addWidget(manual_text)

                    script_box = QtWidgets.QPlainTextEdit()
                    script_box.setPlainText(linux_installer.NAUTILUS_SCRIPT_CONTENT)
                    script_box.setReadOnly(True)
                    script_box.setFont(QtGui.QFont("Monospace"))
                    manual_layout.addWidget(script_box)
                    
                    self.layout.addWidget(self.tabs)

                def run_install_nautilus(self):
                    success, message = linux_installer.install_nautilus_script()
                    if success:
                        QtWidgets.QMessageBox.information(self, "Success", message)
                    else:
                        QtWidgets.QMessageBox.warning(self, "Error", message)

                def run_uninstall_nautilus(self):
                    success, message = linux_installer.uninstall_nautilus_script()
                    if success:
                        QtWidgets.QMessageBox.information(self, "Success", message)
                    else:
                        QtWidgets.QMessageBox.warning(self, "Error", message)

            def open_linux_installer(self):
                dialog = LinuxInstallerDialog(self)
                dialog.exec()

            install_menu_act = QtGui.QAction("Install File Manager Action...", self)
            install_menu_act.triggered.connect(lambda: open_linux_installer(self))
            file_menu.addAction(install_menu_act)
            file_menu.addSeparator()

        quit_act = QtGui.QAction("&Quit", self); quit_act.triggered.connect(self.quit_without_processing); file_menu.addAction(quit_act)
        edit_menu = mb.addMenu("&Edit")
        new_preset_act = QtGui.QAction("&New Preset…", self); new_preset_act.triggered.connect(self.add_new_preset_dialog); edit_menu.addAction(new_preset_act)
        open_settings_folder_act = QtGui.QAction("Open Settings Folder…", self)
        open_settings_folder_act.triggered.connect(self.open_settings_folder)
        edit_menu.addAction(open_settings_folder_act)

        # --- New Help / About menu ---
        help_menu = mb.addMenu("&Help")
        about_act = QtGui.QAction("&About", self)
        about_act.triggered.connect(self.open_about_dialog)
        help_menu.addAction(about_act)
        # Add Complain/Feedback menu item
        complain_act = QtGui.QAction("Send Feedback / Complain...", self)
        complain_act.triggered.connect(self.open_complain_dialog)
        help_menu.addAction(complain_act)

        self.format_combo = QtWidgets.QComboBox()
        self.format_combo.addItems(["XML <code>", "Markdown ###"])
        self.format_combo.setFixedWidth(130)
        self.format_combo.setItemData(0, 'xml')
        self.format_combo.setItemData(1, 'markdown')
        output_label = QtWidgets.QLabel("&Output format:")
        output_label.setBuddy(self.format_combo)
        self.dark_mode_box = QtWidgets.QCheckBox("Dark mode")
        self.dark_mode_box.setChecked(self.is_dark_mode)
        self.dark_mode_box.stateChanged.connect(self.toggle_dark_mode)
        self.token_label = QtWidgets.QLabel("Estimated tokens: 0")
        main_layout.addWidget(self.token_label)
        main_layout.addSpacing(8)

        self.vibe_label = QtWidgets.QLabel("AI Code Prep GUI")
        vibe_font = QtGui.QFont(self.default_font)
        vibe_font.setBold(True)
        vibe_font.setPointSize(self.default_font.pointSize() + 8)
        self.vibe_label.setFont(vibe_font)
        self.vibe_label.setAlignment(QtCore.Qt.AlignHCenter | QtCore.Qt.AlignVCenter)
        self.vibe_label.setStyleSheet(
            "background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #40203f, stop:1 #1f103f); "
            "color: white; padding: 0px 0px 0px 0px; border-radius: 8px;"
        )
        self.vibe_label.setFixedHeight(44)
        banner_wrap = QtWidgets.QWidget()
        banner_layout = QtWidgets.QHBoxLayout(banner_wrap)
        banner_layout.setContentsMargins(14, 0, 14, 0)
        banner_layout.addWidget(self.vibe_label)
        main_layout.addWidget(banner_wrap)
        main_layout.addSpacing(8)

        # --- Update available label (hidden by default) ---
        self.update_label = QtWidgets.QLabel()
        self.update_label.setTextFormat(QtCore.Qt.RichText)
        self.update_label.setAlignment(QtCore.Qt.AlignCenter)
        self.update_label.setVisible(False)
        main_layout.addWidget(self.update_label)
        main_layout.addSpacing(8)

        self.info_label = QtWidgets.QLabel("The selected files will be added to the LLM Context Block along with your prompt, written to fullcode.txt and copied to clipboard, ready to paste into Gemini in AI studio, Deepseek, ChatGPT, etc.")
        self.info_label.setWordWrap(True)  # Add this line to enable word wrapping
        self.info_label.setAlignment(QtCore.Qt.AlignHCenter)
        main_layout.addWidget(self.info_label)

        self.text_label = QtWidgets.QLabel("")
        self.text_label.setWordWrap(True)
        main_layout.addWidget(self.text_label)

        # Add "Prompt Preset Buttons:" label above presets section
        prompt_header_label = QtWidgets.QLabel("Prompt Preset Buttons:")
        main_layout.addWidget(prompt_header_label)
        
        # Create scrollable preset area
        presets_wrapper = QtWidgets.QHBoxLayout()
        
        # Scrollable area for preset buttons
        scroll_area = QtWidgets.QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll_area.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        scroll_area.setFixedHeight(52)  # Enough height for 22px buttons + padding
        
        scroll_widget = QtWidgets.QWidget()
        self.preset_strip = QtWidgets.QHBoxLayout(scroll_widget)
        self.preset_strip.setContentsMargins(0, 0, 0, 0)
        
        add_preset_btn = QtWidgets.QPushButton("✚")
        add_preset_btn.setFixedSize(24, 24)
        add_preset_btn.setToolTip("New Preset…")
        add_preset_btn.clicked.connect(self.add_new_preset_dialog)
        self.preset_strip.addWidget(add_preset_btn)

        delete_preset_btn = QtWidgets.QPushButton("🗑️")
        delete_preset_btn.setFixedSize(24, 24)
        delete_preset_btn.setToolTip("Delete a preset…")
        delete_preset_btn.clicked.connect(self.delete_preset_dialog)
        self.preset_strip.addWidget(delete_preset_btn)
        
        self.preset_strip.addStretch()
        
        scroll_area.setWidget(scroll_widget)
        presets_wrapper.addWidget(scroll_area)
        
        main_layout.addLayout(presets_wrapper)
        
        # Add explanation text below presets
        preset_explanation = QtWidgets.QLabel("Presets help you save more time and will be saved for later use")
        preset_explanation.setObjectName("preset_explanation")
        preset_explanation.setStyleSheet(
            f"font-size: 10px; color: {'#bbbbbb' if self.is_dark_mode else '#444444'};"
        )
        main_layout.addWidget(preset_explanation)
        
        main_layout.addSpacing(8)

        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)
        self.tree_widget = QtWidgets.QTreeWidget()
        self.tree_widget.setHeaderLabels(["File/Folder"])
        self.tree_widget.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        # Apply initial checkbox styling along with other styles
        base_style = """
            QTreeView, QTreeWidget {
                outline: 2; /* Remove focus rectangle */
            }
        """
        checkbox_style = get_checkbox_style_dark() if self.is_dark_mode else get_checkbox_style_light()
        self.tree_widget.setStyleSheet(base_style + checkbox_style)
        
        self.splitter.addWidget(self.tree_widget)
        prompt_widget = QtWidgets.QWidget(); prompt_layout = QtWidgets.QVBoxLayout(prompt_widget); prompt_layout.setContentsMargins(0,0,0,0)
        prompt_layout.addWidget(QtWidgets.QLabel("Optional prompt/question for LLM (will be appended to the end):")); prompt_layout.addSpacing(8)
        self.prompt_textbox = QtWidgets.QPlainTextEdit()
        self.prompt_textbox.setPlaceholderText("Type your question or prompt here (optional)…")
        prompt_layout.addWidget(self.prompt_textbox)

        # Add Clear button below the prompt box
        self.clear_prompt_btn = QtWidgets.QPushButton("Clear")
        self.clear_prompt_btn.setToolTip("Clear the prompt box")
        self.clear_prompt_btn.clicked.connect(self.prompt_textbox.clear)
        prompt_layout.addWidget(self.clear_prompt_btn)
        self.splitter.addWidget(prompt_widget)
        self.splitter.setStretchFactor(0, 4); self.splitter.setStretchFactor(1, 1)
        main_layout.addWidget(self.splitter)

        # Apply saved splitter state if available
        if self.splitter_state_from_prefs: 
            try:
                self.splitter.restoreState(self.splitter_state_from_prefs)
                logging.info("Restored splitter state from preferences")
            except Exception as e:
                logging.warning(f"Failed to restore splitter state: {e}")

        # --- NEW TREE BUILDING LOGIC ---
        self.path_to_item = {}  # Maps relative_path to QTreeWidgetItem
        root_node = self.tree_widget.invisibleRootItem()
        for abs_path, rel_path, is_checked in files:
            parts = rel_path.split(os.sep)
            parent_node = root_node
            path_so_far = ""
            for part in parts[:-1]:
                path_so_far = os.path.join(path_so_far, part) if path_so_far else part
                if path_so_far in self.path_to_item:
                    parent_node = self.path_to_item[path_so_far]
                else:
                    # This case implies a directory was not in the `files` list, create it
                    new_parent = QtWidgets.QTreeWidgetItem(parent_node, [part])
                    new_parent.setIcon(0, self.folder_icon)
                    new_parent.setFlags(new_parent.flags() | QtCore.Qt.ItemIsUserCheckable)
                    new_parent.setCheckState(0, QtCore.Qt.Unchecked)
                    self.path_to_item[path_so_far] = new_parent
                    parent_node = new_parent

            # Create the final item
            item_text = parts[-1]
            item = QtWidgets.QTreeWidgetItem(parent_node, [item_text])
            item.setData(0, QtCore.Qt.UserRole, abs_path) # Store absolute path
            self.path_to_item[rel_path] = item

            if self.prefs_loaded:
                is_checked = rel_path in self.checked_files_from_prefs
            
            if os.path.isdir(abs_path):
                item.setIcon(0, self.folder_icon)
                item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
                # For directories, default to unchecked during initial population.
                # Their checked state will reflect children or be set explicitly by load_prefs_if_exists
                item.setCheckState(0, QtCore.Qt.Unchecked) 
            else: # It's a file
                item.setIcon(0, self.file_icon)
                item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
                # Don't block binary files, just leave them unchecked by default
                if smart_logic.is_binary_file(abs_path):
                    is_checked = False
            
            item.setCheckState(0, QtCore.Qt.Checked if is_checked else QtCore.Qt.Unchecked)

        # Connect signals for lazy loading and item changes
        self.tree_widget.itemExpanded.connect(self.on_item_expanded)
        self.tree_widget.itemChanged.connect(self.handle_item_changed)
        
        # Auto-expand folders containing checked files
        if self.prefs_loaded and self.checked_files_from_prefs:
            self._expand_folders_for_paths(self.checked_files_from_prefs)
        else:
            # On first load (no prefs), expand based on smart-selected files
            initial_checked_paths = {rel_path for _, rel_path, is_checked in files if is_checked}
            self._expand_folders_for_paths(initial_checked_paths)
        
        # --- Remember checked files checkbox with tooltip and ? icon ---
        self.remember_checkbox = QtWidgets.QCheckBox("Remember checked files for this folder, window size information")
        self.remember_checkbox.setChecked(True)
        self.remember_checkbox.setToolTip("Saves which files are included in the context for this folder, so you don't have to keep doing it over and over")
        remember_help = QtWidgets.QLabel("<b style='color:#0078D4; font-size:14px; cursor:help;'>?</b>")
        remember_help.setToolTip("Saves which files are included in the context for this folder, so you don't have to keep doing it over and over")
        remember_help.setAlignment(QtCore.Qt.AlignVCenter)
        remember_layout = QtWidgets.QHBoxLayout()
        remember_layout.setContentsMargins(0,0,0,0)
        remember_layout.addWidget(self.remember_checkbox)
        remember_layout.addWidget(remember_help)
        remember_layout.addStretch()

        # --- Prompt/question to top checkbox with tooltip and ? icon ---
        self.prompt_top_checkbox = QtWidgets.QCheckBox("Add prompt/question to top")
        self.prompt_top_checkbox.setToolTip("Research shows that asking your question before AND after the code context, can improve quality and ability of the AI responses! Highly recommended to check both of these")
        prompt_top_help = QtWidgets.QLabel("<b style='color:#0078D4; font-size:14px; cursor:help;'>?</b>")
        prompt_top_help.setToolTip("Research shows that asking your question before AND after the code context, can improve quality and ability of the AI responses! Highly recommended to check both of these")
        prompt_top_help.setAlignment(QtCore.Qt.AlignVCenter)
        prompt_top_layout = QtWidgets.QHBoxLayout()
        prompt_top_layout.setContentsMargins(0,0,0,0)
        prompt_top_layout.addWidget(self.prompt_top_checkbox)
        prompt_top_layout.addWidget(prompt_top_help)
        prompt_top_layout.addStretch()

        # --- Prompt/question to bottom checkbox with tooltip and ? icon ---
        self.prompt_bottom_checkbox = QtWidgets.QCheckBox("Add prompt/question to bottom")
        self.prompt_bottom_checkbox.setToolTip("Research shows that asking your question before AND after the code context, can improve quality and ability of the AI responses! Highly recommended to check both of these")
        prompt_bottom_help = QtWidgets.QLabel("<b style='color:#0078D4; font-size:14px; cursor:help;'>?</b>")
        prompt_bottom_help.setToolTip("Research shows that asking your question before AND after the code context, can improve quality and ability of the AI responses! Highly recommended to check both of these")
        prompt_bottom_help.setAlignment(QtCore.Qt.AlignVCenter)
        prompt_bottom_layout = QtWidgets.QHBoxLayout()
        prompt_bottom_layout.setContentsMargins(0,0,0,0)
        prompt_bottom_layout.addWidget(self.prompt_bottom_checkbox)
        prompt_bottom_layout.addWidget(prompt_bottom_help)
        prompt_bottom_layout.addStretch()

        # Load global prompt option settings
        self._load_prompt_options()

        # Save settings when toggled
        self.prompt_top_checkbox.stateChanged.connect(self._save_prompt_options)
        self.prompt_bottom_checkbox.stateChanged.connect(self._save_prompt_options)

        # --- New Options & Settings Group ---
        options_group_box = QtWidgets.QGroupBox("Options & Settings")
        options_group_layout = QtWidgets.QVBoxLayout(options_group_box)

        # First row: Output format and Dark mode
        options_top_row = QtWidgets.QHBoxLayout()
        options_top_row.addWidget(output_label)
        options_top_row.addWidget(self.format_combo)
        options_top_row.addStretch()
        options_top_row.addWidget(self.dark_mode_box)
        options_group_layout.addLayout(options_top_row)

        # Add the three checkbox layouts
        options_group_layout.addLayout(remember_layout)
        options_group_layout.addLayout(prompt_top_layout)
        options_group_layout.addLayout(prompt_bottom_layout)

        main_layout.addWidget(options_group_box)
        
        # Button layouts
        button_layout1 = QtWidgets.QHBoxLayout()
        button_layout2 = QtWidgets.QHBoxLayout()

        button_layout1.addStretch()
        process_button = QtWidgets.QPushButton("GENERATE CONTEXT!")
        process_button.clicked.connect(self.process_selected)
        button_layout1.addWidget(process_button)
        select_all_button = QtWidgets.QPushButton("Select All")
        select_all_button.clicked.connect(self.select_all)
        button_layout1.addWidget(select_all_button)
        deselect_all_button = QtWidgets.QPushButton("Deselect All")
        deselect_all_button.clicked.connect(self.deselect_all)
        button_layout1.addWidget(deselect_all_button)

        button_layout2.addStretch()
        load_prefs_button = QtWidgets.QPushButton("Load preferences")
        load_prefs_button.clicked.connect(self.load_from_prefs_button_clicked)
        button_layout2.addWidget(load_prefs_button)
        quit_button = QtWidgets.QPushButton("Quit")
        quit_button.clicked.connect(self.quit_without_processing)
        button_layout2.addWidget(quit_button)

        main_layout.addLayout(button_layout1)
        main_layout.addLayout(button_layout2)

        # --- Footer Layout ---
        footer_layout = QtWidgets.QHBoxLayout()
        
        # Email link on the left
        email_text = '<a href="mailto:tom@wuu73.org">tom@wuu73.org</a>'
        email_label = QtWidgets.QLabel(email_text)
        email_label.setOpenExternalLinks(True)
        footer_layout.addWidget(email_label)
        
        footer_layout.addStretch()
        
        # Website link on the right
        website_label = QtWidgets.QLabel('<a href="https://wuu73.org/aicp">aicodeprep-gui</a>')
        website_label.setOpenExternalLinks(True)
        footer_layout.addWidget(website_label)
        
        main_layout.addLayout(footer_layout)

        self.selected_files = []
        self.file_token_counts = {}
        self.update_token_counter()
        self._load_global_presets()

    def on_item_expanded(self, item):
        """Handler for when a tree item is expanded, used for lazy loading."""
        dir_path = item.data(0, QtCore.Qt.UserRole)
        if not dir_path or not os.path.isdir(dir_path): 
            return
            
        # Check if children have already been loaded by verifying if first child is a real item.
        # If it has children and the first one has a UserRole data, it implies content has been loaded.
        if item.childCount() > 0 and item.child(0).data(0, QtCore.Qt.UserRole) is not None:
            return
            
        try:
            # Clear any existing children (e.g., a dummy placeholder item)
            item.takeChildren()
        
            for name in sorted(os.listdir(dir_path)):
                abs_path = os.path.join(dir_path, name)
                
                try:
                    rel_path = os.path.relpath(abs_path, os.getcwd())
                except ValueError: # Path is on a different drive on Windows
                    logging.warning(f"Skipping {abs_path}: not on current drive.")
                    continue
                
                # If an item for this relative path already exists in the dictionary, skip
                # This can happen if some subdirectories were part of the initial 'files' list
                if rel_path in self.path_to_item:
                    continue

                new_item = QtWidgets.QTreeWidgetItem(item, [name])
                new_item.setData(0, QtCore.Qt.UserRole, abs_path)
                new_item.setFlags(new_item.flags() | QtCore.Qt.ItemIsUserCheckable)
                self.path_to_item[rel_path] = new_item
                
                is_excluded = smart_logic.exclude_spec.match_file(rel_path) or smart_logic.exclude_spec.match_file(rel_path + '/')
                
                if os.path.isdir(abs_path):
                    new_item.setIcon(0, self.folder_icon)
                    # For newly loaded directories, inherit check state from parent if not excluded
                    if is_excluded:
                        new_item.setCheckState(0, QtCore.Qt.Unchecked)
                    else:
                        new_item.setCheckState(0, item.checkState(0)) # Inherit from parent
                else: # File
                    new_item.setIcon(0, self.file_icon)
                    # Treat binary files as implicitly excluded
                    if smart_logic.is_binary_file(abs_path):
                        is_excluded = True

                    # Set check state based on parent, unless it's excluded or was specifically unchecked in prefs
                    if is_excluded:
                        new_item.setCheckState(0, QtCore.Qt.Unchecked)
                    elif self.prefs_loaded and rel_path in self.checked_files_from_prefs:
                        new_item.setCheckState(0, QtCore.Qt.Checked)
                    else:
                        # Inherit from parent if not specifically in prefs and not excluded
                        new_item.setCheckState(0, item.checkState(0))

        except OSError as e:
            logging.error(f"Error scanning directory {dir_path}: {e}")

    def handle_item_changed(self, item, column):
        if column == 0:
            self.tree_widget.blockSignals(True)
            try:
                new_state = item.checkState(0)
                # Apply check state to children
                def apply_to_children(parent_item, state):
                    for i in range(parent_item.childCount()):
                        child = parent_item.child(i)
                        if child.flags() & QtCore.Qt.ItemIsUserCheckable and child.flags() & QtCore.Qt.ItemIsEnabled:
                            abs_path = child.data(0, QtCore.Qt.UserRole)
                            
                            # Prevent checking excluded binary files if state is QtCore.Qt.Checked
                            if state == QtCore.Qt.Checked and abs_path and os.path.isfile(abs_path) and smart_logic.is_binary_file(abs_path):
                                child.setCheckState(0, QtCore.Qt.Unchecked)
                            else:
                                child.setCheckState(0, state)
                            
                            # Recursively apply to children of directories
                            if os.path.isdir(abs_path):
                                apply_to_children(child, state)
                                
                apply_to_children(item, new_state)

                # Update parent state based on children (if all children are checked/unchecked)
                parent = item.parent()
                while parent:
                    all_children_checked = True
                    all_children_unchecked = True
                    has_checkable_children = False
                    
                    for i in range(parent.childCount()):
                        child = parent.child(i)
                        if child.flags() & QtCore.Qt.ItemIsUserCheckable and child.flags() & QtCore.Qt.ItemIsEnabled:
                            has_checkable_children = True
                            if child.checkState(0) == QtCore.Qt.Checked:
                                all_children_unchecked = False
                            elif child.checkState(0) == QtCore.Qt.Unchecked:
                                all_children_checked = False
                            else: # Partially checked
                                all_children_checked = False
                                all_children_unchecked = False
                    
                    if has_checkable_children:
                        if all_children_checked:
                            parent.setCheckState(0, QtCore.Qt.Checked)
                        elif all_children_unchecked:
                            parent.setCheckState(0, QtCore.Qt.Unchecked)
                        else:
                            parent.setCheckState(0, QtCore.Qt.PartiallyChecked)
                    else: # No checkable children, or directory that has no files/folders to check
                        parent.setCheckState(0, QtCore.Qt.Unchecked) # Explicitly set to unchecked
                    parent = parent.parent()

            finally:
                self.tree_widget.blockSignals(False)

            # Auto-expand parent folders if a file is checked (using QTimer to avoid timing issues)
            if item.checkState(0) == QtCore.Qt.Checked:
                file_path = item.data(0, QtCore.Qt.UserRole)
                if file_path and os.path.isfile(file_path):
                    # Use QTimer to ensure expansion happens after signal processing
                    QtCore.QTimer.singleShot(0, lambda: self.expand_parents_of_item(item))

            self.update_token_counter()
            # Only save preferences when explicitly requested by the user, or on window close.

    def expand_parents_of_item(self, item):
        """Expand all parent folders of the given item."""
        parent = item.parent()
        while parent is not None:
            self.tree_widget.expandItem(parent)
            parent = parent.parent()
    
    def _load_global_presets(self):
        try:
            presets = global_preset_manager.get_all_presets()
            for label, text in presets:
                self._add_preset_button(label, text, from_global=True)
        except Exception as e: 
            logging.error(f"Failed to load global presets: {e}")
            
    def _add_preset_button(self, label: str, text: str, from_local=False, from_global=False):
        btn = QtWidgets.QPushButton(label)
        btn.setFixedHeight(22)
        btn.clicked.connect(lambda _=None, t=text: self._apply_preset(t))
        
        if from_global:
            btn.setToolTip(f"Global preset: {label}")
        else:
            btn.setToolTip(f"Preset: {label}")
            
        # Insert before the stretch. The add/delete buttons are at the start.
        # Layout: [add_btn, delete_btn, ..., stretch]
        # We want to insert before 'stretch'.
        insert_index = self.preset_strip.count() - 1 
        self.preset_strip.insertWidget(insert_index, btn)

    def _delete_preset(self, label, button, from_global):
        reply = QtWidgets.QMessageBox.question(self, "Delete Preset", f"Are you sure you want to delete the preset '{label}'?", QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)
        if reply == QtWidgets.QMessageBox.Yes:
            if from_global:
                if not global_preset_manager.delete_preset(label): 
                    QtWidgets.QMessageBox.warning(self, "Error", f"Failed to delete global preset '{label}'")
                    return
            else: 
                # This branch for 'local' presets is currently not used, as all presets are global.
                # It's kept for logical completeness but would require a local preset saving mechanism.
                self.presets = [(l, t) for l, t in self.presets if l != label]
            self.preset_strip.removeWidget(button)
            button.deleteLater()
            logging.info(f"Deleted preset: {label}")
    
    def _apply_preset(self, preset_text: str):
        current = self.prompt_textbox.toPlainText(); self.prompt_textbox.setPlainText((current.rstrip() + "\n\n" if current else "") + preset_text)

    def delete_preset_dialog(self):
        presets = global_preset_manager.get_all_presets()
        if not presets:
            QtWidgets.QMessageBox.information(self, "No Presets", "There are no presets to delete.")
            return

        preset_labels = [p[0] for p in presets]
        label_to_delete, ok = QtWidgets.QInputDialog.getItem(self, "Delete Preset", 
                                                             "Select a preset to delete:", preset_labels, 0, False)

        if ok and label_to_delete:
            # Find the button widget corresponding to the label
            button_to_remove = None
            for i in range(self.preset_strip.count()):
                item = self.preset_strip.itemAt(i)
                if item and item.widget():
                    widget = item.widget()
                    if isinstance(widget, QtWidgets.QPushButton) and widget.text() == label_to_delete:
                        button_to_remove = widget
                        break
            
            if button_to_remove:
                # Call the existing delete logic, which includes the confirmation dialog.
                # All presets managed this way are considered global.
                self._delete_preset(label_to_delete, button_to_remove, from_global=True)
            else:
                # This is a descriptive error for debugging, in case the UI and data get out of sync.
                QtWidgets.QMessageBox.warning(self, "Error", "Could not find the corresponding button to delete. The UI might be out of sync.")
                
    def add_new_preset_dialog(self):
        lbl, ok = QtWidgets.QInputDialog.getText(self, "New preset", "Button label:");
        if not ok or not lbl.strip(): return
        dlg = QtWidgets.QDialog(self); dlg.setWindowTitle("Preset text"); dlg.setMinimumSize(400, 300); v = QtWidgets.QVBoxLayout(dlg)
        v.addWidget(QtWidgets.QLabel("Enter the preset text:")); text_edit = QtWidgets.QPlainTextEdit(); v.addWidget(text_edit)
        bb = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel); v.addWidget(bb); bb.accepted.connect(dlg.accept); bb.rejected.connect(dlg.reject)
        if dlg.exec() != QtWidgets.QDialog.Accepted: return
        txt = text_edit.toPlainText().strip()
        if txt and global_preset_manager.add_preset(lbl.strip(), txt): self._add_preset_button(lbl.strip(), txt, from_global=True)
        else: QtWidgets.QMessageBox.warning(self, "Error", "Failed to save preset.")
        
    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls() and event.mimeData().urls()[0].isLocalFile() and os.path.isdir(event.mimeData().urls()[0].toLocalFile()):
            event.acceptProposedAction()
    def dropEvent(self, event):
        folder_path = event.mimeData().urls()[0].toLocalFile()
        os.chdir(folder_path); from aicodeprep_gui.smart_logic import collect_all_files
        self.new_gui = FileSelectionGUI(collect_all_files()); self.new_gui.show(); self.close()
        
    def select_all(self):
        def check_all(item):
            # Only check if it's a file or a non-excluded folder
            abs_path = item.data(0, QtCore.Qt.UserRole)
            rel_path = os.path.relpath(abs_path, os.getcwd()) if abs_path else None
            is_excluded = False
            if rel_path:
                is_excluded = smart_logic.exclude_spec.match_file(rel_path) or smart_logic.exclude_spec.match_file(rel_path + '/')
                if os.path.isfile(abs_path) and smart_logic.is_binary_file(abs_path):
                    is_excluded = True # Treat binary files as implicitly excluded from 'select all'
            
            if item.flags() & QtCore.Qt.ItemIsUserCheckable and item.flags() & QtCore.Qt.ItemIsEnabled and not is_excluded:
                item.setCheckState(0, QtCore.Qt.Checked)
            else: # If it's excluded, uncheck it or keep unchecked
                 item.setCheckState(0, QtCore.Qt.Unchecked)

            for i in range(item.childCount()): 
                # Ensure children are loaded before processing, if it's a directory
                if os.path.isdir(abs_path):
                    self.on_item_expanded(item) # Ensures children are present for checking
                check_all(item.child(i))
        
        # Block signals temporarily to prevent recursive updates during mass selection
        self.tree_widget.blockSignals(True)
        try:
            for i in range(self.tree_widget.topLevelItemCount()): 
                check_all(self.tree_widget.topLevelItem(i))
        finally:
            self.tree_widget.blockSignals(False)
        self.update_token_counter()
        
    def deselect_all(self):
        iterator = QtWidgets.QTreeWidgetItemIterator(self.tree_widget)
        self.tree_widget.blockSignals(True) # Block signals during mass deselect
        try:
            while iterator.value():
                item = iterator.value()
                if item.flags() & QtCore.Qt.ItemIsUserCheckable: item.setCheckState(0, QtCore.Qt.Unchecked)
                iterator += 1
        finally:
            self.tree_widget.blockSignals(False)
        self.update_token_counter()

    def get_selected_files(self):
        selected = []; iterator = QtWidgets.QTreeWidgetItemIterator(self.tree_widget)
        while iterator.value():
            item = iterator.value()
            # Only consider files that are checked and not directories
            file_path = item.data(0, QtCore.Qt.UserRole)
            if file_path and os.path.isfile(file_path) and item.checkState(0) == QtCore.Qt.Checked:
                selected.append(file_path)
            iterator += 1
        return selected

    def process_selected(self):
        self.action = 'process'
        selected_files = self.get_selected_files()
        chosen_fmt = self.format_combo.currentData()
        prompt = self.prompt_textbox.toPlainText().strip()

        if process_files(
            selected_files,
            "fullcode.txt",
            fmt=chosen_fmt,
            prompt=prompt,
            prompt_to_top=self.prompt_top_checkbox.isChecked(),
            prompt_to_bottom=self.prompt_bottom_checkbox.isChecked()
        ) > 0:
            output_path = os.path.join(os.getcwd(), "fullcode.txt")
            # Now, just read the final content for the clipboard
            with open(output_path, "r", encoding="utf-8") as f:
                content = f.read()
            QtWidgets.QApplication.clipboard().setText(content)
            logging.info(f"Copied {len(content)} chars to clipboard.")
            self.text_label.setStyleSheet(
                f"font-size: 20px; color: {'#00c3ff' if self.is_dark_mode else '#0078d4'}; font-weight: bold;"
            )
            self.text_label.setText("Copied to clipboard and fullcode.txt")
            self.save_prefs()
            QtCore.QTimer.singleShot(1500, self.close)
        else:
            self.close()
            
    def quit_without_processing(self): self.action = 'quit'; self.close()
    
    def update_token_counter(self):
        total_tokens = 0
        for file_path in self.get_selected_files():
            if file_path not in self.file_token_counts:
                try:
                    with open(file_path, "r", encoding="utf-8", errors="ignore") as f: text = f.read()
                    self.file_token_counts[file_path] = len(text) // 4
                except Exception: self.file_token_counts[file_path] = 0
            total_tokens += self.file_token_counts[file_path]
        self.total_tokens = total_tokens; self.token_label.setText(f"Estimated tokens: {total_tokens:,}")
        
    def _expand_folders_for_paths(self, checked_paths: set):
        """Auto-expand folders that contain files from the given paths."""
        folders_to_expand = set()
        
        # Find all folders that should be expanded (containing checked files)
        for checked_path in checked_paths:
            # Get all parent directories of checked files
            path_parts = checked_path.split(os.sep)
            # Iterate up the path hierarchy to find parent directories
            current_path = ""
            for i, part in enumerate(path_parts):
                if i == 0:
                    current_path = part
                else:
                    current_path = os.path.join(current_path, part)
                
                # If it's a directory (and not the file itself)
                if current_path in self.path_to_item and os.path.isdir(self.path_to_item[current_path].data(0, QtCore.Qt.UserRole)):
                    folders_to_expand.add(self.path_to_item[current_path])
        
        # Expand the folders
        for item in folders_to_expand:
            self.tree_widget.expandItem(item)

    def auto_expand_common_folders(self):
        """Auto-expand common project folders on first load. (Currently not called from __init__)"""
        common_folders = ['src', 'lib', 'app', 'components', 'utils', 'helpers', 'models', 'views', 'controllers']
        
        for folder_name in common_folders:
            if folder_name in self.path_to_item:
                item = self.path_to_item[folder_name]
                self.tree_widget.expandItem(item)

    def load_from_prefs_button_clicked(self):
        prefs_path = _prefs_path()
        if os.path.exists(prefs_path):
            self.load_prefs_if_exists() # This re-populates self.checked_files_from_prefs etc.
            self.tree_widget.blockSignals(True)
            try:
                # First, deselect all files to provide a clean slate.
                # Directory states will be updated by handle_item_changed based on their children.
                iterator = QtWidgets.QTreeWidgetItemIterator(self.tree_widget)
                while iterator.value():
                    item = iterator.value()
                    # Only affect files here directly, directories will update based on children
                    if item.flags() & QtCore.Qt.ItemIsUserCheckable and os.path.isfile(item.data(0, QtCore.Qt.UserRole)):
                        item.setCheckState(0, QtCore.Qt.Unchecked) # Deselect all files first
                    iterator += 1

                # Then, check files based on preferences
                for rel_path in self.checked_files_from_prefs:
                    if rel_path in self.path_to_item:
                        item = self.path_to_item[rel_path]
                        if os.path.isfile(item.data(0, QtCore.Qt.UserRole)): # Only check files here
                            item.setCheckState(0, QtCore.Qt.Checked)
                            # Manually trigger parent updates for checked files, if not handled by setCheckState
                            parent = item.parent()
                            while parent:
                                if parent.checkState(0) != QtCore.Qt.PartiallyChecked and parent.checkState(0) != QtCore.Qt.Checked:
                                    # Set to partially checked if it was unchecked. Full check requires all children to be checked.
                                    parent.setCheckState(0, QtCore.Qt.PartiallyChecked) 
                                parent = parent.parent()

            finally:
                self.tree_widget.blockSignals(False)
            # Auto-expand folders after loading preferences
            self._expand_folders_for_paths(self.checked_files_from_prefs)
            file_type = ".auicp" if prefs_path.endswith(".auicp") else ".aicodeprep-gui"
            self.text_label.setText(f"Loaded selection from {file_type}")
            self.update_token_counter()
        else: 
            self.text_label.setText("No preferences file found (.aicodeprep-gui)")

    def closeEvent(self, event):
        # Clean up update thread if it's still running
        if self.update_thread and self.update_thread.isRunning():
            print("[gui] Stopping update check thread before closing...")
            self.update_thread.quit()
            if not self.update_thread.wait(3000):  # Wait up to 3 seconds
                print("[gui] Force terminating update check thread...")
                self.update_thread.terminate()
                self.update_thread.wait()
        
        if self.remember_checkbox and self.remember_checkbox.isChecked():
            self.save_prefs() # Save prefs only if 'remember' is checked
        if self.action != 'process': self.action = 'quit'
        super(FileSelectionGUI, self).closeEvent(event)

    def load_prefs_if_exists(self):
        checked, window_size, splitter_state = _read_prefs_file()
        self.checked_files_from_prefs = checked
        self.window_size_from_prefs = window_size
        self.splitter_state_from_prefs = splitter_state
        self.prefs_loaded = True

    def save_prefs(self):
        checked_relpaths = []
        # Iterate through path_to_item to get only the checked files (not directories)
        for rel_path, item in self.path_to_item.items():
            if item.checkState(0) == QtCore.Qt.Checked:
                file_path_abs = item.data(0, QtCore.Qt.UserRole)
                if file_path_abs and os.path.isfile(file_path_abs): # Only save files, not directories
                    checked_relpaths.append(rel_path)
        
        size = self.size()
        splitter_state = self.splitter.saveState()
        _write_prefs_file(checked_relpaths, window_size=(size.width(), size.height()), splitter_state=splitter_state)
        self._save_prompt_options()

    def _load_prompt_options(self):
        """Load global prompt/question placement options from QSettings."""
        settings = QtCore.QSettings("aicodeprep-gui", "PromptOptions")
        self.prompt_top_checkbox.setChecked(settings.value("prompt_to_top", True, type=bool))
        self.prompt_bottom_checkbox.setChecked(settings.value("prompt_to_bottom", True, type=bool))

    def _save_prompt_options(self):
        """Save global prompt/question placement options to QSettings."""
        settings = QtCore.QSettings("aicodeprep-gui", "PromptOptions")
        settings.setValue("prompt_to_top", self.prompt_top_checkbox.isChecked())
        settings.setValue("prompt_to_bottom", self.prompt_bottom_checkbox.isChecked())

    def _load_dark_mode_setting(self) -> bool:
        """Load dark mode preference from QSettings, or use system preference if not set."""
        try:
            settings = QtCore.QSettings("aicodeprep-gui", "Appearance")
            if settings.contains("dark_mode"):
                return settings.value("dark_mode", type=bool)
            else:
                # Use system preference as default, save it for next time
                dark = system_pref_is_dark()
                settings.setValue("dark_mode", dark)
                return dark
        except Exception as e:
            logging.error(f"Failed to load dark mode setting: {e}")
            # Fallback to system preference
            return system_pref_is_dark()

    def _save_dark_mode_setting(self):
        """Save current dark mode state to QSettings."""
        try:
            settings = QtCore.QSettings("aicodeprep-gui", "Appearance")
            settings.setValue("dark_mode", self.is_dark_mode)
        except Exception as e:
            logging.error(f"Failed to save dark mode setting: {e}")

    def toggle_dark_mode(self, state):
        self.is_dark_mode = bool(state)
        # 1. Apply the correct palette for the entire application
        if self.is_dark_mode:
            apply_dark_palette(self.app)
        else:
            apply_light_palette(self.app)

        # 2. Re-apply the main window's font stylesheet to force style refresh
        font_stack = '"Segoe UI", "Ubuntu", "Helvetica Neue", Arial, sans-serif'
        self.setStyleSheet(f"font-family: {font_stack};")

        # 3. Now, apply the more specific widget styles as before
        base_style = """
            QTreeView, QTreeWidget {
                outline: 2; /* Remove focus rectangle */
            }
        """
        checkbox_style = get_checkbox_style_dark() if self.is_dark_mode else get_checkbox_style_light()
        self.tree_widget.setStyleSheet(base_style + checkbox_style)
        
        # Update theme-aware styles for other widgets
        self.vibe_label.setStyleSheet(
            "background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #40203f, stop:1 #1f103f); "
            "color: white; padding: 0px 0px 0px 0px; border-radius: 8px;"
        )
        # Find preset_explanation and text_label by attribute
        for child in self.findChildren(QtWidgets.QLabel):
            if getattr(child, "objectName", lambda: "")() == "preset_explanation":
                child.setStyleSheet(
                    f"font-size: 10px; color: {'#bbbbbb' if self.is_dark_mode else '#444444'};"
                )
        # Update the status label's style if it has text
        if self.text_label.text():
            self.text_label.setStyleSheet(
                f"font-size: 20px; color: {'#00c3ff' if self.is_dark_mode else '#0078d4'}; font-weight: bold;"
            )

        # Save the user's dark mode preference
        self._save_dark_mode_setting()

    def _start_update_check(self):
        """Start the update check and store the thread reference."""
        print("[gui] Starting update check...")
        self.update_thread = update_checker.check_for_updates(self._on_update_checked, parent=self, force=self.force_update)
        if self.update_thread:
            print("[gui] Update check thread started")
        else:
            print("[gui] Update check skipped (already checked recently)")

    def _on_update_checked(self, new_available: bool, latest: str):
        """Slot called when update check completes."""

        # --- Update label logic ---
        if hasattr(self, "update_label"):
            if new_available:
                self.update_label.setText('Update available! Open a terminal and type:<br><b>pipx upgrade aicodeprep-gui</b>')
                self.update_label.setStyleSheet("color: #28a745; font-weight: bold;")
                self.update_label.setVisible(True)
            else:
                self.update_label.setVisible(False)

        self.latest_pypi_version = latest
        print(f"[gui] Update check callback received - New available: {new_available}, Latest: {latest}")
        from PySide6.QtCore import QSettings, QDate, QDateTime, Qt
        from PySide6.QtWidgets import QMessageBox, QPushButton
        import subprocess

        ORG = "aicodeprep-gui"
        GROUP = "UpdateChecker"
        KEY_LAST_PROMPT = "last_prompt"
        KEY_PROMPTED_THIS_RUN = "prompted_this_run"

        settings = QSettings(ORG, GROUP)
        today = QDate.currentDate().toString(Qt.ISODate)
        prompted_this_run = settings.value(KEY_PROMPTED_THIS_RUN, False, type=bool)
        last_prompt = settings.value(KEY_LAST_PROMPT, "")

        print(f"[gui] Prompt check - prompted_this_run: {prompted_this_run}, last_prompt: {last_prompt}, today: {today}")

        # Only prompt if new version, not already prompted today, and not this run
        if not new_available or prompted_this_run or last_prompt == today:
            print("[gui] Not showing update dialog (conditions not met)")
            return

        print("[gui] Showing update available dialog")

        # Mark as prompted for this run and today
        settings.setValue(KEY_PROMPTED_THIS_RUN, True)
        settings.setValue(KEY_LAST_PROMPT, today)

        msg = QMessageBox(self)
        msg.setWindowTitle("Update Available")
        msg.setIcon(QMessageBox.Information)
        msg.setText(
            f"A new version of aicodeprep-gui is available: {latest}. You are on {__version__}.\n"
            "Would you like to upgrade now?"
        )
        upgrade_btn = msg.addButton("Upgrade", QMessageBox.AcceptRole)
        later_btn = msg.addButton("Later", QMessageBox.RejectRole)
        msg.setStandardButtons(QMessageBox.NoButton)
        msg.setModal(False)
        msg.show()

        def on_button_clicked(btn):
            if btn == upgrade_btn:
                # Run pipx upgrade in subprocess, show result
                try:
                    proc = subprocess.Popen(
                        ["pipx", "install", "--upgrade", "aicodeprep-gui"],
                        stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
                    )
                    out, err = proc.communicate(timeout=120)
                    if proc.returncode == 0:
                        QMessageBox.information(self, "Upgrade Complete", "aicodeprep-gui was upgraded successfully.\nPlease restart the application.")
                    else:
                        QMessageBox.warning(self, "Upgrade Failed", f"Upgrade failed:\n{err or out}")
                except Exception as e:
                    QMessageBox.critical(self, "Upgrade Error", f"Could not run upgrade:\n{e}")
            msg.close()

        msg.buttonClicked.connect(on_button_clicked)

    def showEvent(self, event):
        super(FileSelectionGUI, self).showEvent(event)
        if getattr(self, "initial_show_event", False):
            QtCore.QTimer.singleShot(0, self._start_update_check)
            self.initial_show_event = False

    def open_complain_dialog(self):
        """Open the feedback/complain dialog."""
        import requests

        class FeedbackDialog(QtWidgets.QDialog):
            def __init__(self, parent=None):
                super().__init__(parent)
                self.setWindowTitle("Send Feedback / Complain")
                self.setMinimumWidth(400)
                layout = QtWidgets.QVBoxLayout(self)

                layout.addWidget(QtWidgets.QLabel("Your Email (optional):"))
                self.email_input = QtWidgets.QLineEdit()
                self.email_input.setPlaceholderText("you@example.com")
                layout.addWidget(self.email_input)

                layout.addWidget(QtWidgets.QLabel("Message / Complaint:"))
                self.msg_input = QtWidgets.QPlainTextEdit()
                self.msg_input.setPlaceholderText("Describe your feedback, bug, or complaint here...")
                layout.addWidget(self.msg_input)

                self.status_label = QtWidgets.QLabel("")
                self.status_label.setStyleSheet("color: #d43c2c;")
                layout.addWidget(self.status_label)

                btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
                btns.accepted.connect(self.accept)
                btns.rejected.connect(self.reject)
                layout.addWidget(btns)

            def get_data(self):
                return self.email_input.text().strip(), self.msg_input.toPlainText().strip()

        dlg = FeedbackDialog(self)
        if dlg.exec() != QtWidgets.QDialog.Accepted:
            return

        email, message = dlg.get_data()
        if not email and not message:
            QtWidgets.QMessageBox.warning(self, "Error", "Please enter at least an email or a message.")
            return

        try:
            if message:
                # Submit bug report
                user_uuid = QtCore.QSettings("aicodeprep-gui", "UserIdentity").value("user_uuid", "")
                payload = {
                    "data": {
                        "summary": message.splitlines()[0][:80] if message else "No summary",
                        "details": message
                    },
                    "source_identifier": "aicodeprep-gui"
                }
                headers = {"Content-Type": "application/json"}
                if user_uuid:
                    headers["X-Client-ID"] = user_uuid
                resp = requests.post("https://wuu73.org/idea/collect/bug-report", json=payload, headers=headers, timeout=10)
                if resp.status_code == 200:
                    QtWidgets.QMessageBox.information(self, "Thank you", "Your feedback/complaint was submitted successfully.")
                else:
                    QtWidgets.QMessageBox.critical(self, "Error", f"Submission failed: {resp.status_code} {resp.text}")
            else:
                # Only email provided
                resp = requests.post("https://wuu73.org/idea/collect/submit", json={"email": email}, timeout=10)
                if resp.status_code == 200:
                    QtWidgets.QMessageBox.information(self, "Thank you", "Your email was submitted successfully.")
                else:
                    QtWidgets.QMessageBox.critical(self, "Error", f"Submission failed: {resp.status_code} {resp.text}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Could not submit feedback: {e}")

    def open_about_dialog(self):
        """Show About dialog with version, install age, and links."""
        # read install_date from user settings
        settings = QtCore.QSettings("aicodeprep-gui", "UserIdentity")
        install_date_str = settings.value("install_date", "")
        try:
            dt = datetime.fromisoformat(install_date_str)
            days_installed = (datetime.now() - dt).days
        except Exception:
            days_installed = 0

        # build HTML content
        version_str = __version__

        pypi_version_info = ""
        if self.latest_pypi_version:
            is_newer = update_checker.is_newer_version(__version__, self.latest_pypi_version)
            if is_newer:
                status_text = '<span style="color: #28a745; font-weight: bold;">(Update available)</span>'
            else:
                status_text = '<span style="color: grey;">(Up to date)</span>'
            pypi_version_info = f'<p>Latest version: {self.latest_pypi_version} {status_text}</p>'
        else:
            pypi_version_info = '<p>Latest version: <span style="color: grey;">Checking PyPI...</span></p>'

        html = (
            f"<h2>aicodeprep-gui</h2>"
            f"<p>Installed version: {version_str}</p>"
            f"{pypi_version_info}"
            f"<p>Installed {days_installed} days ago.</p>"
            "<p>"
            '<br><a href="https://github.com/sponsors/detroittommy879">GitHub Sponsors</a><br>'
            '<a href="https://wuu73.org/aicp">AI Code Prep Homepage</a>'
            "</p>"
        )
        # show in rich-text message box
        dlg = QtWidgets.QMessageBox(self)
        dlg.setWindowTitle("About aicodeprep-gui")
        dlg.setTextFormat(QtCore.Qt.RichText)
        dlg.setText(html)
        dlg.setStandardButtons(QtWidgets.QMessageBox.Ok)
        dlg.exec()

def show_file_selection_gui(files, force_update=False):
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])
    gui = FileSelectionGUI(files, force_update=force_update)
    gui.show()
    app.exec()
    return gui.action, gui.get_selected_files()

def _prefs_path():
    """Get the path to the preferences file, preferring .aicodeprep-gui, with .auicp as legacy for migration"""
    new_path = os.path.join(os.getcwd(), ".aicodeprep-gui")
    legacy_path = os.path.join(os.getcwd(), ".auicp")
    # Prefer new file
    if os.path.exists(new_path):
        return new_path
    # Fallback to legacy for migration
    elif os.path.exists(legacy_path):
        return legacy_path
    # Default to new file for new saves
    else:
        return new_path

def _write_prefs_file(checked_relpaths, window_size=None, splitter_state=None):
    """Write preferences to .aicodeprep-gui file"""
    new_path = os.path.join(os.getcwd(), ".aicodeprep-gui")
    try:
        with open(new_path, "w", encoding="utf-8") as f:
            header = (
                f"# .aicodeprep-gui LLM/AI context helper settings file\n"
                f"# This file stores your preferences (checked code files, window size) for this folder.\n"
                f"# Generated by aicodeprep-gui.\n"
                f"# Homepage: https://wuu73.org/aicp\n"
                f"# GitHub: https://github.com/detroittommy879/aicodeprep-gui\n"
                f"# ----------------------------------------------------------\n"
                f"# aicodeprep-gui preferences file version {AICODEPREP_GUI_VERSION}\n"
            )
            f.write(header)
            f.write(f"version={AICODEPREP_GUI_VERSION}\n\n")
            if window_size:
                f.write(f"[window]\nwidth={window_size[0]}\nheight={window_size[1]}\n")
                if splitter_state is not None:
                    # Convert QByteArray to base64 string for storage
                    import base64
                    splitter_data = base64.b64encode(splitter_state).decode('utf-8')
                    f.write(f"splitter_state={splitter_data}\n")
                f.write("\n")
            if checked_relpaths: f.write("[files]\n" + "\n".join(checked_relpaths) + "\n")
        logging.info(f"Saved preferences to {new_path}")
    except Exception as e: 
        logging.warning(f"Could not write .aicodeprep-gui: {e}")

def _read_prefs_file():
    """Read preferences file with backwards compatibility for legacy .auicp files (migrates to .aicodeprep-gui)"""
    checked, window_size, splitter_state = set(), None, None
    width_val, height_val = None, None 

    legacy_path = os.path.join(os.getcwd(), ".auicp")
    new_path = os.path.join(os.getcwd(), ".aicodeprep-gui")

    prefs_path = _prefs_path()

    try:
        with open(prefs_path, "r", encoding="utf-8") as f:
            section = None
            for line in f.read().splitlines():
                if line.strip().startswith('[') and line.strip().endswith(']'):
                    section = line.strip()[1:-1]
                    continue
                if not section: continue

                if section == "files":
                    if line.strip(): checked.add(line.strip())
                elif section == "window":
                    if line.startswith('width='):
                        try: width_val = int(line.split('=')[1])
                        except (ValueError, IndexError): pass
                    elif line.startswith('height='):
                        try: height_val = int(line.split('=')[1])
                        except (ValueError, IndexError): pass
                    elif line.startswith('splitter_state='):
                        try:
                            import base64
                            splitter_data = line.split('=', 1)[1]
                            splitter_state = base64.b64decode(splitter_data.encode('utf-8'))
                        except Exception as e:
                            logging.warning(f"Failed to decode splitter state: {e}")

            if width_val is not None and height_val is not None:
                window_size = (width_val, height_val)

        # Migration logic: if we read from .auicp, migrate to .aicodeprep-gui
        if prefs_path == legacy_path and not os.path.exists(new_path):
            logging.info("Migrating preferences from .auicp to .aicodeprep-gui")
            try:
                # Write the data to the new .aicodeprep-gui file
                _write_prefs_file(list(checked), window_size, splitter_state) 
                logging.info("Successfully migrated preferences to .aicodeprep-gui")
            except Exception as e:
                logging.error(f"Failed to migrate preferences: {e}")

    except FileNotFoundError:
        file_type = ".auicp" if prefs_path.endswith(".auicp") else ".aicodeprep-gui"
        logging.info(f"{file_type} file not found, will create on save.")
    except Exception as e:
        logging.error(f"Error reading preferences file: {e}")

    return checked, window_size, splitter_state

</code>

aicodeprep_gui\linux_installer.py:
<code>
import os
import shutil
import logging

NAUTILUS_SCRIPTS_DIR = os.path.expanduser("~/.local/share/nautilus/scripts")
SCRIPT_NAME = "Open with aicodeprep-gui"

# The shell script to be placed in the Nautilus scripts directory.
NAUTILUS_SCRIPT_CONTENT = """
#!/bin/bash

# Nautilus script for aicodeprep-gui.
# It processes the first selected directory.

# Find the command path. 'which' should work as this script runs in a user session.
CMD_PATH=$(which aicodeprep-gui)

if [ -z "$CMD_PATH" ]; then
    # Use zenity for a graphical error message if available
    if command -v zenity &> /dev/null; then
        zenity --error --width=300 --text="<b>aicodeprep-gui command not found.</b>\\n\\nPlease ensure it's installed and accessible from your terminal's PATH."
    fi
    exit 1
fi

# Nautilus provides selected paths as arguments.
TARGET_DIR="$1"

if [ -n "$TARGET_DIR" ] && [ -d "$TARGET_DIR" ]; then
    # Run the GUI, passing the selected directory.
    # Run in the background to not block Nautilus.
    "$CMD_PATH" "$TARGET_DIR" &
else
    if command -v zenity &> /dev/null; then
        zenity --info --text="Please select a directory to use this script."
    fi
fi
"""

def is_nautilus_installed():
    """Check if Nautilus file manager is likely installed."""
    return shutil.which('nautilus') is not None

def install_nautilus_script():
    """Installs the context menu script for the Nautilus file manager."""
    if not is_nautilus_installed():
        return False, "Nautilus file manager not found."

    try:
        os.makedirs(NAUTILUS_SCRIPTS_DIR, exist_ok=True)
        script_path = os.path.join(NAUTILUS_SCRIPTS_DIR, SCRIPT_NAME)
        
        with open(script_path, "w") as f:
            f.write(NAUTILUS_SCRIPT_CONTENT)
        
        # Make the script executable
        os.chmod(script_path, 0o755)

        msg = (f"Nautilus script '{SCRIPT_NAME}' installed successfully. "
               "Please restart Nautilus (nautilus -q) or log out and back in for it to appear.")
        logging.info(msg)
        return True, msg
    except Exception as e:
        msg = f"Failed to install Nautilus script: {e}"
        logging.error(msg)
        return False, msg

def uninstall_nautilus_script():
    """Uninstalls the context menu script for Nautilus."""
    script_path = os.path.join(NAUTILUS_SCRIPTS_DIR, SCRIPT_NAME)
    if os.path.exists(script_path):
        try:
            os.remove(script_path)
            msg = f"Nautilus script '{SCRIPT_NAME}' has been uninstalled."
            logging.info(msg)
            return True, msg
        except Exception as e:
            msg = f"Failed to uninstall Nautilus script: {e}"
            logging.error(msg)
            return False, msg
    else:
        msg = "Nautilus script not found (already uninstalled)."
        return True, msg

</code>

aicodeprep_gui\macos_installer.py:
<code>
import os
import shutil
import logging
import zipfile
import subprocess
from importlib import resources

# The name of the workflow bundle
WORKFLOW_NAME = "AICodePrep.workflow"

# The standard location for user-installed services/quick actions
SERVICES_DIR = os.path.expanduser("~/Library/Services")

def install_quick_action():
    """
    Extracts the AICodePrep.workflow.zip from package data to the user's Desktop
    and instructs them to double-click it for installation.
    """
    try:
        desktop_path = os.path.expanduser("~/Desktop")
        destination_workflow_path = os.path.join(desktop_path, WORKFLOW_NAME)
        zip_filename = f"{WORKFLOW_NAME}.zip"

        # Ensure the desktop exists
        os.makedirs(desktop_path, exist_ok=True)

        # If the workflow file already exists on the desktop, remove it first for a clean copy
        if os.path.exists(destination_workflow_path):
            logging.info(f"Removing existing '{WORKFLOW_NAME}' from Desktop before extraction.")
            shutil.rmtree(destination_workflow_path)

        # Find the zip file in the package data and extract it
        logging.info(f"Extracting '{zip_filename}' to Desktop...")
        with resources.files('aicodeprep_gui.data').joinpath(zip_filename).open('rb') as zip_file_obj:
            with zipfile.ZipFile(zip_file_obj, 'r') as zip_ref:
                zip_ref.extractall(desktop_path)

        # Open Finder to show the user the file
        subprocess.run(["open", desktop_path])

        msg = (
            f"The installer ('{WORKFLOW_NAME}') has been placed on your Desktop.\n\n"
            "Please follow these steps:\n"
            "1. Go to your Desktop.\n"
            "2. Double-click the 'AICodePrep' workflow file.\n"
            "3. Click 'Install' in the dialog that appears.\n\n"
            "The Quick Action will then be available when you right-click a folder in Finder."
        )
        logging.info("Successfully extracted workflow to Desktop for manual installation.")
        return True, msg

    except FileNotFoundError:
        msg = "Error: Could not find the installer 'AICodePrep.workflow.zip' inside the package."
        logging.error(msg)
        return False, msg
    except Exception as e:
        msg = f"An unexpected error occurred: {e}"
        logging.error(msg)
        return False, msg


def uninstall_quick_action():
    """Removes the macOS Quick Action from the user's Library."""
    dest_path = os.path.join(SERVICES_DIR, WORKFLOW_NAME)
    if os.path.exists(dest_path):
        try:
            shutil.rmtree(dest_path)
            # Attempt to refresh services to make the change immediate
            try:
                subprocess.run(["/System/Library/CoreServices/pbs", "-flush"], check=False, timeout=5)
            except (subprocess.TimeoutExpired, FileNotFoundError) as e:
                 logging.warning(f"Could not flush services cache during uninstall: {e}")
            msg = f"Quick Action '{WORKFLOW_NAME}' has been uninstalled."
            logging.info(msg)
            return True, msg
        except Exception as e:
            msg = f"Failed to uninstall Quick Action: {e}"
            logging.error(msg)
            return False, msg
    else:
        msg = "Quick Action was not found (already uninstalled)."
        logging.info(msg)
        return True, msg
</code>

aicodeprep_gui\main.py:
<code>
import os
import sys
import platform
import ctypes
from PySide6.QtCore import QSettings

# Handle --delset command-line option to delete user settings and exit
if "--delset" in sys.argv:
    # Delete ButtonPresets
    QSettings("aicodeprep-gui", "ButtonPresets").clear()
    # Delete PromptOptions
    QSettings("aicodeprep-gui", "PromptOptions").clear()
    # Delete UserIdentity
    QSettings("aicodeprep-gui", "UserIdentity").clear()
    print("All aicodeprep-gui user settings deleted.")
    sys.exit(0)
import argparse
import logging
from typing import List
from aicodeprep_gui.smart_logic import collect_all_files
from aicodeprep_gui.gui import show_file_selection_gui

# Configure logging with explicit console handler only
logger = logging.getLogger()

# Remove any existing handlers to prevent duplicate logging
for handler in logger.handlers:
    logger.removeHandler(handler)

logger.setLevel(logging.INFO)

# Create console handler
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
console_handler.setFormatter(formatter)

# Add handler to root logger
logger.addHandler(console_handler)

def main():
    parser = argparse.ArgumentParser(description="aicodeprep-gui: A smart GUI for preparing code repositories for AI analysis. Select and bundle files to be copied into your clipboard.")
    parser.add_argument("-n", "--no-copy", action="store_true",
                        help="Do NOT copy output to clipboard (default: copy to clipboard)")
    parser.add_argument("-o", "--output", default="fullcode.txt",
                        help="Output file name (default: fullcode.txt)")
    parser.add_argument("-d", "--debug", action="store_true",
                        help="Enable debug logging")
    parser.add_argument("directory", nargs="?", default=".",
                        help="Directory to process (default: current directory)")
    parser.add_argument("--force-update-check", action="store_true",
                        help="Force update check (ignore 24h limit)")

    # --- ADD THESE NEW ARGUMENTS ---
    if platform.system() == "Windows":
        parser.add_argument("--install-context-menu-privileged", action="store_true", help=argparse.SUPPRESS)
        parser.add_argument("--remove-context-menu-privileged", action="store_true", help=argparse.SUPPRESS)
        parser.add_argument("--menu-text", type=str, help=argparse.SUPPRESS)
        parser.add_argument("--disable-classic-menu", action="store_true", help=argparse.SUPPRESS)
    # --- END OF NEW ARGUMENTS ---

    args = parser.parse_args()
    force_update = args.force_update_check

    # Set Windows AppUserModelID for proper taskbar icon
    if platform.system() == "Windows":
        myappid = 'wuu73.aicodeprep-gui.1.0.6'  # arbitrary unique string
        try:
            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)
        except AttributeError:
            # Fails on older Windows versions, but that's acceptable.
            logging.warning("Could not set AppUserModelID. Taskbar icon may not be correct on older Windows.")

    # --- ADD THIS NEW LOGIC BLOCK ---
    if platform.system() == "Windows":
        try:
            from aicodeprep_gui import windows_registry
        except ImportError:
            windows_registry = None
        if args.install_context_menu_privileged and windows_registry:
            print("Running privileged action: Install context menu...")
            menu_text = getattr(args, 'menu_text', None)
            enable_classic = not getattr(args, 'disable_classic_menu', False)
            windows_registry.install_context_menu(menu_text, enable_classic_menu=enable_classic)
            sys.exit(0)
        if args.remove_context_menu_privileged and windows_registry:
            print("Running privileged action: Remove context menu...")
            windows_registry.remove_context_menu()
            sys.exit(0)
    # --- END OF NEW LOGIC BLOCK ---

    # Ensure Fusion style for QSS consistency
    from PySide6 import QtWidgets
    app = QtWidgets.QApplication.instance()
    if app is None:
        app = QtWidgets.QApplication(sys.argv)
    app.setStyle("Fusion")

    # Set application icon from package favicon.ico
    from PySide6.QtGui import QIcon
    from importlib import resources
    with resources.as_file(resources.files('aicodeprep_gui.images').joinpath('favicon.ico')) as icon_path:
        app.setWindowIcon(QIcon(str(icon_path)))

    if args.debug:
        logger.setLevel(logging.DEBUG)
        console_handler.setLevel(logging.DEBUG)

    # Get the target directory from the parsed arguments
    target_dir = args.directory
    logger.info(f"Target directory: {target_dir}")

    # Change to the specified directory with error handling
    try:
        os.chdir(target_dir)
    except FileNotFoundError:
        logger.error(f"Directory not found: {target_dir}")
        return
    except Exception as e:
        logger.error(f"Error changing directory: {e}")
        return

    logger.info("Starting code concatenation...")

    all_files_with_flags = collect_all_files()

    if not all_files_with_flags:
        logger.warning("No files found to process!")
        return

    action, _ = show_file_selection_gui(all_files_with_flags, force_update=force_update)

    if action != 'quit':
        logger.info("Buy my cat a treat, comments, ideas for improvement appreciated: ")
        logger.info("https://wuu73.org/hello.html")

if __name__ == "__main__":
    main()

</code>

aicodeprep_gui\smart_logic.py:
<code>
from importlib import resources
import os
import sys
import logging
from typing import List, Tuple
import fnmatch

# New imports for the refactoring
import toml
from pathspec import PathSpec
from pathspec.patterns import GitWildMatchPattern

def get_config_path():
    """Get the path to the default configuration file."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
        config_path = os.path.join(base_path, 'aicodeprep_gui', 'data', 'default_config.toml')
    else:
        try:
            with resources.path('aicodeprep_gui.data', 'default_config.toml') as config_file:
                config_path = str(config_file)
        except ModuleNotFoundError:
            config_path = os.path.join(os.path.dirname(__file__), 'data', 'default_config.toml')
    return config_path

def load_config_from_path(path: str) -> dict:
    """Loads a TOML configuration file from a given path."""
    if not os.path.exists(path):
        return {}
    try:
        with open(path, "r", encoding="utf-8") as f:
            return toml.load(f)
    except Exception as e:
        logging.error(f"Error loading or parsing TOML config at {path}: {e}")
        return {}

def load_configurations() -> dict:
    """Load default config, then load user config and merge them."""
    default_config_path = get_config_path()
    config = load_config_from_path(default_config_path)
    if not config:
        logging.critical("Failed to load default configuration. Exiting.")
        sys.exit("Could not load the default configuration file.")
    user_config_path = os.path.join(os.getcwd(), 'aicodeprep-gui.toml')
    user_config = load_config_from_path(user_config_path)
    if user_config:
        logging.info(f"Found user configuration at {user_config_path}. Merging settings.")
        config.update(user_config)
    return config

def is_binary_file(filepath: str) -> bool:
    """Return True if this file is likely binary."""
    try:
        with open(filepath, 'rb') as f: chunk = f.read(1024)
    except OSError: return False
    if chunk.startswith((b'\xEF\xBB\xBF', b'\xFF\xFE', b'\xFE\xFF', b'\xFF\xFE\x00\x00', b'\x00\x00\xFE\xFF')): return False
    return b'\x00' in chunk

# --- CONFIG AND PATHSPEC LOADING ---
config = load_configurations()
CODE_EXTENSIONS = set(config.get('code_extensions', []))
MAX_FILE_SIZE = config.get('max_file_size', 1000000)
exclude_spec = PathSpec.from_lines(GitWildMatchPattern, config.get('exclude_patterns', []))
include_spec = PathSpec.from_lines(GitWildMatchPattern, config.get('default_include_patterns', []))
# These are still useful for some simple checks in the GUI and logic
EXCLUDE_DIRS = [p.rstrip('/') for p in config.get('exclude_patterns', []) if p.endswith('/')]
EXCLUDE_FILES = [p for p in config.get('exclude_patterns', []) if not p.endswith('/')]
EXCLUDE_PATTERNS = EXCLUDE_FILES # Simplified for backward compatibility
INCLUDE_FILES = config.get('default_include_patterns', [])
INCLUDE_DIRS = [p.rstrip('/') for p in INCLUDE_FILES if p.endswith('/')]
EXCLUDE_EXTENSIONS = [] # This concept is now handled by patterns

# --- REWRITTEN collect_all_files FOR LAZY LOADING ---
def collect_all_files() -> List[Tuple[str, str, bool]]:
    """
    Collects files and directories. For excluded directories, it returns them as
    a single entry without their contents, allowing the GUI to lazy-load them.
    Returns a list of (absolute_path, relative_path, is_checked_by_default).
    """
    all_paths = []
    root_dir = os.getcwd()
    seen_paths = set()
    logging.info(f"Starting initial fast scan in: {root_dir}")

    for root, dirs, files in os.walk(root_dir, topdown=True):
        rel_root = os.path.relpath(root, root_dir)
        if rel_root == '.': rel_root = ''

        # Add the directory itself unless it's the root
        if rel_root and root not in seen_paths:
             all_paths.append((root, rel_root, False))
             seen_paths.add(root)

        # Prune directories from the walk
        dirs_to_prune = []
        for d in dirs:
            rel_dir_path = os.path.join(rel_root, d)
            if exclude_spec.match_file(rel_dir_path + '/'):
                dirs_to_prune.append(d)
        dirs[:] = [d for d in dirs if d not in dirs_to_prune]

        # Process all items (unpruned dirs and files)
        for name in dirs + files:
            abs_path = os.path.join(root, name)
            rel_path = os.path.join(rel_root, name)
            if abs_path in seen_paths: continue

            # Determine default check state
            is_checked = False
            check_path = rel_path + '/' if os.path.isdir(abs_path) else rel_path

            if include_spec.match_file(check_path):
                is_checked = True
            elif os.path.isfile(abs_path) and os.path.splitext(name)[1].lower() in CODE_EXTENSIONS:
                 is_checked = True

            # Final filters for files
            if os.path.isfile(abs_path):
                if is_binary_file(abs_path) or os.path.getsize(abs_path) > MAX_FILE_SIZE:
                    is_checked = False

            all_paths.append((abs_path, rel_path, is_checked))
            seen_paths.add(abs_path)

    logging.info(f"Initial scan collected {len(all_paths)} items.")
    return all_paths

def is_excluded_directory(path: str) -> bool:
    """Simplified check used by GUI folder-click logic."""
    dir_name = os.path.basename(path)
    return any(fnmatch.fnmatch(dir_name, pat) for pat in EXCLUDE_DIRS)

def matches_pattern(filename: str, pattern: str) -> bool:
    """Helper used by GUI logic."""
    return fnmatch.fnmatch(filename.lower(), pattern.lower())

</code>

aicodeprep_gui\update_checker.py:
<code>
import datetime
import sys
import traceback
from typing import Callable, Optional

from PySide6.QtCore import QObject, QThread, Signal, QSettings, QDateTime, Qt, QTimer
from packaging.version import parse as parse_version

try:
    import requests
except ImportError:
    requests = None

from . import __version__

PYPI_URL = "https://pypi.org/pypi/aicodeprep-gui/json"
ORG = "aicodeprep-gui"
GROUP = "UpdateChecker"
KEY_LAST_CHECK = "last_check"
KEY_LAST_PROMPT = "last_prompt"
KEY_PROMPTED_THIS_RUN = "prompted_this_run"

def get_latest_pypi_version() -> Optional[str]:
    """Fetch latest version string from PyPI. Returns None on error."""
    if not requests:
        return None
    try:
        resp = requests.get(PYPI_URL, timeout=5)
        resp.raise_for_status()
        data = resp.json()
        return data["info"]["version"]
    except Exception as e:
        print(f"[update_checker] Error fetching PyPI version: {e}", file=sys.stderr)
        traceback.print_exc()
        return None

def is_newer_version(current: str, latest: str) -> bool:
    """Return True if latest > current (semantic version compare)."""
    try:
        return parse_version(latest) > parse_version(current)
    except Exception as e:
        print(f"[update_checker] Version compare error: {e}", file=sys.stderr)
        return False

class _UpdateFetchWorker(QObject):
    finished = Signal(bool, str)
    def __init__(self, current_version: str):
        QObject.__init__(self)
        self.current_version = current_version

    def do_work(self):
        print(f"[update_checker] Worker running - fetching latest version from PyPI...")
        latest = get_latest_pypi_version()
        if latest is None:
            print(f"[update_checker] Failed to fetch latest version from PyPI")
            self.finished.emit(False, latest if latest else "")
            return
        print(f"[update_checker] Latest version from PyPI: {latest}, Current: {self.current_version}")
        new_available = is_newer_version(self.current_version, latest)
        print(f"[update_checker] Version comparison - New available: {new_available}")
        self.finished.emit(new_available, latest)

class UpdateChecker(QObject):
    """Thread-safe update checker that emits signals."""
    update_finished = Signal(bool, str)  # new_available, latest_version
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.thread = None
        self.worker = None

    def check_for_updates(self, force: bool = False) -> bool:
        """Check for updates. Returns True if check was started, False if skipped.
        Connect to update_finished signal to get results."""
        print(f"[update_checker] Starting update check for version {__version__}")
        settings = QSettings(ORG, GROUP)
        # Reset the prompted flag for new run so we can prompt once per day
        settings.setValue(KEY_PROMPTED_THIS_RUN, False)
        print("[update_checker] Reset prompted_this_run flag to False")
        last_check_str = settings.value(KEY_LAST_CHECK, "")
        # NEW: Store and retrieve last known version
        last_known_version = settings.value("last_known_version", "")
        now = QDateTime.currentDateTimeUtc()
        if last_check_str and not force:
            try:
                last_check = QDateTime.fromString(last_check_str, Qt.ISODate)
                if last_check.isValid() and last_check.secsTo(now) < 86400:
                    print(f"[update_checker] Skipping check - last checked {last_check_str} (< 24h ago)")
                    # Use last known version if available
                    if last_known_version:
                        is_newer = is_newer_version(__version__, last_known_version)
                        # Emit signal on main thread via QTimer
                        QTimer.singleShot(0, lambda: self.update_finished.emit(is_newer, last_known_version))
                    else:
                        QTimer.singleShot(0, lambda: self.update_finished.emit(False, ""))
                    return False
            except Exception as e:
                print(f"[update_checker] Error parsing last_check: {e}", file=sys.stderr)
        
        print("[update_checker] Starting background update check thread")
        # Run fetch in background thread
        self.thread = QThread(self)
        self.worker = _UpdateFetchWorker(__version__)
        self.worker.moveToThread(self.thread)
        
        def on_finish(new_available, latest):
            print(f"[update_checker] Check completed - New available: {new_available}, Latest: {latest}")
            # Schedule ALL operations on the main thread, including QSettings access and signal emission
            def main_thread_operations():
                settings.setValue(KEY_LAST_CHECK, now.toString(Qt.ISODate))
                # NEW: Store the latest version for future use
                if latest:
                    settings.setValue("last_known_version", latest)
                self.update_finished.emit(new_available, latest)
            QTimer.singleShot(0, main_thread_operations)
            self.thread.quit()
            
        self.worker.finished.connect(on_finish)
        self.thread.finished.connect(self.thread.deleteLater)
        self.thread.started.connect(self.worker.do_work)
        self.thread.start()
        return True

def check_for_updates(callback: Callable[[bool, str], None], parent=None, force: bool = False) -> Optional[QThread]:
    """Legacy function for backwards compatibility. 
    Returns the QThread if one is created, None if check is skipped."""
    print(f"[update_checker] Starting update check for version {__version__}")
    settings = QSettings(ORG, GROUP)
    # Reset the prompted flag for new run so we can prompt once per day
    settings.setValue(KEY_PROMPTED_THIS_RUN, False)
    print("[update_checker] Reset prompted_this_run flag to False")
    last_check_str = settings.value(KEY_LAST_CHECK, "")
    # NEW: Store and retrieve last known version
    last_known_version = settings.value("last_known_version", "")
    now = QDateTime.currentDateTimeUtc()
    if last_check_str and not force:
        try:
            last_check = QDateTime.fromString(last_check_str, Qt.ISODate)
            if last_check.isValid() and last_check.secsTo(now) < 86400:
                print(f"[update_checker] Skipping check - last checked {last_check_str} (< 24h ago)")
                # Use last known version if available
                if last_known_version:
                    is_newer = is_newer_version(__version__, last_known_version)
                    # Schedule callback on main thread via QTimer
                    QTimer.singleShot(0, lambda: callback(is_newer, last_known_version))
                else:
                    QTimer.singleShot(0, lambda: callback(False, ""))
                return None
        except Exception as e:
            print(f"[update_checker] Error parsing last_check: {e}", file=sys.stderr)

    print("[update_checker] Starting background update check thread")
    # Run fetch in background thread - simplified approach
    thread = QThread(parent)
    worker = _UpdateFetchWorker(__version__)
    worker.moveToThread(thread)
    
    def on_finish(new_available, latest):
        print(f"[update_checker] Check completed - New available: {new_available}, Latest: {latest}")
        # CRITICAL: Schedule everything on main thread and quit thread immediately
        def main_thread_callback():
            try:
                settings.setValue(KEY_LAST_CHECK, now.toString(Qt.ISODate))
                if latest:
                    settings.setValue("last_known_version", latest)
                callback(new_available, latest)
            except Exception as e:
                print(f"[update_checker] Error in main thread callback: {e}")
            finally:
                # Clean up thread
                if thread.isRunning():
                    thread.quit()
                    thread.wait(1000)  # Wait up to 1 second
        
        QTimer.singleShot(0, main_thread_callback)
    
    worker.finished.connect(on_finish)
    thread.started.connect(worker.do_work)
    thread.finished.connect(thread.deleteLater)
    thread.start()
    return thread

</code>

aicodeprep_gui\windows_registry.py:
<code>
import sys
import os
import winreg
import ctypes
import shutil
import logging

def enable_classic_context_menu():
    """
    Enables the classic right-click context menu on Windows 11 by creating the required registry key.
    """
    try:
        key_path = r"Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32"
        with winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path) as key:
            winreg.SetValueEx(key, "", 0, winreg.REG_SZ, "")
        logging.info("Classic context menu enabled (Windows 11).")
        return True, "Classic context menu enabled."
    except Exception as e:
        logging.error(f"Failed to enable classic context menu: {e}")
        return False, f"Failed to enable classic context menu: {e}"

def disable_classic_context_menu():
    """
    Disables the classic right-click context menu on Windows 11 by deleting the registry key.
    """
    try:
        key_path = r"Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32"
        winreg.DeleteKey(winreg.HKEY_CURRENT_USER, key_path)
        # Optionally, try to delete parent key if empty
        parent_key_path = r"Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}"
        try:
            winreg.DeleteKey(winreg.HKEY_CURRENT_USER, parent_key_path)
        except OSError:
            pass
        logging.info("Classic context menu disabled (Windows 11).")
        return True, "Classic context menu disabled."
    except FileNotFoundError:
        return True, "Classic context menu key not found (already default)."
    except Exception as e:
        logging.error(f"Failed to disable classic context menu: {e}")
        return False, f"Failed to disable classic context menu: {e}"

def is_admin():
    """Check if the script is running with administrative privileges."""
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except Exception as e:
        logging.error(f"Failed to check admin status: {e}")
        return False

def run_as_admin(action, menu_text=None, enable_classic_menu=None):
    """
    Re-launches the script with admin rights to perform a specific action.
    'action' can be 'install' or 'remove'.
    'menu_text' is optional custom text for the context menu (only used with 'install').
    'enable_classic_menu' is an optional boolean to control classic menu (only used with 'install').
    """
    if sys.platform != 'win32' and sys.platform != 'Windows':
        return False, "This feature is only for Windows."

    verb = "runas"
    executable = sys.executable  # The python interpreter

    # Use -m to run the main module
    script_entry_point = "aicodeprep_gui.main"

    if action == 'install':
        params = f'-m {script_entry_point} --install-context-menu-privileged'
        if menu_text and menu_text.strip():
            # Escape quotes and pass the menu text as an argument
            escaped_text = menu_text.replace('"', '\\"')
            params += f' --menu-text "{escaped_text}"'
        if enable_classic_menu is False:
            params += ' --disable-classic-menu'
    elif action == 'remove':
        params = f'-m {script_entry_point} --remove-context-menu-privileged'
    else:
        return False, "Invalid action."

    try:
        ret = ctypes.windll.shell32.ShellExecuteW(None, verb, executable, params, None, 1)
        if ret > 32:
            return True, "UAC prompt initiated. The application will close."
        else:
            return False, "UAC prompt was cancelled or failed."
    except Exception as e:
        logging.error(f"Failed to elevate privileges: {e}")
        return False, f"An error occurred while trying to elevate: {e}"

def get_registry_command():
    """
    Constructs the command to be written into the registry.
    Uses pythonw.exe to avoid a console window flashing on execution.
    """
    python_exe = sys.executable
    pythonw_exe = python_exe.replace("python.exe", "pythonw.exe")

    script_path = shutil.which('aicodeprep-gui')
    if not script_path:
        logging.error("Could not find 'aicodeprep-gui' script in system PATH.")
        return None

    # The command to be stored in the registry. Explorer replaces %V with the directory path.
    return f'"{pythonw_exe}" "{script_path}" "%V"'

def install_context_menu(menu_text=None, enable_classic_menu=True):
    """Adds the context menu item to the Windows Registry. Assumes admin rights."""
    if not is_admin():
        logging.error("Install function called without admin rights.")
        print("Administrator rights required.")
        return False, "Administrator rights required."

    command = get_registry_command()
    if not command:
        return False, "'aicodeprep-gui' not found. Is it installed and in your PATH?"

    # Use custom menu text if provided, otherwise use default
    if menu_text is None or menu_text.strip() == "":
        menu_text = "Open with aicodeprep-gui"
    else:
        menu_text = menu_text.strip()

    # Enable or disable classic menu as requested
    if enable_classic_menu:
        enable_classic_context_menu()
        classic_msg = "Classic context menu enabled."
    else:
        disable_classic_context_menu()
        classic_msg = "Classic context menu NOT enabled (Windows 11 default)."

    try:
        key_path = r'Directory\\Background\\shell\\aicodeprep-gui'
        with winreg.CreateKey(winreg.HKEY_CLASSES_ROOT, key_path) as key:
            winreg.SetValue(key, '', winreg.REG_SZ, menu_text)
            with winreg.CreateKey(key, 'command') as command_key:
                winreg.SetValue(command_key, '', winreg.REG_SZ, command)

        logging.info(f"Context menu installed successfully with text: '{menu_text}'")
        restart_explorer()
        return True, f"Context menu installed successfully with text: '{menu_text}'! {classic_msg} Explorer has been restarted."
    except Exception as e:
        logging.error(f"Failed to install context menu: {e}")
        return False, f"An error occurred: {e}"

def remove_context_menu():
    """Removes the context menu item from the Windows Registry. Assumes admin rights."""
    if not is_admin():
        logging.error("Remove function called without admin rights.")
        print("Administrator rights required.")
        return False, "Administrator rights required."

    # Always restore default context menu
    disable_classic_context_menu()

    try:
        key_path = r'Directory\\Background\\shell\\aicodeprep-gui'
        winreg.DeleteKey(winreg.HKEY_CLASSES_ROOT, f"{key_path}\\command")
        winreg.DeleteKey(winreg.HKEY_CLASSES_ROOT, key_path)

        logging.info("Context menu removed successfully.")
        restart_explorer()
        return True, "Context menu removed and classic menu restored! Explorer has been restarted."
    except FileNotFoundError:
        return True, "Context menu item was not found (already removed). Classic menu restored."
    except Exception as e:
        logging.error(f"Failed to remove context menu: {e}")
        return False, f"An error occurred: {e}"

def restart_explorer():
    """Restarts the Windows Explorer process to apply registry changes."""
    try:
        os.system("taskkill /f /im explorer.exe")
        os.system("start explorer.exe")
    except Exception as e:
        logging.error(f"Failed to restart explorer.exe: {e}")

</code>

aicodeprep_gui\__init__.py:
<code>
# Package initialization
__version__ = "1.0.6"

</code>

CHANGELOG.md:
<code>
# 📦 Changelog

---

## [1.0.3] - 2025-06-22

### ✨ New Features

- **Native OS Context Menu Installers:**
  - Added a `File` menu option to easily install a right-click context menu for your operating system's file manager.
  - **Windows:** "Install Right-Click Menu" dialog with options for custom menu text and enabling/disabling the classic (full) context menu for Windows 11.
  - **macOS:** "Install Finder Quick Action" to add an "Open with aicodeprep-gui" action to Finder.
  - **Linux:** "Install File Manager Action" for automated installation of a Nautilus (GNOME/Cinnamon) script, with manual instructions for other file managers.
- **Automatic Update Checker:**
  - The application now non-intrusively checks for new versions on PyPI upon startup.
  - If an update is available, a dialog will appear offering a one-click upgrade option.
- **"About" Dialog:**
  - Added a new "Help" -> "About" menu that displays the current version, update status, and how long the app has been installed.

### 🔄 Changed

- **Improved Documentation:**
  - Complete overhaul of `README.md` with a more professional tone, clearer installation instructions (recommending `pipx`), and better feature descriptions.
- **Windows Integration:**
  - The application now sets a Windows AppUserModelID for a proper, consistent taskbar icon.

### 🛠️ Technical Improvements

- **New Dependencies:** Added `requests` and `packaging` to support the new update checker.
- **New Modules:** Added `windows_registry.py`, `macos_installer.py`, `linux_installer.py`, and `update_checker.py` to modularize the new installer and update-checking logic.
- **Anonymous Telemetry:** A basic, one-way anonymous ping is sent on startup to help estimate the number of active users. This sends no personal data or code. See `PRIVACY.md` for details.

## [1.0.0] - 2025-06-20

### 🎉 Major Release - Production Ready

#### ✨ New Features

- **Enhanced Global Preset System:**

  - Global preset management using QSettings for cross-project persistence
  - Default presets: "Debug", "Security check", "Best Practices", "Please review for"
  - New ✚ and 🗑️ buttons for easy preset creation and deletion
  - Presets automatically available across all project folders
  - Improved preset UI with scrollable horizontal layout

- **Improved File Tree Experience:**

  - Enhanced tree building logic with better performance
  - Smart auto-expansion of folders containing checked files
  - Better visual feedback with hover effects on checkboxes
  - Cleaner, more intuitive folder navigation
  - Improved checkbox styling using permanent image files

- **Enhanced Output Options:**

  - Choose between XML `<code>` tags or Markdown `###` formatting via dropdown
  - Optional prompt/question text appended to output
  - Intelligent file processing with better error handling
  - Support for custom prompts with preset integration

- **Robust Configuration System:**
  - Mature TOML configuration with comprehensive default settings
  - User overrides via `aicodeprep-gui.toml` in project directories
  - `.gitignore`-style pattern matching using pathspec library
  - Extensive default exclusion patterns for common build artifacts

#### 🔄 Changed

- **Performance Improvements:**

  - Optimized file tree population with lazy loading
  - Faster initial startup times
  - Reduced memory usage during file scanning
  - More responsive UI interactions

- **User Experience Enhancements:**

  - Improved menu bar with File and Edit menus
  - Better error messages and descriptive logging
  - Enhanced drag-and-drop folder support
  - Cleaner visual design with better spacing and fonts

- **File Handling:**
  - Better binary file detection and exclusion
  - Improved relative path handling
  - Enhanced file size limits and validation
  - More robust error handling for file operations

#### 🛠️ Technical Improvements

- **Code Architecture:**

  - Comprehensive refactoring for maintainability
  - Better separation of concerns between modules
  - Improved error handling throughout the application
  - Enhanced logging with descriptive error messages

- **Dependencies:**
  - Streamlined dependency list: PySide6, toml, pathspec
  - Removed unused dependencies for cleaner installation
  - Better cross-platform compatibility

---

## [0.9.8] - 2025-06-18

### 🚀 Major Refactoring: TOML Configuration & Lazy Loading

#### ✨ New Features

- **TOML Configuration System:**

  - Replaced custom Markdown configuration with industry-standard TOML format
  - New `default_config.toml` file with comprehensive configuration options
  - Support for user-specific configuration via `aicodeprep-gui.toml` in working directory
  - `.gitignore`-style pattern matching using `pathspec` library for robust file exclusion

- **Lazy Loading File Tree:**

  - Implemented lazy loading for excluded directories (like `node_modules`, `venv`, etc.)
  - Extremely fast initial startup by avoiding scanning large excluded directories
  - On-demand expansion of any directory for fine-grained file selection
  - Users can now manually expand and select specific files from previously excluded directories

- **Enhanced Pattern Matching:**
  - All file and directory exclusion now uses `.gitignore`-style patterns
  - More powerful and standardized exclusion rules
  - Unified inclusion/exclusion lists for better organization

#### 🔄 Changed

- **Dependencies:**

  - Added `toml` for configuration parsing
  - Added `pathspec` for `.gitignore`-style pattern matching
  - Removed `tiktoken` dependency (no longer used)

- **Configuration Format:**

  - Migrated from `config.md` to `default_config.toml`
  - More structured and maintainable configuration system
  - Better support for complex exclusion patterns

- **Performance Improvements:**
  - Significantly faster startup times due to lazy loading
  - Reduced memory usage during initial file scanning
  - More responsive UI when working with large codebases

#### 🛠️ Technical Improvements

- **Code Architecture:**

  - Complete rewrite of `smart_logic.py` for better performance and maintainability
  - Improved GUI tree building logic with lazy loading support
  - Enhanced checkbox styling using Unicode characters instead of temporary files
  - Better error handling and descriptive error messages for debugging

- **File Processing:**
  - More efficient directory traversal with intelligent pruning
  - Better binary file detection and handling
  - Improved pathspec-based filtering throughout the application

---

## [0.9.7] - 2025-04-28

### ✨ New Features

- **Output Format Selection:**

  - Added dropdown menu to select output format for `fullcode.txt`
  - Options: "XML <code>" (uses `<code>...</code>` tags) or "Markdown ###" (uses `### File Path` ... `### END File Path`)

- **Prompt Presets:**

  - Users can create, save, and quickly apply preset text snippets to the LLM prompt box
  - Added "Edit" → "New Preset..." menu option and "✚" button for easy creation
  - Presets saved per-folder in `.aicodeprep` preferences file

- **Enhanced Configuration System:**

  - Default configuration loaded from `aicodeprep_gui_c/data/config.md`
  - User-specific overrides via `aicodeprep_config.md` file in working directory

- **UI & UX Improvements:**

  - Native QMainWindow menu bar ("File" → "Quit", "Edit" → "New Preset...")
  - Binary files automatically detected, greyed out, and made unselectable
  - Improved checkbox styling with programmatically generated checkmark images
  - Vertical splitter state now saved and restored via `.aicodeprep` file
  - Application style set to "Fusion" for consistent rendering

- **File & Directory Handling:**
  - Enhanced logic to skip excluded directories during initial file collection
  - Files and folders starting with dots (e.g., `.vscode`, `.idea`) skipped by default
  - Glob-style pattern matching for exclusions via `fnmatch`

### 🔄 Changed

- **Token Counting:**

  - Simplified character-based approximation (`total_chars / 4`)
  - Removed direct runtime dependency on `tiktoken` for GUI token counting

- **Preferences File:**
  - `.aicodeprep` now stores splitter state and prompt presets
  - Enhanced preference management system

### 🐛 Fixed

- Binary files can no longer be accidentally selected
- More robust directory exclusion logic

---

## [0.9.6] - 2025-05-27

### ✨ New Features

- **Dark Mode Support:**
  - Automatic theme detection based on system preferences
  - Manual dark/light mode toggle in top-right corner
  - Carefully designed dark theme palette for optimal readability

### 🔄 Changed

- **PySide6 Migration:**
  - Upgraded from PyQt5 to PySide6 for improved performance
  - Better Qt6 features and future-proofing
  - Simplified dependencies

---

## [0.9.5] - 2025-01-24

### 🎉 Added

- **macOS Support:**
  - Native macOS app bundle
  - Finder workflow integration for right-click Quick Actions
  - Tested on macOS Ventura 13.4+ (M1+)

---

## [0.5.0] - 2024-11-14

### 🎉 Added

- **Windows GUI Version:**
  - Cross-platform Qt-based GUI application
  - Right-click context menu integration for Windows Explorer
  - Enhanced file selection with granular inclusion/exclusion
  - DPI awareness for high-resolution displays

### ✨ New Features

- Interactive file selection before code preparation
- Checkbox-based file inclusion/exclusion
- Scalable UI with multiple theme options
- Windows Explorer context menu integration

### 🔄 Changed

- Enhanced configuration options
- Improved logging and error handling

---

## [0.2.2] - 2024-11-02

### 🛠️ Improvements

- Minor tweaks and bug fixes
- Performance optimizations

---

## [0.2.0] - 2024-02-11

### 🔧 Configuration Overhaul

- Moved all hard-coded options to `default_config.yaml` file

### 🎉 Added

- **New Configuration Options:**
  - `exclude_extensions` for global file type exclusion
  - `exclude_patterns` for pattern-based exclusions (e.g., `.min.js`)
  - `include_dirs` for explicit directory inclusion
  - Enhanced priority system for inclusion/exclusion rules
  - Better support for user configuration overrides

### 🔄 Changed

- **Improved Processing Logic:**
  - Clear priority rules for file inclusion/exclusion:
    1. Explicitly included files (highest priority)
    2. Explicitly excluded files
    3. Excluded extensions
    4. Code extensions (lowest priority)
  - Enhanced directory processing with priority-based logic
  - Updated exclusion patterns based on real-world usage

</code>

INSTALLER_Linux.sh:
<code>
#!/bin/bash

# ============================================================================
# aicodeprep-gui Installer for Linux
# ============================================================================
# This script attempts to automate the installation of aicodeprep-gui.
# It detects the package manager to install Python dependencies if needed,
# then uses pipx to install the application.
# ============================================================================

# Function to print and log messages
LOG_FILE="install_log_linux.txt"
log() {
    echo -e "$1" | tee -a "$LOG_FILE"
}

# Ensure the log file is clean on new run
> "$LOG_FILE"

log "--- Starting aicodeprep-gui Installer for Linux ---"
log "--- $(date) ---"
log ""

# Stop script on any error
set -e

# --- Step 1: Detect Package Manager and Install Dependencies ---
log "Step 1: Checking for dependencies (python3, python3-pip)..."

if ! command -v python3 &> /dev/null || ! python3 -m pip --version &> /dev/null; then
    log "Python3 or pip is missing. Attempting to install them."
    log "This will require administrative privileges (sudo) and will ask for your password."

    if command -v apt-get &> /dev/null; then
        log "Detected Debian/Ubuntu based system (apt)."
        sudo apt-get update
        sudo apt-get install -y python3 python3-pip
    elif command -v dnf &> /dev/null; then
        log "Detected Fedora/CentOS based system (dnf)."
        sudo dnf install -y python3 python3-pip
    elif command -v pacman &> /dev/null; then
        log "Detected Arch based system (pacman)."
        sudo pacman -Syu --noconfirm python python-pip
    elif command -v zypper &> /dev/null; then
        log "Detected OpenSUSE based system (zypper)."
        sudo zypper install -y python3 python3-pip
    else
        log "\nERROR: Could not detect a supported package manager (apt, dnf, pacman, zypper)."
        log "Please install 'python3' and 'python3-pip' manually using your system's package manager, then run this script again."
        exit 1
    fi
    log "Dependencies should now be installed."
else
    log "Dependencies (python3 and pip) are already installed."
fi
log ""

# --- Step 2: Install/Upgrade Pipx ---
log "Step 2: Installing/upgrading pipx..."
log "pipx is a tool to install Python applications in isolated environments."
python3 -m pip install --user --upgrade pipx
log "pipx installed successfully."
log ""

# --- Step 3: Add Pipx to PATH ---
log "Step 3: Ensuring pipx is in your system's PATH..."
# Note: pipx ensurepath returns a non-zero exit code if paths are already present,
# which would stop the script if `set -e` is active. So we run it carefully.
set +e
python3 -m pipx ensurepath
set -e
log "pipx paths are configured. The output above gives details."
log "You might need to add the indicated directory to your ~/.bashrc or ~/.zshrc file if it's not already there."
log ""


# --- Step 4: Install aicodeprep-gui ---
log "Step 4: Installing aicodeprep-gui..."
log "This may take a minute or two..."
# The PATH might not be updated in this current session, so we call pipx via python
python3 -m pipx install aicodeprep-gui

log ""
log "============================================================================"
log "  SUCCESS! aicodeprep-gui has been installed."
log "============================================================================"
log ""
log "  \e[1m\e[31mIMPORTANT:\e[0m You MUST close this Terminal window and open a NEW one"
log "  for the changes to take effect."
log ""
log "  After opening a new terminal, you can run the app from any"
log "  folder by typing:"
log "  \e[1maicp\e[0m"
log ""
log "============================================================================"
log "Installation script finished."

# Unset error checking
set +e
exit 0
</code>

INSTALLER_MacOS.sh:
<code>
#!/bin/bash

# ============================================================================
# aicodeprep-gui Installer for macOS
# ============================================================================
# This script automates the installation of aicodeprep-gui using Homebrew
# and pipx, which is the most robust method for macOS.
# ============================================================================

# Function to print and log messages
LOG_FILE="install_log_macos.txt"
log() {
    echo "$1" | tee -a "$LOG_FILE"
}

# Ensure the log file is clean on new run
> "$LOG_FILE"

log "--- Starting aicodeprep-gui Installer for macOS ---"
log "--- $(date) ---"
log ""

# Stop script on any error
set -e

# --- Step 1: Check for Homebrew ---
log "Step 1: Checking for Homebrew..."
if ! command -v brew &> /dev/null; then
    log "ERROR: Homebrew is not installed. Homebrew is the recommended package manager for macOS and is required by this script."
    log ""
    log "To install Homebrew, open a new Terminal window and run this command:"
    log '/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"'
    log ""
    log "After Homebrew is installed, please run this script again."
    exit 1
fi
log "Homebrew is installed."
log ""

# --- Step 2: Install/Upgrade Pipx using Homebrew ---
log "Step 2: Installing/upgrading pipx via Homebrew..."
log "pipx is a tool to install Python applications in isolated environments."
log "This may take a moment and might ask for your password..."
brew install pipx
log "pipx installed successfully."
log ""

# --- Step 3: Add Pipx to PATH ---
log "Step 3: Ensuring pipx is in your system's PATH..."
pipx ensurepath
log "pipx paths are configured. The output above gives details."
log ""

# --- Step 4: Install aicodeprep-gui ---
log "Step 4: Installing aicodeprep-gui..."
log "This may take a minute or two..."
pipx install aicodeprep-gui

log ""
log "============================================================================"
log "  SUCCESS! aicodeprep-gui has been installed."
log "============================================================================"
log ""
log "  IMPORTANT: You MUST close this Terminal window and open a NEW one"
log "  for the changes to take effect."
log ""
log "  After opening a new terminal, you can run the app from any"
log "  folder by typing:"
log "  aicp"
log ""
log "============================================================================"
log "Installation script finished."

# Unset error checking to prevent exit on non-zero from here
set +e
exit 0
</code>

INSTALLER_Windows.bat:
<code>

---
**New File: `scripts/install-windows.bat`**
```bat
@echo off
setlocal

:: ============================================================================
:: aicodeprep-gui Installer for Windows
:: ============================================================================
:: This script automates the installation of aicodeprep-gui using pipx.
:: It checks for Python, installs pipx, and then installs the application.
:: It will create a log file in this directory.
:: ============================================================================

set "LOGFILE=install_log_windows.txt"
echo. > %LOGFILE%

call :log "--- Starting aicodeprep-gui Installer for Windows ---"
call :log "--- %date% %time% ---"
call :log ""

:: --- Step 1: Find Python ---
call :log "Step 1: Checking for Python..."
set "PYTHON_CMD="

:: Check for 'py' launcher first (modern standard)
py --version >nul 2>&1
if %errorlevel% equ 0 (
    set "PYTHON_CMD=py"
    call :log "Found Python via the 'py' launcher."
) else (
    :: Fallback to 'python'
    python --version >nul 2>&1
    if %errorlevel% equ 0 (
        set "PYTHON_CMD=python"
        call :log "Found Python via the 'python' command."
    ) else (
        :: Fallback to 'python3'
        python3 --version >nul 2>&1
        if %errorlevel% equ 0 (
            set "PYTHON_CMD=python3"
            call :log "Found Python via the 'python3' command."
        )
    )
)

if not defined PYTHON_CMD (
    call :log "ERROR: Python is not installed or not found in your system's PATH."
    call :log "Please install the latest stable version of Python from:"
    call :log "https://www.python.org/downloads/windows/"
    call :log ""
    call :log "IMPORTANT: During installation, make sure to check the box that says"
    call :log "'Add Python to PATH'."
    goto :end_script
)

call :log "Python found! Using '%PYTHON_CMD%' for commands."
call :log ""

:: --- Step 2: Ensure Pip is available ---
call :log "Step 2: Checking for Pip..."
%PYTHON_CMD% -m pip --version >nul 2>&1
if %errorlevel% neq 0 (
    call :log "ERROR: Pip (Python's package installer) is not available."
    call :log "This is unusual. Your Python installation might be corrupted."
    call :log "Please try reinstalling Python from python.org."
    goto :end_script
)
call :log "Pip is available."
call :log ""

:: --- Step 3: Install/Upgrade Pipx ---
call :log "Step 3: Installing/upgrading pipx..."
call :log "pipx is a tool to install Python applications in isolated environments."
call :log "This is the recommended way to install tools like aicodeprep-gui."

%PYTHON_CMD% -m pip install --user --upgrade pipx >> %LOGFILE% 2>&1
if %errorlevel% neq 0 (
    call :log "ERROR: Failed to install pipx. Please check the log file for details:"
    call :log "%LOGFILE%"
    goto :end_script
)
call :log "pipx installed successfully."
call :log ""

:: --- Step 4: Add Pipx to PATH ---
call :log "Step 4: Ensuring pipx is in your system's PATH..."
%PYTHON_CMD% -m pipx ensurepath >> %LOGFILE% 2>&1
if %errorlevel% neq 0 (
    call :log "WARNING: 'pipx ensurepath' command failed. This might be okay."
    call :log "We will proceed, but if the 'aicp' command doesn't work later,"
    call :log "you may need to add the scripts path to your PATH environment variable manually."
) else (
    call :log "pipx paths are configured."
)
call :log ""

:: --- Step 5: Install aicodeprep-gui ---
call :log "Step 5: Installing aicodeprep-gui..."
call :log "This may take a minute or two..."
pipx install aicodeprep-gui >> %LOGFILE% 2>&1
if %errorlevel% neq 0 (
    call :log "ERROR: Failed to install aicodeprep-gui with pipx."
    call :log "Trying to upgrade it in case it's an old version..."
    pipx upgrade aicodeprep-gui >> %LOGFILE% 2>&1
    if %errorlevel% neq 0 (
      call :log "ERROR: Upgrade also failed. Please check the log file for details:"
      call :log "%LOGFILE%"
      goto :end_script
    )
)

call :log ""
call :log "============================================================================"
call :log "  SUCCESS! aicodeprep-gui has been installed."
call :log "============================================================================"
call :log ""
call :log "  IMPORTANT: You MUST close this window and open a NEW Command"
call :log "  Prompt, PowerShell, or Terminal window for the changes to take effect."
call :log ""
call :log "  After opening a new terminal, you can run the app from any"
call :log "  folder by typing:"
call :log "  aicp"
call :log ""
call :log "============================================================================"
goto :end_script

:log
echo %~1
echo %~1 >> %LOGFILE%
exit /b

:end_script
call :log ""
call :log "Installation script finished. Press any key to close this window."
pause >nul
exit /b
</code>

pyproject.toml:
<code>
[build-system]
requires = ["setuptools>=61.0.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
# CRITICAL: Changed name to match your new package name
name = "aicodeprep-gui" 
version = "1.0.6"
description = "A smart GUI to select, filter, and concatenate code files for large language model (LLM) and AI analysis."
readme = "README.md"
authors = [{ name = "Tom Brothers", email = "tom@wuu73.org" }]
license = { file = "SUSTAINABLE-LICENSE" }
classifiers = [
    # NOTE: You might want to change "Proprietary" to an open-source license like "MIT"
    # if you intend for others to use and contribute.
    "License :: Other/Proprietary License",  # Changed from OSI approved
    "Programming Language :: Python",
    "Programming Language :: Python :: 3",
    "Operating System :: OS Independent",
    "Topic :: Software Development",
    "Environment :: X11 Applications :: Qt",
    "Environment :: Win32 (MS Windows)",
    "Environment :: MacOS X",
]
keywords = ["ai", "code", "preparation", "llm", "gui", "pyside6"]
dependencies = [
    # These are the RUNTIME dependencies. Users who pip install your package need these.
    "PySide6>=6.7.0", # Simplified dependency, Essentials and Addons are included
    "toml",
    "pathspec",
    "requests", # for your network check
    "packaging"
]
requires-python = ">=3.8" # PySide6 requires Python 3.8+

[project.scripts]
# CRITICAL: Changed script name and entry point module
aicodeprep-gui = "aicodeprep_gui.main:main"
aicp = "aicodeprep_gui.main:main"

[project.urls]
# SUGGESTION: Update this once you rename the GitHub repo
Homepage = "https://github.com/detroittommy879/aicodeprep-gui" 

[tool.setuptools.packages.find]
# This is correct and will find your `aicodeprep_gui` package
where = ["."] 

[tool.setuptools.package-data]
# CRITICAL: Changed key to match your actual package name `aicodeprep_gui`
aicodeprep_gui = ["data/default_config.toml", "images/*.png", "images/*.ico"]

# SUGGESTION: Create optional dependencies for developers/builders
[project.optional-dependencies]
build = [
    "pyinstaller>=6.0.0",
    "pyinstaller-hooks-contrib",
    "setuptools",
    "wheel"
]

</code>

README.md:
<code>
# aicodeprep-gui: The fast context maker

**Context Engineering basically.. but made effortless! prepare and share project code with any AI model, on any OS, from any editor.**

[![GitHub stars](https://img.shields.io/github/stars/detroittommy879/aicodeprep-gui.svg?style=social&label=Stars)](https://github.com/detroittommy879/aicodeprep-gui/stargazers)
[![PyPI version](https://badge.fury.io/py/aicodeprep-gui.svg)](https://badge.fury.io/py/aicodeprep-gui)

Manually copying and pasting files into AI chatbots is slow, error-prone, and kills your workflow. `aicodeprep-gui` solves this with a sleek, powerful, and blazing-fast desktop application that makes preparing code context a one-click process.

It is **platform-independent** (Windows, macOS, Linux) and **IDE-independent**. Use it alongside VS Code, Cursor, Windsurf, or any other editor. It doesn't replace your agentic workflow; it works along side it, user-curated context every time.

AI models get 'dumbed down' the more irrelevant text that gets sent with your prompt - like when you are trying to fix a bug, agents (like Cursor, Cline, etc) will send huge giant pages of text about MCP servers, how to edit files etc all of that is not related to your bug. When you use the web chat interfaces, it is clean without any tools, no MCP stuff etc and it can 100% focus on your task.

This tool allows you to go from project ---> web chat very fast. It is designed to remove that friction. All the features are to save time and save you from having to do repetitive things.

![Screenshot](scrs/n1.png)

## The aicodeprep-gui Workflow

The core philosophy is simple: **You know your code best.** Instead of letting a "dumber" IDE agent guess which files are relevant, `aicodeprep-gui` puts you in control with a smart, intuitive UI.

1.  **Launch Instantly**:

    - **Right-click** any folder in your File Explorer, Finder, or Nautilus and select "Open with aicodeprep-gui".
    - _or_ Pop open a terminal and type `aicp` and press Enter.

2.  **Review Smart Selection**: The app opens instantly, having already pre-selected the most relevant files based on a `.gitignore`-style configuration.

3.  **Fine-tune & Prompt**: Quickly check/uncheck files, use powerful **prompt presets** (like one for [Cline](https://github.com/stitionai/cline)), or write a custom question.

4.  **Generate & Paste**: Click "GENERATE CONTEXT!". The entire code bundle and your prompt are **instantly copied to your clipboard**, ready to be pasted into ChatGPT, Gemini, Claude, Openrouter, or any other AI model.

5.  **Smarter AI responses and abilities**: Whenever you rely on IDE extensions or agentic IDEs to do everything, they feed too much crap into the AI which always seems to reduce its intelligence. You end up needing to use Claude for everything even minor bugs, which gets expensive. With this tool, you can use the web chat interfaces for the hard/difficult stuff, bug fixing, planning, and then paste the result back into the agent set to use a cheap unlimited model, to make the actual file changes.

## ✨ Key Features

- 🚀 **Seamless OS Integration**: The only tool of its kind with optional, native right-click context menu integration for **Windows File Explorer**, **macOS Finder**, and **Linux Nautilus**.
- 💻 **Truly Cross-Platform**: A single, consistent experience on Windows, macOS (Intel & Apple Silicon), and major Linux distributions.
- ⌨️ **Simple & Fast Commands**: Launch from anywhere by simply typing `aicp` in your terminal. Pass a directory (`aicp ./my-project`) or run it in the current folder.
- 🧠 **Intelligent File Scanning**:
  - Uses a powerful `.gitignore`-style pattern system (`aicodeprep-gui.toml`) to smartly include/exclude files.
  - Blazing-fast startup thanks to **lazy-loading**, which skips huge directories like `node_modules/` or `venv/` until you need them.
  - Remembers your file selections, window size, and layout on a per-project basis in a local `.aicodeprep-gui` file.
- 🎨 **Unique & Polished UI**:
  - A clean, modern interface built with PySide6.
  - **Automatic Light/Dark mode** detection that syncs with your OS, plus a manual toggle.
  - Satisfying, custom-styled UI components, including an intuitive file tree with hover effects.
  - Real-time **token counter** to help you stay within context limits.
- 🔧 **Powerful Prompt Engineering**:
  - Create, save, and manage **global prompt presets** that are available across all your projects.
  - Comes with useful defaults for debugging, security analysis, or generating prompts for AI agents like **Cline**.
- 🌐 **IDE & Agent Agnostic**:
  - This is **not another IDE plugin**. It's a standalone utility that enhances your workflow with _any_ tool.
  - Perfect for preparing context for agent-based IDEs like **Cursor** or **Windsurf**, or for direct use in web-based chatbots.

---

## Installation

The TL;DR version:
Make sure python is installed on your system, then install pipx. Just google how to do that or ask AI etc. Then open a fresh terminal/cmd window and type:

pipx install aicodeprep-gui

## Mac

```sh
# Install pipx using Homebrew
brew install pipx

# Add pipx to your PATH
pipx ensurepath
```

#### (then close/open a fresh new terminal window)

```sh
pipx install aicodeprep-gui
```

## Windows

Download python from python.org - pick one of the stable versions, 3.13.x is good.

Then try:

```sh
py -m pip install --user pipx
py -m pipx ensurepath
```

(if py doesn't work, try 'python' or 'python3')

Close that terminal window, and open a fresh new one (very important after installing pipx

```sh
pipx install aicodeprep-gui
```

It should say success or something similar or done.

Now that it is installed, you can type 'aicp' + enter in a terminal to run it or aicp path/to/folder/
also aicodeprep-gui works instead of aicp. aicp is shorter, both do the same thing (open the app window in whichever folder you typed it)

A common thing would be when you are using VS Code or Cursor, and whichever agent / agentic coder is pissing you off or acting stupid, go to the VS Code terminal and type 'aicp' to open it for the project you are working on.

## Linux (Debian/Ubuntu instructions here but should work on most distros)

#### Update package lists and upgrade existing packages

```sh
sudo apt update && sudo apt upgrade -y
```

#### Install pip for Python 3

```sh
sudo apt install python3-pip -y
```

#### Install and Configure pipx

Now, use pip to install pipx. It's best to install it in your user space to avoid needing sudo for Python packages.

```sh
pip3 install --user pipx
```

```sh
pipx ensurepath
```

#### IMPORTANT: After running pipx ensurepath, you must close and reopen your terminal for the PATH changes to take effect.

In a new terminal, type:

```sh
pipx install aicodeprep-gui
```

### File Explorer Integration (Optional, Recommended)

For the ultimate workflow, add the right-click menu item after installing:

1.  Run the application (`aicp`).
2.  Go to the **File** menu in the top-left corner.
3.  Select **"Install Right-Click Menu..."** (or the equivalent for your OS).
4.  Follow the on-screen instructions. A UAC prompt may appear on Windows, as this requires administrator rights.

---

## Usage

### The GUI Way

1.  **Launch**: Right-click a project folder or type `aicp` in a terminal inside the folder.
2.  **Select**: Review the automatically selected files. The app will remember your choices for the next time you open it in this folder.
3.  **Prompt (Optional)**: Click a preset button or type a question in the prompt box.
4.  **Generate**: Click **GENERATE CONTEXT!**.
5.  **Paste**: Your context is now on your clipboard. Paste it into your AI of choice.

### The Command Line

While the GUI is the main feature, you can use these command-line options:

```bash
# Run in the current directory
aicp

# Run in a specific directory
aicodeprep-gui /path/to/your/project

# See all options
aicp --help
```

---

## Configuration

`aicodeprep-gui` is powerful out of the box, but you can customize its behavior by creating an `aicodeprep-gui.toml` file in your project's root directory. This allows you to override the default filters.

**Example `aicodeprep-gui.toml`:**

```toml
# Set a different max file size in bytes
max_file_size = 2000000

# Override the default code extensions to check
code_extensions = [".py", ".js", ".ts", ".html", ".css", ".rs"]

# Add custom exclusion patterns (uses .gitignore syntax)
exclude_patterns = [
    "build/",
    "dist/",
    "*.log",
    "temp_*",
    "cache/"
]

# Add custom patterns for files that should always be checked by default
default_include_patterns = [
    "README.md",
    "main.py",
    "docs/architecture.md"
]
```

For a full list of default settings, see the [default_config.toml](aicodeprep_gui/data/default_config.toml) in the source code.

---

## Contributing

Contributions, bug reports, and feature requests are welcome! Please feel free to open an issue or submit a pull request on GitHub. Or just email me your complaints! Happy to hear from you: tom@wuu73.org

---

## Support & Donations

If this tool saves you time and makes your life easier, consider supporting its development.

| Method   | Address / Link                                                                                    |
| -------- | ------------------------------------------------------------------------------------------------- |
| Bitcoin  | `bc1qkuwhujaxhzk7e3g4f3vekpzjad2rwlh9usagy6`                                                      |
| Litecoin | `ltc1q3z327a3ea22mlhtawmdjxmwn69n65a32fek2s4`                                                     |
| Monero   | `46FzbFckBy9bbExzwAifMPBheYFb37k8ghGWSHqc6wE1BiEz6rQc2f665JmqUdtv1baRmuUEcDoJ2dpqY6Msa3uCKArszQZ` |
| CashApp  | `$lightweb73`                                                                                     |
| Website  | [https://wuu73.org/hello.html](https://wuu73.org/hello.html)                                      |

---

## License

This software uses a Sustainable License:

- ✅ Free for personal and commercial use
- ✅ Keep and modify source code
- ✅ Use app output commercially without restrictions
- ❌ Cannot sell/redistribute this software
- ❌ Cannot offer this as a hosted service

[Full license details](SUSTAINABLE-LICENSE)

</code>


aicodeprep_gui\data\AICodePrep.workflow.zip binary file skipped..


can you analyze the code, the changelog, and then update it for 1.0.6? i forgot to keep track, but a lot of it was minor bug fixes, fixed mac finder menu method etc